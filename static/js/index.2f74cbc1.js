(() => {
  var e = {
      674: function () {},
      13282: function (e, t, i) {
        var o = {
          "./jv": "24286",
          "./kk": "47772",
          "./lb": "36841",
          "./sw.js": "91172",
          "./fa": "76959",
          "./bn": "8905",
          "./it-ch.js": "10150",
          "./fr-ca.js": "63049",
          "./gu": "95349",
          "./ku-kmr.js": "90563",
          "./en-sg.js": "31662",
          "./cv.js": "50877",
          "./ug-cn": "9288",
          "./bn-bd": "76225",
          "./ar-sa.js": "16040",
          "./ar-ps": "20315",
          "./az": "31083",
          "./oc-lnc.js": "92135",
          "./sr": "49131",
          "./ar-kw.js": "96135",
          "./tlh": "89444",
          "./fi.js": "11897",
          "./tlh.js": "89444",
          "./tzm-latn.js": "30699",
          "./uk.js": "67691",
          "./si.js": "90124",
          "./yo": "75805",
          "./lo.js": "55466",
          "./zh-hk": "55726",
          "./sq": "51104",
          "./pt.js": "89520",
          "./si": "90124",
          "./sr.js": "49131",
          "./fil": "42549",
          "./hi.js": "30094",
          "./et.js": "5603",
          "./kk.js": "47772",
          "./uz-latn": "60588",
          "./bm": "67438",
          "./de": "59740",
          "./gu.js": "95349",
          "./gom-latn.js": "23168",
          "./ku": "1408",
          "./es-us.js": "71146",
          "./fy": "5044",
          "./pa-in.js": "15858",
          "./id.js": "29218",
          "./me": "39861",
          "./it.js": "90626",
          "./ja": "39183",
          "./ne": "16744",
          "./ru": "21793",
          "./sd": "40950",
          "./de-at": "60217",
          "./lo": "55466",
          "./x-pseudo": "14378",
          "./fil.js": "42549",
          "./oc-lnc": "92135",
          "./zh-mo": "99807",
          "./zh-cn.js": "83839",
          "./ja.js": "39183",
          "./da.js": "24780",
          "./zh-hk.js": "55726",
          "./gl.js": "38794",
          "./ro.js": "96459",
          "./x-pseudo.js": "14378",
          "./en-nz": "76319",
          "./br": "1278",
          "./tk.js": "19005",
          "./en-sg": "31662",
          "./cs.js": "5822",
          "./ka.js": "12105",
          "./ar-ly": "56440",
          "./ar-ps.js": "20315",
          "./fr-ch": "52330",
          "./lv": "37595",
          "./tk": "19005",
          "./ur": "13795",
          "./tzm-latn": "30699",
          "./lb.js": "36841",
          "./cy": "47373",
          "./nl-be": "59814",
          "./eu": "77763",
          "./ml": "87341",
          "./tzl": "28254",
          "./uz.js": "6791",
          "./vi": "65666",
          "./fy.js": "5044",
          "./en-il": "47207",
          "./hy-am.js": "11423",
          "./te": "23110",
          "./pt-br.js": "57971",
          "./se.js": "10490",
          "./tl-ph": "75768",
          "./es-do": "55251",
          "./zh-tw.js": "74152",
          "./mt.js": "72126",
          "./te.js": "23110",
          "./en-ca": "77925",
          "./mk.js": "95966",
          "./gl": "38794",
          "./ar-sa": "16040",
          "./gom-deva": "27884",
          "./sw": "91172",
          "./en-il.js": "47207",
          "./bg.js": "68338",
          "./ku-kmr": "90563",
          "./de.js": "59740",
          "./ar.js": "30867",
          "./fr-ca": "63049",
          "./ku.js": "1408",
          "./nn": "83877",
          "./cs": "5822",
          "./uz": "6791",
          "./bo.js": "11560",
          "./gd": "2101",
          "./hr.js": "30316",
          "./el.js": "50837",
          "./br.js": "1278",
          "./hi": "30094",
          "./bo": "11560",
          "./lt": "57010",
          "./ga": "29295",
          "./bn.js": "8905",
          "./dv.js": "5300",
          "./eu.js": "77763",
          "./sd.js": "40950",
          "./km": "18758",
          "./ky": "33291",
          "./tl-ph.js": "75768",
          "./sv": "98760",
          "./fr-ch.js": "52330",
          "./de-ch": "60894",
          "./zh-cn": "83839",
          "./af": "42786",
          "./uk": "67691",
          "./fa.js": "76959",
          "./ru.js": "21793",
          "./nl.js": "93901",
          "./tet": "52095",
          "./tr": "72397",
          "./en-gb.js": "22243",
          "./es-do.js": "55251",
          "./en-in.js": "44175",
          "./fr.js": "94470",
          "./he": "24206",
          "./sl": "14985",
          "./en-au.js": "78348",
          "./mn.js": "5115",
          "./jv.js": "24286",
          "./sl.js": "14985",
          "./dv": "5300",
          "./sk": "64249",
          "./fi": "11897",
          "./is.js": "90135",
          "./eo": "92915",
          "./tzl.js": "28254",
          "./mi": "35493",
          "./mn": "5115",
          "./ar-ma": "47702",
          "./en-nz.js": "76319",
          "./es": "55655",
          "./tzm": "51106",
          "./tr.js": "72397",
          "./mt": "72126",
          "./ta.js": "27333",
          "./pt-br": "57971",
          "./ms-my": "41237",
          "./ms-my.js": "41237",
          "./da": "24780",
          "./de-at.js": "60217",
          "./ga.js": "29295",
          "./zh-tw": "74152",
          "./sq.js": "51104",
          "./id": "29218",
          "./ms.js": "9847",
          "./bm.js": "67438",
          "./ur.js": "13795",
          "./ko": "33730",
          "./he.js": "24206",
          "./mk": "95966",
          "./kn": "79282",
          "./ky.js": "33291",
          "./en-ie.js": "46436",
          "./ar-dz": "14130",
          "./ar-ma.js": "47702",
          "./hy-am": "11423",
          "./el": "50837",
          "./ms": "9847",
          "./nl": "93901",
          "./nn.js": "83877",
          "./sr-cyrl.js": "79915",
          "./ss.js": "95606",
          "./tg.js": "27321",
          "./lt.js": "57010",
          "./ca": "2468",
          "./hu": "22138",
          "./mr": "10370",
          "./nb.js": "64924",
          "./is": "90135",
          "./sk.js": "64249",
          "./pl.js": "64495",
          "./se": "10490",
          "./fo.js": "94694",
          "./ka": "12105",
          "./lv.js": "37595",
          "./af.js": "42786",
          "./my": "56165",
          "./en-ie": "46436",
          "./tzm.js": "51106",
          "./ar-tn.js": "37100",
          "./ro": "96459",
          "./tet.js": "52095",
          "./en-ca.js": "77925",
          "./fr": "94470",
          "./gom-latn": "23168",
          "./be.js": "9808",
          "./sr-cyrl": "79915",
          "./es.js": "55655",
          "./th.js": "9041",
          "./cy.js": "47373",
          "./th": "9041",
          "./it-ch": "10150",
          "./cv": "50877",
          "./nb": "64924",
          "./hu.js": "22138",
          "./ml.js": "87341",
          "./yo.js": "75805",
          "./fo": "94694",
          "./ne.js": "16744",
          "./sv.js": "98760",
          "./it": "90626",
          "./be": "9808",
          "./kn.js": "79282",
          "./az.js": "31083",
          "./me.js": "39861",
          "./bg": "68338",
          "./bn-bd.js": "76225",
          "./my.js": "56165",
          "./ar-tn": "37100",
          "./bs.js": "80622",
          "./ar": "30867",
          "./nl-be.js": "59814",
          "./pa-in": "15858",
          "./pt": "89520",
          "./gom-deva.js": "27884",
          "./ta": "27333",
          "./tg": "27321",
          "./vi.js": "65666",
          "./zh-mo.js": "99807",
          "./de-ch.js": "60894",
          "./bs": "80622",
          "./en-au": "78348",
          "./gd.js": "2101",
          "./pl": "64495",
          "./en-gb": "22243",
          "./ss": "95606",
          "./et": "5603",
          "./km.js": "18758",
          "./ar-kw": "96135",
          "./ar-ly.js": "56440",
          "./uz-latn.js": "60588",
          "./es-us": "71146",
          "./ca.js": "2468",
          "./es-mx.js": "96112",
          "./ar-dz.js": "14130",
          "./es-mx": "96112",
          "./ug-cn.js": "9288",
          "./en-in": "44175",
          "./eo.js": "92915",
          "./hr": "30316",
          "./ko.js": "33730",
          "./mi.js": "35493",
          "./mr.js": "10370",
        };
        function s(e) {
          return Promise.resolve().then(function () {
            if (!i.o(o, e)) {
              var t = Error("Cannot find module '" + e + "'");
              throw ((t.code = "MODULE_NOT_FOUND"), t);
            }
            var s = o[e];
            return i.t(s, 23);
          });
        }
        (s.keys = () => Object.keys(o)), (s.id = 13282), (e.exports = s);
      },
      26058: function (e, t, i) {
        var o = {
          "./af": "42786",
          "./af.js": "42786",
          "./ar": "30867",
          "./ar-dz": "14130",
          "./ar-dz.js": "14130",
          "./ar-kw": "96135",
          "./ar-kw.js": "96135",
          "./ar-ly": "56440",
          "./ar-ly.js": "56440",
          "./ar-ma": "47702",
          "./ar-ma.js": "47702",
          "./ar-ps": "20315",
          "./ar-ps.js": "20315",
          "./ar-sa": "16040",
          "./ar-sa.js": "16040",
          "./ar-tn": "37100",
          "./ar-tn.js": "37100",
          "./ar.js": "30867",
          "./az": "31083",
          "./az.js": "31083",
          "./be": "9808",
          "./be.js": "9808",
          "./bg": "68338",
          "./bg.js": "68338",
          "./bm": "67438",
          "./bm.js": "67438",
          "./bn": "8905",
          "./bn-bd": "76225",
          "./bn-bd.js": "76225",
          "./bn.js": "8905",
          "./bo": "11560",
          "./bo.js": "11560",
          "./br": "1278",
          "./br.js": "1278",
          "./bs": "80622",
          "./bs.js": "80622",
          "./ca": "2468",
          "./ca.js": "2468",
          "./cs": "5822",
          "./cs.js": "5822",
          "./cv": "50877",
          "./cv.js": "50877",
          "./cy": "47373",
          "./cy.js": "47373",
          "./da": "24780",
          "./da.js": "24780",
          "./de": "59740",
          "./de-at": "60217",
          "./de-at.js": "60217",
          "./de-ch": "60894",
          "./de-ch.js": "60894",
          "./de.js": "59740",
          "./dv": "5300",
          "./dv.js": "5300",
          "./el": "50837",
          "./el.js": "50837",
          "./en-au": "78348",
          "./en-au.js": "78348",
          "./en-ca": "77925",
          "./en-ca.js": "77925",
          "./en-gb": "22243",
          "./en-gb.js": "22243",
          "./en-ie": "46436",
          "./en-ie.js": "46436",
          "./en-il": "47207",
          "./en-il.js": "47207",
          "./en-in": "44175",
          "./en-in.js": "44175",
          "./en-nz": "76319",
          "./en-nz.js": "76319",
          "./en-sg": "31662",
          "./en-sg.js": "31662",
          "./eo": "92915",
          "./eo.js": "92915",
          "./es": "55655",
          "./es-do": "55251",
          "./es-do.js": "55251",
          "./es-mx": "96112",
          "./es-mx.js": "96112",
          "./es-us": "71146",
          "./es-us.js": "71146",
          "./es.js": "55655",
          "./et": "5603",
          "./et.js": "5603",
          "./eu": "77763",
          "./eu.js": "77763",
          "./fa": "76959",
          "./fa.js": "76959",
          "./fi": "11897",
          "./fi.js": "11897",
          "./fil": "42549",
          "./fil.js": "42549",
          "./fo": "94694",
          "./fo.js": "94694",
          "./fr": "94470",
          "./fr-ca": "63049",
          "./fr-ca.js": "63049",
          "./fr-ch": "52330",
          "./fr-ch.js": "52330",
          "./fr.js": "94470",
          "./fy": "5044",
          "./fy.js": "5044",
          "./ga": "29295",
          "./ga.js": "29295",
          "./gd": "2101",
          "./gd.js": "2101",
          "./gl": "38794",
          "./gl.js": "38794",
          "./gom-deva": "27884",
          "./gom-deva.js": "27884",
          "./gom-latn": "23168",
          "./gom-latn.js": "23168",
          "./gu": "95349",
          "./gu.js": "95349",
          "./he": "24206",
          "./he.js": "24206",
          "./hi": "30094",
          "./hi.js": "30094",
          "./hr": "30316",
          "./hr.js": "30316",
          "./hu": "22138",
          "./hu.js": "22138",
          "./hy-am": "11423",
          "./hy-am.js": "11423",
          "./id": "29218",
          "./id.js": "29218",
          "./is": "90135",
          "./is.js": "90135",
          "./it": "90626",
          "./it-ch": "10150",
          "./it-ch.js": "10150",
          "./it.js": "90626",
          "./ja": "39183",
          "./ja.js": "39183",
          "./jv": "24286",
          "./jv.js": "24286",
          "./ka": "12105",
          "./ka.js": "12105",
          "./kk": "47772",
          "./kk.js": "47772",
          "./km": "18758",
          "./km.js": "18758",
          "./kn": "79282",
          "./kn.js": "79282",
          "./ko": "33730",
          "./ko.js": "33730",
          "./ku": "1408",
          "./ku-kmr": "90563",
          "./ku-kmr.js": "90563",
          "./ku.js": "1408",
          "./ky": "33291",
          "./ky.js": "33291",
          "./lb": "36841",
          "./lb.js": "36841",
          "./lo": "55466",
          "./lo.js": "55466",
          "./lt": "57010",
          "./lt.js": "57010",
          "./lv": "37595",
          "./lv.js": "37595",
          "./me": "39861",
          "./me.js": "39861",
          "./mi": "35493",
          "./mi.js": "35493",
          "./mk": "95966",
          "./mk.js": "95966",
          "./ml": "87341",
          "./ml.js": "87341",
          "./mn": "5115",
          "./mn.js": "5115",
          "./mr": "10370",
          "./mr.js": "10370",
          "./ms": "9847",
          "./ms-my": "41237",
          "./ms-my.js": "41237",
          "./ms.js": "9847",
          "./mt": "72126",
          "./mt.js": "72126",
          "./my": "56165",
          "./my.js": "56165",
          "./nb": "64924",
          "./nb.js": "64924",
          "./ne": "16744",
          "./ne.js": "16744",
          "./nl": "93901",
          "./nl-be": "59814",
          "./nl-be.js": "59814",
          "./nl.js": "93901",
          "./nn": "83877",
          "./nn.js": "83877",
          "./oc-lnc": "92135",
          "./oc-lnc.js": "92135",
          "./pa-in": "15858",
          "./pa-in.js": "15858",
          "./pl": "64495",
          "./pl.js": "64495",
          "./pt": "89520",
          "./pt-br": "57971",
          "./pt-br.js": "57971",
          "./pt.js": "89520",
          "./ro": "96459",
          "./ro.js": "96459",
          "./ru": "21793",
          "./ru.js": "21793",
          "./sd": "40950",
          "./sd.js": "40950",
          "./se": "10490",
          "./se.js": "10490",
          "./si": "90124",
          "./si.js": "90124",
          "./sk": "64249",
          "./sk.js": "64249",
          "./sl": "14985",
          "./sl.js": "14985",
          "./sq": "51104",
          "./sq.js": "51104",
          "./sr": "49131",
          "./sr-cyrl": "79915",
          "./sr-cyrl.js": "79915",
          "./sr.js": "49131",
          "./ss": "95606",
          "./ss.js": "95606",
          "./sv": "98760",
          "./sv.js": "98760",
          "./sw": "91172",
          "./sw.js": "91172",
          "./ta": "27333",
          "./ta.js": "27333",
          "./te": "23110",
          "./te.js": "23110",
          "./tet": "52095",
          "./tet.js": "52095",
          "./tg": "27321",
          "./tg.js": "27321",
          "./th": "9041",
          "./th.js": "9041",
          "./tk": "19005",
          "./tk.js": "19005",
          "./tl-ph": "75768",
          "./tl-ph.js": "75768",
          "./tlh": "89444",
          "./tlh.js": "89444",
          "./tr": "72397",
          "./tr.js": "72397",
          "./tzl": "28254",
          "./tzl.js": "28254",
          "./tzm": "51106",
          "./tzm-latn": "30699",
          "./tzm-latn.js": "30699",
          "./tzm.js": "51106",
          "./ug-cn": "9288",
          "./ug-cn.js": "9288",
          "./uk": "67691",
          "./uk.js": "67691",
          "./ur": "13795",
          "./ur.js": "13795",
          "./uz": "6791",
          "./uz-latn": "60588",
          "./uz-latn.js": "60588",
          "./uz.js": "6791",
          "./vi": "65666",
          "./vi.js": "65666",
          "./x-pseudo": "14378",
          "./x-pseudo.js": "14378",
          "./yo": "75805",
          "./yo.js": "75805",
          "./zh-cn": "83839",
          "./zh-cn.js": "83839",
          "./zh-hk": "55726",
          "./zh-hk.js": "55726",
          "./zh-mo": "99807",
          "./zh-mo.js": "99807",
          "./zh-tw": "74152",
          "./zh-tw.js": "74152",
        };
        function s(e) {
          return i(r(e));
        }
        function r(e) {
          if (!i.o(o, e)) {
            var t = Error("Cannot find module '" + e + "'");
            throw ((t.code = "MODULE_NOT_FOUND"), t);
          }
          return o[e];
        }
        (s.keys = function () {
          return Object.keys(o);
        }),
          (s.resolve = r),
          (e.exports = s),
          (s.id = 26058);
      },
      56505: function (e, t, i) {
        "use strict";
        i.r(t), i.d(t, { default: () => o });
        let o =
          '<xml xmlns="http://www.w3.org/1999/xhtml" collection="false" is_dbot="true">\n  <variables></variables>\n  <block type="trade_definition" x="0" y="0">\n    <statement name="TRADE_OPTIONS">\n      <block type="trade_definition_market" deletable="false" movable="false">\n        <field name="MARKET_LIST"></field>\n        <field name="SUBMARKET_LIST"></field>\n        <field name="SYMBOL_LIST"></field>\n        <next>\n          <block type="trade_definition_tradetype" deletable="false" movable="false">\n            <field name="TRADETYPECAT_LIST"></field>\n            <field name="TRADETYPE_LIST"></field>\n            <next>\n              <block type="trade_definition_contracttype" deletable="false" movable="false">\n                <field name="TYPE_LIST"></field>\n                <next>\n                  <block type="trade_definition_candleinterval" deletable="false" movable="false">\n                    <field name="CANDLEINTERVAL_LIST">60</field>\n                    <next>\n                      <block type="trade_definition_restartbuysell" deletable="false" movable="false">\n                        <field name="TIME_MACHINE_ENABLED">FALSE</field>\n                        <next>\n                          <block type="trade_definition_restartonerror" deletable="false" movable="false">\n                            <field name="RESTARTONERROR">TRUE</field>\n                          </block>\n                        </next>\n                      </block>\n                    </next>\n                  </block>\n                </next>\n              </block>\n            </next>\n          </block>\n        </next>\n      </block>\n    </statement>\n    <statement name="SUBMARKET">\n      <block type="trade_definition_tradeoptions">\n        <mutation has_first_barrier="false" has_second_barrier="false" has_prediction="false"></mutation>\n        <field name="DURATIONTYPE_LIST"></field>\n        <field name="CURRENCY_LIST">USD</field>\n        <value name="DURATION">\n          <shadow type="math_number_positive">\n            <field name="NUM">5</field>\n          </shadow>\n        </value>\n        <value name="AMOUNT">\n          <shadow type="math_number_positive">\n            <field name="NUM">1</field>\n          </shadow>\n        </value>\n        <field name="AMOUNT_LIMITS"></field>\n      </block>\n    </statement>\n  </block>\n  <block type="during_purchase" x="720" y="0">\n    <statement name="DURING_PURCHASE_STACK">\n      <block type="controls_if">\n        <value name="IF0">\n          <block type="check_sell"></block>\n        </value>\n      </block>\n    </statement>\n  </block>\n  <block type="after_purchase" x="720" y="248">\n    <statement name="AFTERPURCHASE_STACK">\n      <block type="trade_again"></block>\n    </statement>\n  </block>\n  <block type="before_purchase" x="0" y="576">\n    <statement name="BEFOREPURCHASE_STACK">\n      <block type="purchase">\n        <field name="PURCHASE_LIST"></field>\n      </block>\n    </statement>\n  </block>\n</xml>';
      },
      5765: function (e, t, i) {
        var o = {
          "./2025\uD83D\uDCC8\uD83D\uDCC9Dp  Printer Version1.xml": [
            "99069",
            "68",
          ],
          "./2025 No Martngale bot free.xml": ["28826", "372"],
          "./Alpha Ai  Two Predictions .xml": ["56815", "890"],
          "./2025 UPDATED DIGIT EVEN Version Bot\uD83D\uDCC8\uD83D\uDCC9.xml": [
            "95897",
            "462",
          ],
          "./2 2025 Updated Expert Speed Bot  Version \uD83D\uDCC9\uD83D\uDCC9\uD83D\uDCC9\uD83D\uDCC8\uD83D\uDCC8\uD83D\uDCC8 (1) (1).xml":
            ["97354", "820"],
          "./3 2025 Updated Version Of Candle Mine\uD83C\uDDEC\uD83C\uDDE7.xml":
            ["91837", "996"],
          "./Dp Entry point Bot V1.xml": ["44111", "705"],
          "./OVER1 BOT WITH OVER3 REVOVERY .xml": ["87378", "129"],
          "./2025 Binary Expert  Version pro .xml": ["22642", "640"],
          "./2025 Alpha Version 2025.xml": ["18117", "331"],
          "./2025 Updated Binary V5 Expert pro .xml": ["13309", "817"],
          "./1 2025 $Orginal DollarPrinterBot  2025 Version $ (1).xml": [
            "88078",
            "307",
          ],
          "./2025 BOT - 0008 - Over Under (1).xml": ["6056", "677"],
        };
        function s(e) {
          if (!i.o(o, e))
            return Promise.resolve().then(function () {
              var t = Error("Cannot find module '" + e + "'");
              throw ((t.code = "MODULE_NOT_FOUND"), t);
            });
          var t = o[e],
            s = t[0];
          return i.e(t[1]).then(function () {
            return i(s);
          });
        }
        (s.keys = () => Object.keys(o)), (s.id = 5765), (e.exports = s);
      },
      13617: function (e, t, i) {
        "use strict";
        i.d(t, { oH: () => o, om: () => a, xt: () => s });
        let o = "ce_bot_form",
          s = "No results found";
        var r,
          a =
            (((r = {}).OPEN = "open"),
            (r.CLOSE = "close"),
            (r.RUN_BOT = "run_bot"),
            (r.RUN_QUICK_STRATEGY = "run_quick_strategy"),
            (r.EDIT_QUICK_STRATEGY = "edit_quick_strategy"),
            (r.SELECT_QUICK_STRATEGY_GUIDE = "select_quick_strategy_guide"),
            (r.SWITCH_QUICK_STRATEGY_TAB = "switch_quick_strategy_tab"),
            (r.DASHBOARD_CLICK = "dashboard_click"),
            (r.UPLOAD_STRATEGY_START = "upload_strategy_start"),
            (r.UPLOAD_STRATEGY_COMPLETED = "upload_strategy_completed"),
            (r.UPLOAD_STRATEGY_FAILED = "upload_strategy_failed"),
            (r.GOOGLE_DRIVE_CONNECT = "google_drive_connect"),
            (r.GOOGLE_DRIVE_DISCONNECT = "google_drive_disconnect"),
            (r.SWITCH_LOAD_STRATEGY_TAB = "switch_load_strategy_tab"),
            (r.ANNOUNCEMENT_CLICK = "announcement_click"),
            (r.ANNOUNCEMENT_ACTION = "announcement_action"),
            r);
      },
      89057: function (e, t, i) {
        "use strict";
        i.d(t, {
          GE: () => l,
          Oi: () => c,
          WN: () => d,
          _W: () => n,
          df: () => h,
          m5: () => a,
          mu: () => u,
          z9: () => p,
        });
        var o = i(83571),
          s = i(13617),
          r = i(66062);
        let a = (e) => {
            let {
              subpage_name: t,
              subform_source: i,
              subform_name: r,
              load_strategy_tab: a,
            } = e;
            o.Analytics.trackEvent("ce_bot_form", {
              action: s.om.OPEN,
              form_name: s.oH,
              subpage_name: t,
              subform_name: r,
              subform_source: i,
              load_strategy_tab: a,
            });
          },
          n = (e) => {
            let {
              subform_name: t,
              quick_strategy_tab: i,
              selected_strategy: a,
              load_strategy_tab: n,
              announcement_name: l,
            } = e;
            o.Analytics.trackEvent("ce_bot_form", {
              action: s.om.CLOSE,
              form_name: s.oH,
              subform_name: t,
              quick_strategy_tab: i,
              strategy_name: (0, r.gc)(a),
              load_strategy_tab: n,
              announcement_name: l,
            });
          },
          l = (e) => {
            let { subpage_name: t } = e;
            o.Analytics.trackEvent("ce_bot_form", {
              action: s.om.RUN_BOT,
              form_name: s.oH,
              subpage_name: t,
            });
          },
          c = (e) => {
            let { upload_provider: t, upload_id: i } = e;
            o.Analytics.trackEvent("ce_bot_form", {
              action: s.om.UPLOAD_STRATEGY_START,
              form_name: s.oH,
              subform_name: "load_strategy",
              subpage_name: "bot_builder",
              upload_provider: t,
              upload_id: i,
            });
          },
          d = (e) => {
            let { upload_provider: t, upload_id: i, upload_type: r } = e;
            o.Analytics.trackEvent("ce_bot_form", {
              action: s.om.UPLOAD_STRATEGY_COMPLETED,
              form_name: s.oH,
              subform_name: "load_strategy",
              subpage_name: "bot_builder",
              upload_provider: t,
              upload_id: i,
              upload_type: r,
            });
          },
          u = (e) => {
            let {
              upload_provider: t,
              upload_id: i,
              upload_type: r,
              error_message: a,
              error_code: n,
            } = e;
            o.Analytics.trackEvent("ce_bot_form", {
              action: s.om.UPLOAD_STRATEGY_FAILED,
              form_name: s.oH,
              subform_name: "load_strategy",
              subpage_name: "bot_builder",
              upload_provider: t,
              upload_id: i,
              upload_type: r,
              error_message: a,
              error_code: n,
            });
          },
          h = () => {
            o.Analytics.trackEvent("ce_bot_form", {
              action: s.om.GOOGLE_DRIVE_CONNECT,
              form_name: s.oH,
              subpage_name: "bot_builder",
            });
          },
          p = () => {
            o.Analytics.trackEvent("ce_bot_form", {
              action: s.om.GOOGLE_DRIVE_DISCONNECT,
              form_name: s.oH,
              subpage_name: "bot_builder",
            });
          };
      },
      66062: function (e, t, i) {
        "use strict";
        i.d(t, { dC: () => h, gc: () => l, qc: () => u, yO: () => d });
        var o,
          s = i(85414),
          r = i(13617);
        let a = () => {
            try {
              var e;
              return JSON.parse(
                (null === (e = localStorage) || void 0 === e
                  ? void 0
                  : e.getItem("qs-analytics")) ?? "{}"
              );
            } catch (e) {
              return (
                console.error("Rudderstack: unable to get dropdown text"), {}
              );
            }
          },
          n = (e) => e && e !== r.xt,
          l = (e) => {
            var t;
            return null === (t = (0, s.j)()[e]) || void 0 === t
              ? void 0
              : t.rs_strategy_name;
          };
        var c =
          (((o = c || {}).recent = "recent"),
          (o.local = "local"),
          (o.google_drive = "google drive"),
          o);
        let d = Object.values(c),
          u = (e) => {
            let { form_values: t } = e;
            if (!t) return;
            let { symbol: i, tradetype: o, type: s, stake: r } = t,
              l = a();
            return {
              asset_type: n(null == l ? void 0 : l.symbol) ? l.symbol : i,
              trade_type: n(null == l ? void 0 : l.tradetype)
                ? null == l
                  ? void 0
                  : l.tradetype
                : o,
              purchase_condition: n(null == l ? void 0 : l.type)
                ? null == l
                  ? void 0
                  : l.type
                : s,
              initial_stake: n(null == l ? void 0 : l.stake)
                ? null == l
                  ? void 0
                  : l.stake
                : r,
            };
          },
          h = (e) => {
            try {
              let t = new DOMParser().parseFromString(
                e.toString(),
                "application/xml"
              );
              if (t.getElementsByTagName("xml").length) {
                let e = t.documentElement.getAttribute("is_dbot");
                return "true" === e ? "new" : "old";
              }
              return "old";
            } catch (e) {
              return "old";
            }
          };
      },
      59462: function (e, t, i) {
        "use strict";
        i.d(t, { Bn: () => c, tx: () => n, xG: () => l });
        var o,
          s = i(6753),
          r = i(26855),
          a = i(48059),
          n =
            (((o = {}).BOT_IMPORT = "BOT_IMPORT"),
            (o.BOT_DELETE = "BOT_DELETE"),
            o);
        let l = () => ({
            bot_stop: (0, a.NC)(
              "You’ve just stopped the bot. Any open contracts can be viewed on the Reports page."
            ),
            workspace_change: (0, a.NC)(
              "Changes you make will not affect your running bot."
            ),
            block_delete: (0, a.NC)("You’ve just deleted a block."),
            invalid_xml: (0, a.NC)(
              "Your import failed due to an invalid file. Upload a complete file in XML format."
            ),
            BOT_IMPORT: (0, a.NC)("You’ve successfully imported a bot."),
            BOT_DELETE: (0, a.NC)("You’ve successfully deleted a bot."),
            strategy_conversion: (0, a.NC)(
              "Save this strategy as an XML file from Deriv Bot for faster re-imports."
            ),
            google_drive_error: (0, a.NC)(
              "Your session has expired. Please sign in again."
            ),
          }),
          c = {
            type: s.Am.TYPE.DEFAULT,
            position: (0, r.rK)()
              ? s.Am.POSITION.BOTTOM_RIGHT
              : s.Am.POSITION.BOTTOM_LEFT,
            autoClose: 6e3,
            hideProgressBar: !0,
            closeOnClick: !1,
            pauseOnHover: !0,
            pauseOnFocusLoss: !1,
          };
      },
      64736: function (e, t, i) {
        "use strict";
        i.d(t, { J: () => l });
        var o = i(85893),
          s = i(67294),
          r = i(6753),
          a = i(59462);
        let n = (e) => {
            let { message: t, primary_action: i, closeToast: a } = e;
            return (
              s.useEffect(() => {
                let e = () => {
                  "hidden" === document.visibilityState && r.Am.dismiss();
                };
                return (
                  document.addEventListener("visibilitychange", e),
                  () => {
                    document.removeEventListener("visibilitychange", e);
                  }
                );
              }, []),
              (0, o.jsxs)("div", {
                className: "notification-content",
                "data-testid": "dt_bot_notification",
                children: [
                  (0, o.jsx)("div", { children: t }),
                  i &&
                    (0, o.jsx)("button", {
                      onClick: () => i.onClick(a),
                      children: i.label,
                    }),
                ],
              })
            );
          },
          l = (e, t, i) =>
            (0, r.Am)(
              (i) => {
                let { closeToast: s } = i;
                return (0, o.jsx)(n, {
                  message: e,
                  primary_action: t,
                  closeToast: s,
                });
              },
              {
                type: (null == i ? void 0 : i.type) ?? a.Bn.type,
                position: (null == i ? void 0 : i.position) ?? a.Bn.position,
                autoClose: (null == i ? void 0 : i.autoClose) ?? a.Bn.autoClose,
                hideProgressBar:
                  (null == i ? void 0 : i.hideProgressBar) ??
                  a.Bn.hideProgressBar,
                closeOnClick:
                  (null == i ? void 0 : i.closeOnClick) ?? a.Bn.closeOnClick,
                pauseOnHover:
                  (null == i ? void 0 : i.pauseOnHover) ?? a.Bn.pauseOnHover,
                pauseOnFocusLoss:
                  (null == i ? void 0 : i.pauseOnFocusLoss) ??
                  a.Bn.pauseOnFocusLoss,
                closeButton: (null == i ? void 0 : i.closeButton) ?? !0,
              }
            );
      },
      17481: function (e, t, i) {
        "use strict";
        i.d(t, { Gz: () => s, Lq: () => o }), i(88199);
        let o = () => ({
            au: "Australian",
            sg: "Singaporean",
            it: "Italian",
            de: "German",
            fr: "French",
            lu: "Luxembourgish",
            gr: "Greek",
            mf: "Saint Martiner",
            es: "Spanish",
            sk: "Slovak",
            lt: "Lithuanian",
            nl: "Dutch",
            at: "Austrian",
            bg: "Bulgarian",
            si: "Slovenian",
            cy: "Cypriot",
            be: "Belgian",
            ro: "Romanian",
            hr: "Croatian",
            pt: "Portuguese",
            pl: "Polish",
            lv: "Latvian",
            ee: "Estonian",
            cz: "Czech",
            fi: "Finnish",
            hu: "Hungarian",
            dk: "Danish",
            se: "Swedish",
            ie: "Irish",
            im: "Manx",
            gb: "British",
            mt: "Malta",
          }),
          s = () => ["za", "ec", "bw"];
      },
      97613: function (e, t, i) {
        "use strict";
        i.d(t, { Z: () => r });
        var o = i(85893),
          s = i(33281);
        function r(e) {
          let { message: t } = e;
          return (0, o.jsxs)("div", {
            className: "app-root",
            children: [
              (0, o.jsx)(s.a, {}),
              (0, o.jsx)("div", { className: "load-message", children: t }),
            ],
          });
        }
      },
      29656: function (e, t, i) {
        "use strict";
        i.d(t, { Yb: () => l, uw: () => a, x3: () => s });
        let o = [
            "it",
            "de",
            "fr",
            "lu",
            "gr",
            "mf",
            "es",
            "sk",
            "lt",
            "nl",
            "at",
            "bg",
            "si",
            "cy",
            "be",
            "ro",
            "hr",
            "pt",
            "pl",
            "lv",
            "ee",
            "cz",
            "fi",
            "hu",
            "dk",
            "se",
            "ie",
            "im",
            "gb",
            "mt",
          ],
          s = (e) => o.includes(e),
          r = ["de", "es", "it", "lu", "gr", "au", "fr"],
          a = (e) => r.includes(e),
          n = ["au", "fr"],
          l = (e) => n.includes(e);
      },
      66175: function (e, t, i) {
        "use strict";
        let o;
        i.d(t, {
          tmR: () => P,
          mrB: () => h.mr,
          vPG: () => R.vP,
          wmM: () => l.wm,
          hwq: () => j,
          tqC: () => F.tq,
          rhL: () => l.rh,
          L8o: () => d.L8,
          Yeo: () => d.Ye,
          FJ7: () => d.FJ,
          K9$: () => d.K9,
          Dlf: () => d.Dl,
          W9k: () => d.W9,
          lby: () => u.lb,
          O$T: () => u.O$,
          MT8: () => O.MT,
          eiS: () => R.ei,
          i4S: () => u.i4,
          LI1: () => R.LI,
          LUK: () => h.LU,
          DQA: () => c.DQ,
          cX8: () => $,
          bs3: () => u.bs,
          bfN: () => u.bf,
          uvr: () => R.uv,
          hWv: () => m,
          JIr: () => d.JI,
          QRc: () => h.QR,
          xGd: () => d.xG,
          xb4: () => R.xb,
          Kq_: () => d.Kq,
          vMw: () => d.vM,
          XtD: () => d.Xt,
          drH: () => u.dr,
          s0r: () => L.s0,
          xVn: () => _,
          oC5: () => u.oC,
          O2o: () => l.O2,
          G6W: () => n,
          gNN: () => d.gN,
          nIE: () => F.nI,
          v3q: () => d.v3,
          Lp7: () => d.Lp,
          g$d: () => u.g$,
          oS6: () => u.oS,
          FTx: () => d.FT,
          gk9: () => c.gk,
          MOe: () => d.MO,
          iBr: () => d.iB,
          xOw: () => M.x,
          kIu: () => R.kI,
          dR9: () => d.dR,
          vxy: () => d.vx,
          $Xq: () => a,
          e_e: () => l.e_,
          j73: () => D,
          _mr: () => d._m,
          Qr$: () => R.Qr,
          p6d: () => h.p6,
          fcq: () => h.fc,
          dq6: () => d.dq,
          UTW: () => d.UT,
          yvY: () => l.yv,
          _Xx: () => U,
          gbT: () => h.gb,
          CeH: () => d.Ce,
          CY$: () => L.CY,
          efd: () => d.ef,
        }),
          i(83571);
        var s = JSON.parse(
          '{"Zk":{"trader":{"name":"Deriv Trader","icon":"IcRebrandingDerivTrader"},"dbot":{"name":"Deriv Bot","icon":"IcRebrandingDerivBot"},"mt5":{"name":"Deriv MT5","icon":"IcRebrandingDmt5"},"ctrader":{"name":"Deriv cTrader","icon":"IcRebrandingCtrader"},"dxtrade":{"name":"Deriv X","icon":"IcRebrandingDxtrade"},"smarttrader":{"name":"SmartTrader","icon":"IcRebrandingSmarttrader"},"bbot":{"name":"Binary Bot","icon":"IcRebrandingBinaryBot"},"go":{"name":"Deriv GO","icon":"IcRebrandingDerivGo"}}}'
        );
        let r = (e) =>
            /^(((.*)\.)?(localhost:8444|pages.dev|binary\.(sx|com)|deriv.(com|me|be|dev)))$/.test(
              e
            ),
          a = (e) => {
            let t = s.Zk[e];
            return r(window.location.host) || (t.icon = ""), t;
          },
          n = () =>
            /constructor/i.test(window.HTMLElement) ||
            "[object SafariRemoteNotification]" ===
              (
                !window.safari ||
                (void 0 !== window.safari && window.safari.pushNotification)
              ).toString();
        var l = i(18470),
          c = i(63069),
          d = i(91761),
          u = i(52717),
          h = i(72755),
          p = i(29656);
        let _ = function (e, t, i, o) {
            let s =
                !(arguments.length > 4) ||
                void 0 === arguments[4] ||
                arguments[4],
              { title: r, text: a, link: n } = t;
            e({
              message: a,
              header: r,
              redirect_label: n,
              redirectOnClick: i,
              should_show_refresh: !1,
              redirect_to: "/appstore/traders-hub",
              should_clear_error_on_click: s,
              should_redirect: o,
            });
          },
          m = (e) =>
            (null == e ? void 0 : e.length) === 1 &&
            e.every(
              (e) =>
                (0, p.x3)(e.residence ?? "") &&
                "virtual" === e.landing_company_shortcode
            );
        i(23554),
          Object.freeze({
            amlglobalcheck: "amlglobalcheck",
            bankstatement: "bankstatement",
            docverification: "docverification",
            driverslicense: "driverslicense",
            driving_licence: "driving_licence",
            national_identity_card: "national_identity_card",
            other: "other",
            passport: "passport",
            power_of_attorney: "power_of_attorney",
            proof_of_ownership: "proof_of_ownership",
            proofaddress: "proofaddress",
            proofid: "proofid",
            utility_bill: "utility_bill",
          }),
          Object.freeze({ back: "back", front: "front", photo: "photo" });
        var g = i(68949),
          y = i(48059),
          v = i(33304),
          f = i(92198),
          b = i(45543),
          w = i(24797);
        let k = function (e) {
            return JSON.parse(this.getItem(e) || "{}");
          },
          C = function (e, t) {
            if (t && t instanceof Object)
              try {
                this.setItem(e, JSON.stringify(t));
              } catch (e) {}
          };
        "undefined" != typeof Storage &&
          ((Storage.prototype.getObject = k),
          (Storage.prototype.setObject = C));
        let T = (e) => {
            if (void 0 === e) return !1;
            let t = "test";
            try {
              return e.setItem(t, "1"), e.removeItem(t), !0;
            } catch (e) {
              return !1;
            }
          },
          N = function (e) {
            (this.storage = e),
              (this.storage.getObject = k),
              (this.storage.setObject = C);
          };
        N.prototype = {
          get(e) {
            return this.storage.getItem(e) || void 0;
          },
          set(e, t) {
            void 0 !== t && this.storage.setItem(e, t);
          },
          getObject(e) {
            return "function" == typeof this.storage.getObject
              ? this.storage.getObject(e)
              : JSON.parse(this.storage.getItem(e) || "{}");
          },
          setObject(e, t) {
            "function" == typeof this.storage.setObject
              ? this.storage.setObject(e, t)
              : this.storage.setItem(e, JSON.stringify(t));
          },
          remove(e) {
            this.storage.removeItem(e);
          },
          clear() {
            this.storage.clear();
          },
        };
        let S = function (e) {
          this.store = void 0 !== e ? e : {};
        };
        S.prototype = {
          get(e) {
            return (0, b.SX)(this.store, e);
          },
          set(e, t) {
            let i =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : this.store,
              o = e;
            Array.isArray(o) || (o = [o]),
              o.length > 1
                ? ((!(o[0] in i) || (0, b.Qr)(i[o[0]])) && (i[o[0]] = {}),
                  this.set(o.slice(1), t, i[o[0]]))
                : (i[o[0]] = t);
          },
          getObject(e) {
            return JSON.parse(this.get(e) || "{}");
          },
          setObject(e, t) {
            this.set(e, JSON.stringify(t));
          },
          remove() {
            for (var e = arguments.length, t = Array(e), i = 0; i < e; i++)
              t[i] = arguments[i];
            t.forEach((e) => {
              delete this.store[e];
            });
          },
          clear() {
            this.store = {};
          },
          has(e) {
            return void 0 !== this.get(e);
          },
          keys() {
            return Object.keys(this.store);
          },
          call(e) {
            "function" == typeof this.get(e) && this.get(e)();
          },
        };
        let x = new S();
        (x.prototype = S.prototype),
          (x.prototype.getResponse = function (e) {
            let t = e;
            if ("string" == typeof t) {
              let e = t.split(".");
              t = ["response", e[0]].concat(e);
            }
            return this.get(t);
          }),
          (x.prototype.getByMsgType = x.getResponse),
          x.set("response", {});
        let E = function (e, t) {
          let i = window.location.hostname;
          (this.initialized = !1),
            (this.cookie_name = e),
            (this.domain =
              t ||
              (i.includes("binary.sx") ? "binary.sx" : w.L.DERIV_HOST_NAME)),
            (this.path = "/"),
            (this.expires = new Date("Thu, 1 Jan 2037 12:00:00 GMT")),
            (this.value = {});
        };
        E.prototype = {
          read() {
            let e = f.Z.get(this.cookie_name);
            try {
              this.value = e ? JSON.parse(e) : {};
            } catch (e) {
              this.value = {};
            }
            this.initialized = !0;
          },
          write(e, t, i) {
            this.initialized || this.read(),
              (this.value = e),
              t && (this.expires = t),
              f.Z.set(this.cookie_name, this.value, {
                expires: this.expires,
                path: this.path,
                domain: this.domain,
                secure: !!i,
              });
          },
          get(e) {
            return this.initialized || this.read(), this.value[e];
          },
          set(e, t) {
            this.initialized || this.read(),
              (this.value[e] = t),
              f.Z.set(this.cookie_name, this.value, {
                expires: new Date(this.expires),
                path: this.path,
                domain: this.domain,
              });
          },
          remove() {
            f.Z.remove(this.cookie_name, {
              path: this.path,
              domain: this.domain,
            });
          },
        };
        let D = T(window.localStorage) ? new N(window.localStorage) : new S();
        T(window.sessionStorage) ? new N(window.sessionStorage) : new S();
        var O = i(339);
        let A = function (e, t) {
            let i =
                !(arguments.length > 2) ||
                void 0 === arguments[2] ||
                arguments[2],
              o =
                arguments.length > 3 && void 0 !== arguments[3]
                  ? arguments[3]
                  : 0;
            if (!e && T(sessionStorage)) {
              let e = window.location,
                s = i
                  ? window.location.href
                  : `${e.protocol}//${e.host}${e.pathname}`;
              sessionStorage.setItem("redirect_url", s),
                setTimeout(() => {
                  let e = I({ language: t });
                  window.location.href = e;
                }, o);
            }
          },
          I = (e) => {
            let { language: t } = e,
              i = D.get("config.server_url"),
              o = new E("signup_device").get("signup_device"),
              s = new E("date_first_contact").get("date_first_contact"),
              r = `${o ? `&signup_device=${o}` : ""}${
                s ? `&date_first_contact=${s}` : ""
              }`,
              a = () =>
                `https://oauth.${
                  w.L.DERIV_HOST_NAME
                }/oauth2/authorize?app_id=${(0,
                l.rh)()}&l=${t}${r}&brand=${v.F0.toLowerCase()}`;
            return i && /qa/.test(i)
              ? `https://${i}/oauth2/authorize?app_id=${(0,
                l.rh)()}&l=${t}${r}&brand=${v.F0.toLowerCase()}`
              : (0, l.rh)() === l.VC[window.location.hostname]
              ? a()
              : (0, O.y_)(a());
          };
        (0, g.ls)(function* (e, t) {
          let i = yield o.wait("website_status"),
            s = yield o.residenceList(),
            r = i.website_status.clients_country,
            a = (s.residence_list.find((e) => e.value === r) || {}).text,
            n = a
              ? (0, y.NC)(
                  "Sorry, this app is unavailable in {{clients_country}}.",
                  { clients_country: a }
                )
              : (0, y.NC)(
                  "Sorry, this app is unavailable in your current location."
                );
          e({
            message: (0, y.NC)("If you have an account, log in to continue."),
            header: n,
            redirect_label: (0, y.NC)("Log in"),
            redirectOnClick: () => A(t, (0, y.Jb)()),
            should_show_refresh: !1,
          });
        });
        i(85893), y.Xx, y.Xx, i(30381);
        var L = i(29398);
        i(6967);
        var R = i(11016);
        i(87537);
        var B = i(67294);
        let P = () => {
            let e = B.useRef(!1);
            return (
              B.useEffect(
                () => (
                  (e.current = !0),
                  () => {
                    e.current = !1;
                  }
                ),
                []
              ),
              () => e.current
            );
          },
          j = (e) => {
            let [t, i] = B.useState(!e);
            return (
              B.useEffect(() => {
                e && i(!0);
              }, [e]),
              { in_prop: t }
            );
          };
        i(68356), i(42238);
        let U = () => {
          let e = navigator.userAgent || navigator.vendor || window.opera || "";
          return /windows phone/i.test(e)
            ? "Windows Phone"
            : /android/i.test(e)
            ? /\bK\b|ALP-|AMN-|ANA-|ANE-|ANG-|AQM-|ARS-|ART-|ATU-|BAC-|BLA-|BRQ-|CAG-|CAM-|CAN-|CAZ-|CDL-|CDY-|CLT-|CRO-|CUN-|DIG-|DRA-|DUA-|DUB-|DVC-|ELE-|ELS-|EML-|EVA-|EVR-|FIG-|FLA-|FRL-|GLK-|HMA-|HW-|HWI-|INE-|JAT-|JEF-|JER-|JKM-|JNY-|JSC-|LDN-|LIO-|LON-|LUA-|LYA-|LYO-|MAR-|MED-|MHA-|MLA-|MRD-|MYA-|NCE-|NEO-|NOH-|NOP-|OCE-|PAR-|PIC-|POT-|PPA-|PRA-|RNE-|SEA-|SLA-|SNE-|SPN-|STK-|TAH-|TAS-|TET-|TRT-|VCE-|VIE-|VKY-|VNS-|VOG-|VTR-|WAS-|WKG-|WLZ-|JAD-|WKG-|MLD-|RTE-|NAM-|NEN-|BAL-|JAD-|JLN-|YAL/i.test(
                e
              ) || /huawei/i.test(e)
              ? "huawei"
              : "Android"
            : /iPad|iPhone|iPod/.test(e) && !window.MSStream
            ? "iOS"
            : "unknown";
        };
        var M = i(42231),
          F = i(77149);
        i(419);
        var G = i(27412),
          H = i(40968);
        let V = class {
            add(e, t) {
              this.has(e) || (this.errors[e] = []),
                -1 === this.errors[e].indexOf(t) && this.errors[e].push(t);
            }
            all() {
              return this.errors;
            }
            first(e) {
              return this.has(e) ? this.errors[e][0] : null;
            }
            get(e) {
              return this.has(e) ? this.errors[e] : [];
            }
            has(e) {
              return Object.prototype.hasOwnProperty.call(this.errors, e);
            }
            constructor() {
              (0, G._)(this, "errors", void 0), (this.errors = {});
            }
          },
          W = (e, t) => {
            let i = t;
            return (
              t && !Array.isArray(t) && (i = [t]),
              e.replace(/\[_(\d+)]/g, (e, t) => i[+t - 1])
            );
          };
        class Y {
          addFailure(e, t, i) {
            var o, s;
            let r = i || t.options.message || (0, H.Cc)()[t.name].message();
            "length" === t.name
              ? (r = W(r, [
                  t.options.min === t.options.max
                    ? (null === (o = t.options.min) || void 0 === o
                        ? void 0
                        : o.toString()) ?? ""
                    : `${t.options.min}-${t.options.max}`,
                ]))
              : "min" === t.name
              ? (r = W(r, [
                  (null === (s = t.options.min) || void 0 === s
                    ? void 0
                    : s.toString()) ?? "",
                ]))
              : "not_equal" === t.name &&
                (r = W(r, [t.options.name1 ?? "", t.options.name2 ?? ""])),
              this.errors.add(e, r),
              this.error_count++;
          }
          check() {
            return (
              Object.keys(this.input).forEach((e) => {
                Object.prototype.hasOwnProperty.call(this.rules, e) &&
                  this.rules[e].forEach((t) => {
                    let i = Y.getRuleObject(t);
                    if (
                      (!i.validator && "function" != typeof i.validator) ||
                      (i.options.condition &&
                        !i.options.condition(this.store)) ||
                      ("" === this.input[e] && "req" !== i.name)
                    )
                      return;
                    let o = i.validator(
                      this.input[e],
                      i.options,
                      this.store,
                      this.input
                    );
                    if ("boolean" != typeof o || o) {
                      if ("object" == typeof o) {
                        let { is_ok: t, message: s } = o;
                        t || this.addFailure(e, i, s);
                      }
                    } else this.addFailure(e, i);
                  });
              }),
              !this.error_count
            );
          }
          isPassed() {
            return this.check();
          }
          static getRuleObject(e) {
            let t = "string" == typeof e,
              i = t ? e : e[0],
              o = t ? {} : e[1] || {};
            return {
              name: i,
              options: o,
              validator: "custom" === i ? o.func : (0, H.Cc)()[i].func,
            };
          }
          constructor(e, t, i) {
            (0, G._)(this, "input", void 0),
              (0, G._)(this, "rules", void 0),
              (0, G._)(this, "store", void 0),
              (0, G._)(this, "errors", void 0),
              (0, G._)(this, "error_count", void 0),
              (this.input = e),
              (this.rules = t),
              (this.store = i),
              (this.errors = new V()),
              (this.error_count = 0);
          }
        }
        let $ = Y;
      },
      18470: function (e, t, i) {
        "use strict";
        i.d(t, {
          e_: () => p,
          zY: () => l,
          VC: () => n,
          O2: () => g,
          wm: () => m,
          yv: () => c,
          rh: () => _,
        });
        var o = i(12838);
        let s = function () {
            let e =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : window.location.hostname,
              t = {
                is_staging_deriv_app: /^staging-app\.deriv\.(com|me|be)$/i.test(
                  e
                ),
                is_deriv_app: /^app\.deriv\.(com|me|be)$/i.test(e),
                is_test_link: /^(.*)\.binary\.sx$/i.test(e),
                is_test_deriv_app: /^test-app\.deriv\.com$/i.test(e),
              };
            return {
              ...t,
              is_staging: t.is_staging_deriv_app,
              is_test_link: t.is_test_link,
            };
          },
          r = function () {
            let e =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : window.location.hostname,
              { is_staging_deriv_app: t } = s(e);
            return t;
          },
          a = {
            LOCALHOST: 76083,
            TMP_STAGING: 76083,
            STAGING: 76083,
            STAGING_BE: 76083,
            STAGING_ME: 76083,
            PRODUCTION: 76083,
            PRODUCTION_BE: 76083,
            PRODUCTION_ME: 76083,
          },
          n = {
            "master.bot-standalone.pages.dev": a.TMP_STAGING,
            "staging-dbot.deriv.com": a.STAGING,
            "staging-dbot.deriv.be": a.STAGING_BE,
            "staging-dbot.deriv.me": a.STAGING_ME,
            "dbot.deriv.com": a.PRODUCTION,
            "dbot.deriv.be": a.PRODUCTION_BE,
            "dbot.deriv.me": a.PRODUCTION_ME,
            "geetrading.web.app": a.PRODUCTION,
          },
          l = () =>
            !/^staging\./.test(window.location.hostname) &&
            Object.keys(n).find((e) => window.location.hostname === e),
          c = () => {
            let e = Object.keys(n).map(
              (e) => `(www\\.)?${e.replace(".", "\\.")}`
            );
            return RegExp(`^(${e.join("|")})$`, "i").test(
              window.location.hostname
            );
          },
          d = () => {
            var e, t;
            return (
              (null === (e = window.location.origin) || void 0 === e
                ? void 0
                : e.includes(".binary.sx")) ||
              (null === (t = window.location.origin) || void 0 === t
                ? void 0
                : t.includes("bot-65f.pages.dev")) ||
              u()
            );
          },
          u = () => /localhost(:\d+)?$/i.test(window.location.hostname),
          h = () => "ws.derivws.com",
          p = () => {
            let e = h();
            return d()
              ? { app_id: a.LOCALHOST, server_url: e }
              : { app_id: n[l() ?? ""] ?? a.PRODUCTION, server_url: e };
          },
          _ = () => {
            let e = null,
              t = window.localStorage.getItem("config.app_id"),
              i = l() ?? "";
            return (
              console.log("Config app_id:", t),
              console.log("Current domain:", i),
              console.log("Is test link:", d()),
              console.log(
                "Selected app_id:",
                (e =
                  t ||
                  (r() ? a.STAGING : d() ? a.LOCALHOST : n[i] ?? a.PRODUCTION))
              ),
              e
            );
          },
          m = () => {
            let e = window.localStorage.getItem("config.server_url");
            return e || h();
          },
          g = () => {
            let e = _();
            console.log("OAuth app_id to use:", e);
            let { getOauthURL: t } = o.fr,
              i = t();
            console.log("Original OAuth URL:", i),
              console.log(
                "Modified OAuth URL:",
                (i = i.replace(/app_id=\d+/, `app_id=${e}`))
              );
            let s = new URL(i),
              r =
                o.fV.getValue(o.sE.configServerURL) ||
                localStorage.getItem("config.server_url") ||
                s.hostname,
              a = [
                "green.derivws.com",
                "red.derivws.com",
                "blue.derivws.com",
                "ws.derivws.com",
              ];
            ("string" == typeof r
              ? a.includes(r)
              : a.includes(JSON.stringify(r))) || (s.hostname = r);
            let n = s.toString() || i;
            return console.log("Final OAuth URL:", n), n;
          };
        console.log("Current hostname:", window.location.hostname),
          console.log(
            "Active login ID:",
            window.localStorage.getItem("active_loginid")
          ),
          console.log("App ID:", _()),
          console.log("Server URL:", m());
      },
      6967: function (e, t, i) {
        "use strict";
        i.d(t, { gk: () => s }), i(67294);
        var o = i(48059);
        i(91761);
        let s = () => ({
          APPLY: (0, o.NC)("Apply"),
          BARRIER: (0, o.NC)("Barrier:"),
          BUY_PRICE: (0, o.NC)("Buy price:"),
          CANCEL: (0, o.NC)("Cancel"),
          CLOSE: (0, o.NC)("Close"),
          CLOSED: (0, o.NC)("Closed"),
          CONTRACT_COST: (0, o.NC)("Contract cost:"),
          CONTRACT_VALUE: (0, o.NC)("Contract value:"),
          CURRENT_STAKE: (0, o.NC)("Current stake:"),
          DAY: (0, o.NC)("day"),
          DAYS: (0, o.NC)("days"),
          DEAL_CANCEL_FEE: (0, o.NC)("Deal cancel. fee:"),
          DECREMENT_VALUE: (0, o.NC)("Decrement value"),
          DONT_SHOW_THIS_AGAIN: (0, o.NC)("Don't show this again"),
          ENTRY_SPOT: (0, o.NC)("Entry spot:"),
          INCREMENT_VALUE: (0, o.NC)("Increment value"),
          INDICATIVE_PRICE: (0, o.NC)("Indicative price:"),
          INITIAL_STAKE: (0, o.NC)("Initial stake:"),
          LOST: (0, o.NC)("Lost"),
          MULTIPLIER: (0, o.NC)("Multiplier:"),
          NOT_AVAILABLE: (0, o.NC)("N/A"),
          PAYOUT: (0, o.NC)("Sell price:"),
          POTENTIAL_PAYOUT: (0, o.NC)("Potential payout:"),
          POTENTIAL_PROFIT_LOSS: (0, o.NC)("Potential profit/loss:"),
          PROFIT_LOSS: (0, o.NC)("Profit/Loss:"),
          PURCHASE_PRICE: (0, o.NC)("Buy price:"),
          RESALE_NOT_OFFERED: (0, o.NC)("Resale not offered"),
          SELL: (0, o.NC)("Sell"),
          STAKE: (0, o.NC)("Stake:"),
          STOP_LOSS: (0, o.NC)("Stop loss:"),
          STRIKE: (0, o.NC)("Strike:"),
          TAKE_PROFIT: (0, o.NC)("Take profit:"),
          TICK: (0, o.NC)("Tick "),
          TICKS: (0, o.NC)("Ticks"),
          TOTAL_PROFIT_LOSS: (0, o.NC)("Total profit/loss:"),
          TAKE_PROFIT_LOSS_NOT_AVAILABLE: (0, o.NC)(
            "Take profit and/or stop loss are not available while deal cancellation is active."
          ),
          WON: (0, o.NC)("Won"),
        });
      },
      63069: function (e, t, i) {
        "use strict";
        i.d(t, { sJ: () => n, Re: () => a, DQ: () => o, gk: () => s.gk });
        let o = Object.freeze({
          LOW_RISK_CR_EU: "low_risk_cr_eu",
          LOW_RISK_CR_NON_EU: "low_risk_cr_non_eu",
          HIGH_RISK_CR: "high_risk_cr",
          CR_DEMO: "cr_demo",
          EU_DEMO: "eu_demo",
          EU_REAL: "eu_real",
        });
        var s = i(6967),
          r = i(48059);
        let a = () => (0, r.NC)("No results found"),
          n = () => ({
            header: (0, r.NC)("Sorry for the interruption"),
            description: (0, r.NC)(
              "Our servers hit a bump. Let’s refresh to move on."
            ),
            cta_label: (0, r.NC)("Refresh"),
          });
        Object.freeze({
          NONE: "none",
          PENDING: "pending",
          REJECTED: "rejected",
          VERIFIED: "verified",
          EXPIRED: "expired",
          SUSPECTED: "suspected",
        }),
          Object.freeze({
            SVG: "svg",
            BVI: "bvi",
            VANUATU: "vanuatu",
            LABUAN: "labuan",
            MALTA_INVEST: "maltainvest",
          }),
          Object.freeze({ DXTRADE: "dxtrade", MT5: "mt5" }),
          Object.freeze({
            FAILED: "failed",
            MIGRATED_WITH_POSITION: "migrated_with_position",
            MIGRATED_WITHOUT_POSITION: "migrated_without_position",
            NEEDS_VERIFICATION: "needs_verification",
            PENDING: "pending",
            POA_PENDING: "poa_pending",
            POA_VERIFIED: "poa_verified",
          });
        var l = i(85893);
        i(67294),
          Object.freeze({
            DobMismatch: {
              code: "DobMismatch",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text:
                  "The <0>date of birth</0> on your identity document doesn't match your profile.",
                components: [(0, l.jsx)("strong", {}, 0)],
              }),
            },
            DocumentRejected: {
              code: "DocumentRejected",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text:
                  "We were unable to verify the identity document with the details provided.",
              }),
            },
            EmptyStatus: {
              code: "EmptyStatus",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text:
                  "The verification status was empty, rejected for lack of information.",
              }),
            },
            Expired: {
              code: "Expired",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text: "Your identity document has expired.",
              }),
            },
            InformationLack: {
              code: "InformationLack",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text:
                  "The verification is passed but the personal info is not available to compare.",
              }),
            },
            MalformedJson: {
              code: "MalformedJson",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text:
                  "The verification status is not available, provider says: Malformed JSON.",
              }),
            },
            NameMismatch: {
              code: "NameMismatch",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text:
                  "The <0>name</0> on your identity document doesn't match your profile.",
                components: [(0, l.jsx)("strong", {}, 0)],
              }),
            },
            RejectedByProvider: {
              code: "RejectedByProvider",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text: "The document was rejected by the Provider.",
              }),
            },
            Underage: {
              code: "Underage",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text: "You’re under legal age.",
              }),
            },
            Deceased: {
              code: "Deceased",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text: "The document’s owner is deceased.",
              }),
            },
            Failed: {
              code: "Failed",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text:
                  "We were unable to verify the identity document with the details provided.",
              }),
            },
            NameDobMismatch: {
              code: "NameDobMismatch",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text:
                  "The <0>name</0> and <0>date of birth</0> on your identity document don't match your profile.",
                components: [(0, l.jsx)("strong", {}, 0)],
              }),
            },
            NeedsTechnicalInvestigation: {
              code: "NeedsTechnicalInvestigation",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text:
                  "The verification status is not available, provider says: Needs Technical Investigation.",
              }),
            },
            HighRisk: {
              code: "HighRisk",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text:
                  "For enhanced security, we need to reverify your identity. Kindly resubmit your proof of identity to unlock your account.",
              }),
            },
            ReportNotAvailable: {
              code: "ReportNotAvailable",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text:
                  "We were unable to verify the identity document with the details provided.",
              }),
            },
          }),
          Object.freeze({
            AgeValidationMinimumAcceptedAge: {
              code: "AgeValidationMinimumAcceptedAge",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text:
                  "Your age in the document you provided appears to be below 18 years. We’re only allowed to offer our services to clients above 18 years old, so we’ll need to close your account. If you have a balance in your account, contact us via live chat and we’ll help to withdraw your funds before your account is closed.",
              }),
            },
            CompromisedDocument: {
              code: "CompromisedDocument",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text:
                  "Your document failed our verification checks.",
              }),
            },
            DataComparisonDateOfBirth: {
              code: "DataComparisonDateOfBirth",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text:
                  "The date of birth on your document doesn’t match your profile.",
              }),
            },
            DataComparisonDateOfExpiry: {
              code: "DataComparisonDateOfExpiry",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text: "Your document has expired.",
              }),
            },
            DataComparisonDocumentNumbers: {
              code: "DataComparisonDocumentNumbers",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text: "Your document appears to be invalid.",
              }),
            },
            DataComparisonDocumentType: {
              code: "DataComparisonDocumentType",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text: "Your document appears to be invalid.",
              }),
            },
            DataComparisonIssuingCountry: {
              code: "DataComparisonIssuingCountry",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text: "Your document appears to be invalid.",
              }),
            },
            DataComparisonName: {
              code: "DataComparisonName",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text:
                  "The name on your document doesn’t match your profile.",
              }),
            },
            DataValidationDateOfBirth: {
              code: "DataValidationDateOfBirth",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text:
                  "Some details on your document appear to be invalid, missing, or unclear.",
              }),
            },
            DataValidationDocumentExpiration: {
              code: "DataValidationDocumentExpiration",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text: "Your document has expired.",
              }),
            },
            DataValidationDocumentNumbers: {
              code: "DataValidationDocumentNumbers",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text:
                  "Some details in your document appear to be invalid, missing, or unclear.",
              }),
            },
            DataValidationExpiryDate: {
              code: "DataValidationExpiryDate",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text:
                  "Some details on your document appear to be invalid, missing, or unclear.",
              }),
            },
            DataValidationMrz: {
              code: "DataValidationMrz",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text:
                  "Some details on your document appear to be invalid, missing, or unclear.",
              }),
            },
            DataValidationNoDocumentNumbers: {
              code: "DataValidationNoDocumentNumbers",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text:
                  "The serial number of your document couldn’t be verified.",
              }),
            },
            DuplicatedDocument: {
              code: "DuplicatedDocument",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text:
                  "Your verification documents were already used for another account.",
              }),
            },
            Expired: {
              code: "Expired",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text: "Your document has expired.",
              }),
            },
            ImageIntegrityColourPicture: {
              code: "ImageIntegrityColourPicture",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text:
                  "Your document appears to be in black and white. Please upload a colour photo of your document.",
              }),
            },
            ImageIntegrityConclusiveDocumentQuality: {
              code: "ImageIntegrityConclusiveDocumentQuality",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text: "Your document appears to be invalid.",
              }),
            },
            ImageIntegrityConclusiveDocumentQualityAbnormalDocumentFeatures: {
              code: "ImageIntegrityConclusiveDocumentQualityAbnormalDocumentFeatures",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text:
                  "Some details on your document appear to be invalid, missing, or unclear.",
              }),
            },
            ImageIntegrityConclusiveDocumentQualityCornerRemoved: {
              code: "ImageIntegrityConclusiveDocumentQualityCornerRemoved",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text:
                  "Your document appears to be damaged or cropped.",
              }),
            },
            ImageIntegrityConclusiveDocumentQualityDigitalDocument: {
              code: "ImageIntegrityConclusiveDocumentQualityDigitalDocument",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text:
                  "Your document appears to be a digital document.",
              }),
            },
            ImageIntegrityConclusiveDocumentQualityMissingBack: {
              code: "ImageIntegrityConclusiveDocumentQualityMissingBack",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text:
                  "The back of your document appears to be missing. Please include both sides of your identity document.",
              }),
            },
            ImageIntegrityConclusiveDocumentQualityObscuredDataPoints: {
              code: "ImageIntegrityConclusiveDocumentQualityObscuredDataPoints",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text:
                  "Some details on your document appear to be invalid, missing, or unclear.",
              }),
            },
            ImageIntegrityConclusiveDocumentQualityObscuredSecurityFeatures: {
              code: "ImageIntegrityConclusiveDocumentQualityObscuredSecurityFeatures",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text:
                  "Some details on your document appear to be invalid, missing, or unclear.",
              }),
            },
            ImageIntegrityConclusiveDocumentQualityPuncturedDocument: {
              code: "ImageIntegrityConclusiveDocumentQualityPuncturedDocument",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text:
                  "Your document appears to be damaged or cropped.",
              }),
            },
            ImageIntegrityConclusiveDocumentQualityWatermarksDigitalTextOverlay:
              {
                code: "ImageIntegrityConclusiveDocumentQualityWatermarksDigitalTextOverlay",
                message: (0, l.jsx)(r.Xx, {
                  i18n_default_text:
                    "Your document contains markings or text that should not be on your document.",
                }),
              },
            ImageIntegrityImageQuality: {
              code: "ImageIntegrityImageQuality",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text:
                  "The image quality of your document is too low. Please provide a hi-res photo of your identity document.",
              }),
            },
            ImageIntegrityImageQualityBlurredPhoto: {
              code: "ImageIntegrityImageQualityBlurredPhoto",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text:
                  "We were unable to verify your selfie because it’s not clear. Please take a clearer photo and try again. Ensure that there's enough light where you are and that your entire face is in the frame.",
              }),
            },
            ImageIntegrityImageQualityCoveredPhoto: {
              code: "ImageIntegrityImageQualityCoveredPhoto",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text:
                  "We’re unable to verify the document you provided because some details appear to be missing. Please try again or provide another document.",
              }),
            },
            ImageIntegrityImageQualityCutOffDocument: {
              code: "ImageIntegrityImageQualityCutOffDocument",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text:
                  "We’re unable to verify the document you provided because it appears to be damaged. Please try again or upload another document.",
              }),
            },
            ImageIntegrityImageQualityDamagedDocument: {
              code: "ImageIntegrityImageQualityDamagedDocument",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text:
                  "We’re unable to verify the document you provided because it appears to be damaged. Please try again or upload another document.",
              }),
            },
            ImageIntegrityImageQualityDarkPhoto: {
              code: "ImageIntegrityImageQualityDarkPhoto",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text:
                  "We were unable to verify your selfie because it’s not clear. Please take a clearer photo and try again. Ensure that there’s enough light where you are and that your entire face is in the frame.",
              }),
            },
            ImageIntegrityImageQualityGlareOnPhoto: {
              code: "ImageIntegrityImageQualityGlareOnPhoto",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text:
                  "We were unable to verify your selfie because it’s not clear. Please take a clearer photo and try again. Ensure that there’s enough light where you are and that your entire face is in the frame.",
              }),
            },
            ImageIntegrityImageQualityIncorrectSide: {
              code: "ImageIntegrityImageQualityIncorrectSide",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text:
                  "The front of your document appears to be missing. Please provide both sides of your identity document.",
              }),
            },
            ImageIntegrityImageQualityNoDocumentInImage: {
              code: "ImageIntegrityImageQualityNoDocumentInImage",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text:
                  "We’re unable to verify the document you provided because it appears to be a blank image. Please try again or upload another document.",
              }),
            },
            ImageIntegrityImageQualityOtherPhotoIssue: {
              code: "ImageIntegrityImageQualityOtherPhotoIssue",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text:
                  "We’re unable to verify the document you provided because some details appear to be missing. Please try again or provide another document.",
              }),
            },
            ImageIntegrityImageQualityTwoDocumentsUploaded: {
              code: "ImageIntegrityImageQualityTwoDocumentsUploaded",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text:
                  "The document you provided appears to be two different types. Please try again or provide another document.",
              }),
            },
            ImageIntegritySupportedDocument: {
              code: "ImageIntegritySupportedDocument",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text:
                  "The document you provided is not supported for your country. Please provide a supported document for your country.",
              }),
            },
            SelfieRejected: {
              code: "SelfieRejected",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text: "Your selfie does not match your document.",
              }),
            },
            VisualAuthenticityDigitalTampering: {
              code: "VisualAuthenticityDigitalTampering",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text: "Your document appears to be invalid.",
              }),
            },
            VisualAuthenticityFaceDetection: {
              code: "VisualAuthenticityFaceDetection",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text: "Your document appears to be invalid.",
              }),
            },
            VisualAuthenticityFonts: {
              code: "VisualAuthenticityFonts",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text: "Your document appears to be invalid.",
              }),
            },
            VisualAuthenticityOriginalDocumentPresent: {
              code: "VisualAuthenticityOriginalDocumentPresent",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text:
                  "Your document appears to be a scanned copy that contains markings or text that shouldn’t be on your document.",
              }),
            },
            VisualAuthenticityOriginalDocumentPresentDocumentOnPrintedPaper: {
              code: "VisualAuthenticityOriginalDocumentPresentDocumentOnPrintedPaper",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text:
                  "Your document appears to be a printed copy.",
              }),
            },
            VisualAuthenticityOriginalDocumentPresentPhotoOfScreen: {
              code: "VisualAuthenticityOriginalDocumentPresentPhotoOfScreen",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text:
                  "Your document appears to be a photo of a device screen.",
              }),
            },
            VisualAuthenticityOriginalDocumentPresentScan: {
              code: "VisualAuthenticityOriginalDocumentPresentScan",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text:
                  "We’re unable to verify the document you provided because it contains markings or text that should not be on your document. Please provide a clear photo or a scan of your original identity document.",
              }),
            },
            VisualAuthenticityOriginalDocumentPresentScreenshot: {
              code: "VisualAuthenticityOriginalDocumentPresentScreenshot",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text: "Your document appears to be a screenshot.",
              }),
            },
            VisualAuthenticityPictureFaceIntegrity: {
              code: "VisualAuthenticityPictureFaceIntegrity",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text: "Your document appears to be invalid.",
              }),
            },
            VisualAuthenticitySecurityFeatures: {
              code: "VisualAuthenticitySecurityFeatures",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text: "Your document appears to be invalid.",
              }),
            },
            VisualAuthenticityTemplate: {
              code: "VisualAuthenticityTemplate",
              message: (0, l.jsx)(r.Xx, {
                i18n_default_text: "Your document appears to be invalid.",
              }),
            },
          }),
          Object.freeze({
            EMPLOYED: "Employed",
            UNEMPLOYED: "Unemployed",
            SELF_EMPLOYED: "Self-Employed",
          });
      },
      91761: function (e, t, i) {
        "use strict";
        i.d(t, {
          v3: () => E,
          FT: () => d,
          FJ: () => g,
          Xt: () => w,
          Ce: () => _,
          vx: () => x,
          L8: () => k,
          Lp: () => j,
          vM: () => O,
          W9: () => B,
          dq: () => I,
          Dl: () => v,
          iB: () => f,
          Ye: () => T,
          dR: () => L,
          gN: () => A,
          _m: () => b,
          xG: () => N,
          MO: () => C,
          ef: () => R,
          K9: () => U,
          UT: () => m,
          Kq: () => p,
          JI: () => M,
        });
        var o = i(85893);
        i(67294);
        var s = i(30381),
          r = i.n(s),
          a = i(48059),
          n = i(11016),
          l = i(29398),
          c = i(46677);
        let d = {
          ACCUMULATOR: "ACCU",
          ASIAN: { UP: "ASIANU", DOWN: "ASIAND" },
          CALL: "CALL",
          CALLE: "CALLE",
          CALL_BARRIER: "CALL_BARRIER",
          CALL_PUT_SPREAD: { CALL: "CALLSPREAD", PUT: "PUTSPREAD" },
          END: { IN: "EXPIRYRANGE", OUT: "EXPIRYMISS" },
          EVEN_ODD: { ODD: "DIGITODD", EVEN: "DIGITEVEN" },
          EXPIRYRANGEE: "EXPIRYRANGEE",
          FALL: "FALL",
          HIGHER: "HIGHER",
          LB_HIGH_LOW: "LBHIGHLOW",
          LB_CALL: "LBFLOATCALL",
          LB_PUT: "LBFLOATPUT",
          LOWER: "LOWER",
          MATCH_DIFF: { MATCH: "DIGITMATCH", DIFF: "DIGITDIFF" },
          MULTIPLIER: { UP: "MULTUP", DOWN: "MULTDOWN" },
          OVER_UNDER: { OVER: "DIGITOVER", UNDER: "DIGITUNDER" },
          PUT: "PUT",
          PUTE: "PUTE",
          PUT_BARRIER: "PUT_BARRIER",
          RESET: { CALL: "RESETCALL", PUT: "RESETPUT" },
          RISE: "RISE",
          RUN_HIGH_LOW: { HIGH: "RUNHIGH", LOW: "RUNLOW" },
          STAY: { IN: "RANGE", OUT: "UPORDOWN" },
          TICK_HIGH_LOW: { HIGH: "TICKHIGH", LOW: "TICKLOW" },
          TOUCH: { ONE_TOUCH: "ONETOUCH", NO_TOUCH: "NOTOUCH" },
          TURBOS: { LONG: "TURBOSLONG", SHORT: "TURBOSSHORT" },
          VANILLA: { CALL: "VANILLALONGCALL", PUT: "VANILLALONGPUT" },
        };
        d.TURBOS.LONG.toLowerCase(),
          d.TURBOS.SHORT.toLowerCase(),
          d.VANILLA.CALL.toLowerCase(),
          d.VANILLA.PUT.toLowerCase();
        let u = (e) => {
            let {
              contract_type: t,
              exit_tick_time: i,
              profit: o,
              status: s,
            } = e;
            return w(t)
              ? ("open" === s && !i && "open") ||
                  (o && o < 0 && i ? "lost" : "won")
              : s;
          },
          h = (e) => e.sell_price || e.bid_price,
          p = (e) => (h(e) && m(e) ? h(e) : Number(e.bid_price)),
          _ = (e) => {
            let { cancellation: { ask_price: t = 0 } = {} } = e;
            return t;
          },
          m = (e) =>
            !!(
              (e.status && "open" !== e.status) ||
              e.is_expired ||
              e.is_settleable
            ),
          g = (e) => "open" === u(e),
          y = (e) => "sold" === e.status,
          v = (e) => !!e.is_valid_to_cancel,
          f = (e) => !m(e) && !y(e) && !!e.is_valid_to_sell,
          b = (e) => !!e.entry_spot,
          w = function () {
            let e =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : "";
            return /ACCU/i.test(e);
          },
          k = function () {
            let e =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : "";
            return /MULT/i.test(e);
          },
          C = function () {
            let e =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : "";
            return /TURBOS/i.test(e);
          },
          T = function () {
            let e =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : "";
            return /VANILLA/i.test(e);
          },
          N = function () {
            let e =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : "";
            return /RUN|EXPIRY|RANGE|UPORDOWN|ASIAN|RESET|TICK|LB/i.test(e);
          },
          S = function () {
            let e =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : "";
            return /ASIAN/i.test(e);
          },
          x = function () {
            let e =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : "";
            return /LB/i.test(e);
          },
          E = (e) => {
            let t = (0, n.Tw)(e.tick_stream || [], "epoch"),
              i =
                D(e.contract_type) || S(e.contract_type)
                  ? t.length
                  : t.length - 1;
            return !i || i < 0 ? 0 : i;
          },
          D = function () {
            let e =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : "";
            return /digit/i.test(e);
          },
          O = (e) => Number(e.bid_price) - Number(e.buy_price),
          A = (e) => {
            if (!e) return { stop_loss: null, take_profit: null };
            let {
              stop_loss: { order_amount: t } = {},
              take_profit: { order_amount: i } = {},
            } = e;
            return { stop_loss: t, take_profit: i };
          },
          I = (e, t, i) => {
            let o = r().duration(r().unix(i).diff(r().unix(t))),
              s =
                (r().duration(r().unix(i).diff(e)).asMilliseconds() /
                  o.asMilliseconds()) *
                100;
            return s < 0.5 ? (s = 0) : s > 100 && (s = 100), Math.round(s);
          },
          L = (e) => 100 * e,
          R = (e) => {
            let t = "purchased";
            return m(e) && (t = O(e) >= 0 ? "won" : "lost"), t;
          },
          B = (e) => {
            let { contract_update: t, limit_order: i } = e,
              { stop_loss: o, take_profit: s } = A(i || t);
            return {
              contract_update_stop_loss: o ? Math.abs(o).toString() : "",
              contract_update_take_profit: s ? s.toString() : "",
              has_contract_update_stop_loss: !!o,
              has_contract_update_take_profit: !!s,
            };
          },
          P = function () {
            let e =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : "";
            return /(VANILLALONG|TURBOS)/i.test(e)
              ? (0, c.fm)(e.replace(/(VANILLALONG|TURBOS)/i, "").toLowerCase())
              : "";
          },
          j = function () {
            let e =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : "";
            return C(e)
              ? "Long" === P(e)
                ? (0, o.jsx)(a.Xx, { i18n_default_text: "Up" })
                : (0, o.jsx)(a.Xx, { i18n_default_text: "Down" })
              : "";
          },
          U = (e, t) => {
            t
              ? (t.preventDefault(),
                ("keydown" !== t.type ||
                  ("keydown" === t.type && "Enter" === t.key)) &&
                  (null == e || e()))
              : null == e || e();
          },
          M = (e, t, i) => "buy" === e && !!(0, l.s0)(t, i);
        i(42231);
      },
      52717: function (e, t, i) {
        "use strict";
        i.d(t, {
          bf: () => n,
          bs: () => a,
          lb: () => c,
          i4: () => p,
          oC: () => u,
          g$: () => r,
          O$: () => g,
          oS: () => _,
          dr: () => l,
        });
        var o = i(11016);
        let s = {},
          r = ["USD", "EUR", "GBP", "AUD"],
          a = [
            "TUSDT",
            "BTC",
            "ETH",
            "LTC",
            "UST",
            "eUSDT",
            "BUSD",
            "DAI",
            "EURS",
            "IDK",
            "PAX",
            "TUSD",
            "USDC",
            "USDK",
          ],
          n = (e, t) => Number(Number(e).toFixed(p(t))),
          l = (e, t) => `${u(e, p(t), _(t))} ${t}`,
          c = function (e, t, i) {
            let o =
                arguments.length > 3 && void 0 !== arguments[3]
                  ? arguments[3]
                  : 0,
              s =
                arguments.length > 4 && void 0 !== arguments[4]
                  ? arguments[4]
                  : 0,
              r = t;
            r && (r = String(r).replace(/,/g, ""));
            let a = r && 0 > Number(r) ? "-" : "",
              n = o || p(e);
            return (
              (r = isNaN(+r) ? 0 : Math.abs(+r)),
              (r =
                "undefined" != typeof Intl
                  ? new Intl.NumberFormat("en", {
                      minimumFractionDigits: s || n,
                      maximumFractionDigits: n,
                    }).format(r)
                  : u(r, n)),
              a + (i ? "" : d(e)) + r
            );
          },
          d = (e) => `<span class="symbols ${(e || "").toLowerCase()}"></span>`,
          u = (e, t, i) => {
            let o = String(e || 0).replace(/,/g, "");
            return (
              void 0 !== t && (o = (+o).toFixed(t)),
              i && (o = parseFloat(String(o))),
              o
                .toString()
                .replace(
                  /(^|[^\w.])(\d{4,})/g,
                  (e, t, i) => t + i.replace(/\d(?=(?:\d\d\d)+(?!\d))/g, "$&,")
                )
            );
          },
          h = (e) => (_(e) ? (0, o.SX)(m.get(), [e, "fractional_digits"]) : 2),
          p = function () {
            let e =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : "";
            return s[e] ? (0, o.SX)(s, [e, "fractional_digits"]) : h(e);
          },
          _ = (e) => /crypto/i.test((0, o.SX)(s, [e, "type"])) || e in m.get(),
          m = (() => {
            let e;
            let t = () =>
              (0, o._A)({
                BTC: {
                  display_code: "BTC",
                  name: "Bitcoin",
                  min_withdrawal: 0.002,
                  pa_max_withdrawal: 5,
                  pa_min_withdrawal: 0.002,
                  fractional_digits: 8,
                },
                BUSD: {
                  display_code: "BUSD",
                  name: "Binance USD",
                  min_withdrawal: 0.002,
                  pa_max_withdrawal: 5,
                  pa_min_withdrawal: 0.002,
                  fractional_digits: 2,
                },
                DAI: {
                  display_code: "DAI",
                  name: "Multi-Collateral DAI",
                  min_withdrawal: 0.002,
                  pa_max_withdrawal: 5,
                  pa_min_withdrawal: 0.002,
                  fractional_digits: 2,
                },
                EURS: {
                  display_code: "EURS",
                  name: "STATIS Euro",
                  min_withdrawal: 0.002,
                  pa_max_withdrawal: 5,
                  pa_min_withdrawal: 0.002,
                  fractional_digits: 2,
                },
                IDK: {
                  display_code: "IDK",
                  name: "IDK",
                  min_withdrawal: 0.002,
                  pa_max_withdrawal: 5,
                  pa_min_withdrawal: 0.002,
                  fractional_digits: 0,
                },
                PAX: {
                  display_code: "PAX",
                  name: "Paxos Standard",
                  min_withdrawal: 0.002,
                  pa_max_withdrawal: 5,
                  pa_min_withdrawal: 0.002,
                  fractional_digits: 2,
                },
                TUSD: {
                  display_code: "TUSD",
                  name: "True USD",
                  min_withdrawal: 0.002,
                  pa_max_withdrawal: 5,
                  pa_min_withdrawal: 0.002,
                  fractional_digits: 2,
                },
                USDC: {
                  display_code: "USDC",
                  name: "USD Coin",
                  min_withdrawal: 0.002,
                  pa_max_withdrawal: 5,
                  pa_min_withdrawal: 0.002,
                  fractional_digits: 2,
                },
                USDK: {
                  display_code: "USDK",
                  name: "USDK",
                  min_withdrawal: 0.002,
                  pa_max_withdrawal: 5,
                  pa_min_withdrawal: 0.002,
                  fractional_digits: 2,
                },
                eUSDT: {
                  display_code: "eUSDT",
                  name: "Tether ERC20",
                  min_withdrawal: 0.002,
                  pa_max_withdrawal: 5,
                  pa_min_withdrawal: 0.002,
                  fractional_digits: 2,
                },
                tUSDT: {
                  display_code: "tUSDT",
                  name: "Tether TRC20",
                  min_withdrawal: 0.002,
                  pa_max_withdrawal: 5,
                  pa_min_withdrawal: 0.002,
                  fractional_digits: 2,
                },
                BCH: {
                  display_code: "BCH",
                  name: "Bitcoin Cash",
                  min_withdrawal: 0.002,
                  pa_max_withdrawal: 5,
                  pa_min_withdrawal: 0.002,
                  fractional_digits: 8,
                },
                ETH: {
                  display_code: "ETH",
                  name: "Ether",
                  min_withdrawal: 0.002,
                  pa_max_withdrawal: 5,
                  pa_min_withdrawal: 0.002,
                  fractional_digits: 8,
                },
                ETC: {
                  display_code: "ETC",
                  name: "Ether Classic",
                  min_withdrawal: 0.002,
                  pa_max_withdrawal: 5,
                  pa_min_withdrawal: 0.002,
                  fractional_digits: 8,
                },
                LTC: {
                  display_code: "LTC",
                  name: "Litecoin",
                  min_withdrawal: 0.002,
                  pa_max_withdrawal: 5,
                  pa_min_withdrawal: 0.002,
                  fractional_digits: 8,
                },
                UST: {
                  display_code: "USDT",
                  name: "Tether Omni",
                  min_withdrawal: 0.02,
                  pa_max_withdrawal: 2e3,
                  pa_min_withdrawal: 10,
                  fractional_digits: 2,
                },
              });
            return { get: () => (e || (e = t()), e) };
          })(),
          g = function () {
            let e =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : "";
            return (
              "eUSDT" !== e && "tUSDT" !== e && (e = e.toUpperCase()),
              (0, o.SX)(m.get(), [e, "display_code"]) || e
            );
          };
      },
      72755: function (e, t, i) {
        "use strict";
        i.d(t, {
          LU: () => d,
          QR: () => c,
          fc: () => u,
          gb: () => a,
          mr: () => l,
          p6: () => n,
          vk: () => r,
        });
        var o = i(30381),
          s = i.n(o);
        i(48059),
          (s().createFromInputFallback = function (e) {
            e._d = new Date(NaN);
          });
        let r = (e) => s().unix(e).utc(),
          a = (e) => {
            if (!e) return s()().utc();
            if (e instanceof s() && e.isValid() && e.isUTC()) return e;
            if ("number" == typeof e) return r(e);
            if (/invalid/i.test(s()(e).toString())) {
              let t = s()(),
                i = t.utc().daysInMonth();
              return s().utc(e, "DD MMM YYYY").valueOf() / 864e5 > i
                ? s().utc(t.add(e, "d"), "DD MMM YYYY")
                : s().utc(e, "DD MMM YYYY");
            }
            return s().utc(e);
          },
          n = function (e) {
            let t =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : "YYYY-MM-DD",
              i =
                !(arguments.length > 2) ||
                void 0 === arguments[2] ||
                arguments[2];
            return i || null !== e ? a(e).format(t) : void 0;
          },
          l = function (e) {
            let t =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : "HH:mm:ss [GMT]";
            return a(e).format(t);
          },
          c = (e, t) => s().duration(s().unix(t).diff(s().unix(e))),
          d = (e, t) => {
            let i = Math.floor(e.asDays()),
              o = e.hours(),
              r = e.minutes(),
              a = e.seconds();
            return {
              days: i,
              timestamp: s()(0)
                .hour(o)
                .minute(r)
                .seconds(a)
                .format(t || "HH:mm:ss"),
            };
          },
          u = (e, t, i) => s()(e, t).format(i);
      },
      78485: function (e, t, i) {
        "use strict";
        e = i.hmd(e);
        let o = (function () {
          let e, t, i;
          function o(e, t) {
            return null != t && e instanceof t;
          }
          try {
            e = Map;
          } catch (t) {
            e = function () {};
          }
          try {
            t = Set;
          } catch (e) {
            t = function () {};
          }
          try {
            i = Promise;
          } catch (e) {
            i = function () {};
          }
          function s(r, n, l, c, d) {
            "object" == typeof n &&
              ((l = n.depth),
              (c = n.prototype),
              (d = n.includeNonEnumerable),
              (n = n.circular));
            let u = [],
              h = [],
              p = "undefined" != typeof Buffer;
            return (
              void 0 === n && (n = !0),
              void 0 === l && (l = 1 / 0),
              (function r(l, _) {
                let m, g;
                if (null === l) return null;
                if (0 === _ || "object" != typeof l) return l;
                if (o(l, e)) m = new e();
                else if (o(l, t)) m = new t();
                else if (o(l, i))
                  m = new i(function (e, t) {
                    l.then(
                      function (t) {
                        e(r(t, _ - 1));
                      },
                      function (e) {
                        t(r(e, _ - 1));
                      }
                    );
                  });
                else if (s.__isArray(l)) m = [];
                else if (s.__isRegExp(l))
                  (m = new RegExp(l.source, a(l))),
                    l.lastIndex && (m.lastIndex = l.lastIndex);
                else if (s.__isDate(l)) m = new Date(l.getTime());
                else {
                  if (p && Buffer.isBuffer(l))
                    return (
                      Buffer.from
                        ? (m = Buffer.from(l))
                        : ((m = new Buffer(l.length)), l.copy(m)),
                      m
                    );
                  o(l, Error)
                    ? (m = Object.create(l))
                    : void 0 === c
                    ? (m = Object.create(Object.getPrototypeOf(l)))
                    : (m = Object.create(c));
                }
                if (n) {
                  let e = u.indexOf(l);
                  if (-1 != e) return h[e];
                  u.push(l), h.push(m);
                }
                for (var y in (o(l, e) &&
                  l.forEach(function (e, t) {
                    let i = r(t, _ - 1),
                      o = r(e, _ - 1);
                    m.set(i, o);
                  }),
                o(l, t) &&
                  l.forEach(function (e) {
                    let t = r(e, _ - 1);
                    m.add(t);
                  }),
                l)) {
                  if (Object.getOwnPropertyDescriptor(l, y)) {
                    if (0 > Object.keys(l).indexOf(y)) continue;
                    m[y] = r(l[y], _ - 1);
                  }
                  try {
                    let e = Object.getOwnPropertyDescriptor(l, y);
                    if ("undefined" === e.set) continue;
                    m[y] = r(l[y], _ - 1);
                  } catch (e) {
                    if (e instanceof TypeError || e instanceof ReferenceError)
                      continue;
                  }
                }
                if (Object.getOwnPropertySymbols) {
                  let e = Object.getOwnPropertySymbols(l);
                  for (var y = 0; y < e.length; y++) {
                    let t = e[y];
                    var v = Object.getOwnPropertyDescriptor(l, t);
                    (!v || v.enumerable || d) &&
                      ((m[t] = r(l[t], _ - 1)), Object.defineProperty(m, t, v));
                  }
                }
                if (d) {
                  let e = Object.getOwnPropertyNames(l);
                  for (var y = 0; y < e.length; y++) {
                    let t = e[y];
                    var v = Object.getOwnPropertyDescriptor(l, t);
                    (!v || !v.enumerable) &&
                      ((m[t] = r(l[t], _ - 1)), Object.defineProperty(m, t, v));
                  }
                }
                return m;
              })(r, l)
            );
          }
          function r(e) {
            return Object.prototype.toString.call(e);
          }
          function a(e) {
            let t = "";
            return (
              e.global && (t += "g"),
              e.ignoreCase && (t += "i"),
              e.multiline && (t += "m"),
              t
            );
          }
          return (
            (s.clonePrototype = function (e) {
              if (null === e) return null;
              let t = function () {};
              return (t.prototype = e), new t();
            }),
            (s.__objToStr = r),
            (s.__isDate = function (e) {
              return "object" == typeof e && "[object Date]" === r(e);
            }),
            (s.__isArray = function (e) {
              return "object" == typeof e && "[object Array]" === r(e);
            }),
            (s.__isRegExp = function (e) {
              return "object" == typeof e && "[object RegExp]" === r(e);
            }),
            (s.__getRegExpFlags = a),
            s
          );
        })();
        e.exports && (e.exports = o);
      },
      11016: function (e, t, i) {
        "use strict";
        i.d(t, {
          LI: () => o.LI,
          Qr: () => o.Qr,
          SX: () => o.SX,
          Tw: () => o.Tw,
          _A: () => o._A,
          ei: () => o.ei,
          kI: () => o.kI,
          uv: () => o.uv,
          vP: () => o.vP,
          xb: () => o.xb,
        }),
          i(78485);
        var o = i(45543);
      },
      45543: function (e, t, i) {
        "use strict";
        i.d(t, {
          LI: () => h,
          Qr: () => o,
          SX: () => c,
          Tw: () => l,
          _A: () => p,
          ei: () => u,
          kI: () => s,
          uv: () => n,
          vP: () => d,
          xb: () => r,
        });
        let o = (e) => {
            let t = !0;
            return (
              e &&
                e instanceof Object &&
                Object.keys(e).forEach((i) => {
                  Object.prototype.hasOwnProperty.call(e, i) && (t = !1);
                }),
              t
            );
          },
          s = (e) => {
            if (o(e)) return e;
            let t = Array.isArray(e) ? [] : {};
            for (let i in e)
              Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
            return t;
          },
          r = (e, t) =>
            typeof e == typeof t &&
            (Array.isArray(e)
              ? a(e, t)
              : e && t && "object" == typeof e
              ? n(e, t)
              : !!(
                  "number" == typeof e &&
                  "number" == typeof t &&
                  isNaN(e) &&
                  isNaN(t)
                ) || e === t),
          a = (e, t) =>
            e === t || (e.length === t.length && e.every((e, i) => r(e, t[i]))),
          n = (e, t) =>
            e === t ||
            (Object.keys(e).length === Object.keys(t).length &&
              Object.keys(e).every((i) => r(e[i], t[i]))),
          l = (e, t) =>
            e.filter(
              (i, o) =>
                e.findIndex((e, s) => (e[t] ? e[t] === i[t] : s === o)) === o
            ),
          c = (e, t) => {
            let i = t;
            return (Array.isArray(i) || (i = [i]),
            !o(e) && i[0] in e && i && i.length > 1)
              ? c(e[i[0]], i.slice(1))
              : e
              ? s(e[i[0]])
              : void 0;
          },
          d = (e) => Array.from(Array(e).keys()),
          u = (e, t) =>
            t.reduce(
              (t, i) => (
                Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]), t
              ),
              {}
            ),
          h = (e, t) => {
            let i;
            return (
              Object.keys(e).some((o) => {
                let s = e[o];
                if (o === t) return (i = e[t]), !0;
                if ("object" == typeof s) {
                  let e = h(s, t);
                  if (e) return (i = e), !0;
                }
                return !1;
              }),
              i
            );
          },
          p = (e) => (
            Object.getOwnPropertyNames(e).forEach((t) => {
              let i = e[t];
              i && "object" == typeof i && !Object.isFrozen(i) && p(i);
            }),
            Object.freeze(e)
          );
      },
      42231: function (e, t, i) {
        "use strict";
        i.d(t, { x: () => r });
        let o = {
            derivCom: {
              staging: "https://staging.deriv.com",
              production: {
                me: "https://deriv.me",
                be: "https://deriv.be",
                com: "https://deriv.com",
              },
            },
            derivApp: {
              staging: "https://staging-app.deriv.com",
              production: {
                me: "https://app.deriv.me",
                be: "https://app.deriv.be",
                com: "https://app.deriv.com",
              },
            },
            smartTrader: {
              staging: {
                me: "https://staging-smarttrader.deriv.me",
                be: "https://staging-smarttrader.deriv.be",
                com: "https://staging-smarttrader.deriv.com",
              },
              production: {
                me: "https://smarttrader.deriv.me",
                be: "https://smarttrader.deriv.be",
                com: "https://smarttrader.deriv.com",
              },
            },
          },
          s = (e) => {
            let t = window.location.hostname,
              i = t.includes("staging"),
              s = t.endsWith(".me") ? "me" : t.endsWith(".be") ? "be" : "com",
              r = o[e];
            return i
              ? "string" == typeof r.staging
                ? r.staging
                : r.staging[s]
              : r.production[s];
          },
          r = {
            bot: `${window.location.origin}`,
            cashier: `${s("derivApp")}/cashier/`,
            cashier_deposit: `${s("derivApp")}/cashier/deposit`,
            cashier_p2p: `${s("derivApp")}/cashier/p2p`,
            contract: `${s("derivApp")}/contract/:contract_id`,
            personal_details: `${s("derivApp")}/account/personal-details`,
            positions: `${s("derivApp")}/reports/positions`,
            profit: `${s("derivApp")}/reports/profit`,
            reports: `${s("derivApp")}/reports`,
            root: s("derivApp"),
            smarttrader: s("smartTrader"),
            statement: `${s("derivApp")}/reports/statement`,
            trade: `${s("derivApp")}/dtrader`,
            traders_hub: s("derivApp"),
            wallets_transfer: `${s("derivApp")}/wallet/account-transfer`,
            signup: "https://hub.deriv.com/tradershub/signup",
            deriv_com: s("derivCom"),
            deriv_app: s("derivApp"),
            endpoint: `${window.location.origin}/endpoint`,
            account_limits: `${s("derivApp")}/account/account-limits`,
            help_center: `${s("derivCom")}/help-centre/`,
            responsible: `${s("derivCom")}/responsible/`,
          };
      },
      77149: function (e, t, i) {
        "use strict";
        i.d(t, { b1: () => o, nI: () => r, tq: () => s });
        let o = () =>
            "ontouchstart" in window ||
            "ontouchstart" in document.documentElement ||
            (window.DocumentTouch &&
              document instanceof window.DocumentTouch) ||
            navigator.maxTouchPoints > 0 ||
            window.navigator.msMaxTouchPoints > 0,
          s = () => window.innerWidth <= 600,
          r = () => a() || window.innerWidth > 1279,
          a = () => 600 < window.innerWidth && window.innerWidth <= 1279;
      },
      29398: function (e, t, i) {
        "use strict";
        i.d(t, { CY: () => l, s0: () => d });
        let o =
            "^([A-Z]+)_((?:1HZ[0-9-V]+)|(?:(?:CRASH|BOOM)[0-9\\d]+[A-Z]?)|(?:cry_[A-Z]+)|(?:JD[0-9]+)|(?:OTC_[A-Z0-9]+)|R_[\\d]{2,3}|[A-Z]+)_([\\d.]+)",
          s = RegExp(`${o}_(\\d+)_(\\d*\\.?\\d*)_(\\d+)_(\\d*\\.?\\d*)_(\\d+)`),
          r = RegExp(`${o}_(\\d+)_(\\d+)`),
          a = RegExp(`${o}_([A-Z\\d]+)_([A-Z\\d]+)_?([A-Z\\d]+)?`),
          n = (e) => {
            let t = {
                category: "",
                underlying: "",
                barrier_1: "",
                multiplier: "",
                start_time: "",
                payout_tick: "",
                growth_rate: "",
                growth_frequency: "",
              },
              i = /^ACCU/i.test(e),
              o = /^MULT/i.test(e),
              n = (o ? r : i ? s : a).exec(e);
            return (
              null !== n &&
                ((t.category =
                  n[1].charAt(0).toUpperCase() + n[1].slice(1).toLowerCase()),
                (t.underlying = n[2]),
                o
                  ? ((t.multiplier = n[4]), (t.start_time = n[5]))
                  : i
                  ? ((t.payout_tick = n[4]),
                    (t.growth_rate = n[5]),
                    (t.growth_frequency = n[6]),
                    (t.start_time = n[8]))
                  : (t.start_time = n[4]),
                /^(CALL|PUT)$/i.test(t.category) && (t.barrier_1 = n[6])),
              t
            );
          },
          l = (e) => {
            let { shortcode: t = "", shortcode_info: i } = e,
              o = t ? n(t) : i;
            return !!o && !!o.barrier_1 && !/^S0P$/.test(o.barrier_1);
          },
          c = (e) => {
            let t = n(e);
            return (
              (null == t || !t.multiplier) &&
              ((null == t ? void 0 : t.start_time) || "")
            );
          },
          d = (e, t) => {
            let i = c(e);
            return i && t && /f$/gi.test(i);
          };
      },
      46677: function (e, t, i) {
        "use strict";
        i.d(t, { _v: () => l, fm: () => n, pp: () => r, qB: () => s });
        let o = (e, t, i) => {
            let o = String(e || "");
            return o.length >= t ? o : `${Array(t - o.length + 1).join(i)}${o}`;
          },
          s = (e, t) => {
            let i = a(e),
              s = a(t);
            if (!i || !s) return "";
            let r = Math.max(i.length, s.length);
            i = o(i, r, "0");
            let n = 0;
            return i !== (s = o(s, r, "0")) && (n = i > s ? 1 : -1), n;
          },
          r = (e, t) =>
            (null == t ? void 0 : t.length) < 1 ||
            RegExp(
              t.split("").reduce((e, t) => `${e}[^${t}]*${t}`, ""),
              "i"
            ).test(e),
          a = (e) => ("number" == typeof e ? String(e) : e),
          n = (e) => e && e[0].toUpperCase() + e.slice(1),
          l = (e) =>
            e
              .normalize("NFD")
              .split("")
              .filter((e) => /^[a-z ]*$/i.test(e))
              .join("");
      },
      24797: function (e, t, i) {
        "use strict";
        i.d(t, { L: () => a });
        let o = "deriv.com",
          s =
            ("undefined" != typeof window &&
              window.location.hostname.split("app.")[1]) ||
            "",
          r = [o, "deriv.me", "deriv.be"].includes(s) ? s : o,
          a = Object.freeze({
            DERIV_HOST_NAME: r,
            DERIV_COM_PRODUCTION: `https://${r}`,
            DERIV_COM_PRODUCTION_EU: `https://eu.${r}`,
            DERIV_COM_STAGING: `https://staging.${r}`,
            DERIV_APP_PRODUCTION: `https://app.${r}`,
            DERIV_APP_STAGING: `https://staging-app.${r}`,
            SMARTTRADER_PRODUCTION: `https://smarttrader.${r}`,
            SMARTTRADER_STAGING: `https://staging-smarttrader.${r}`,
            BINARYBOT_PRODUCTION: `https://bot.${r}`,
            BINARYBOT_STAGING: `https://staging-bot.${r}`,
          });
      },
      339: function (e, t, i) {
        "use strict";
        let o;
        i.d(t, { MT: () => d, SM: () => u, y_: () => c, RK: () => h });
        var s = i(24797),
          r = i(18470);
        i(42231);
        let a = "binary.com",
          n = {
            "bot.binary.com": "www.binary.bot",
            "developers.binary.com": "developers.binary.com",
            "academy.binary.com": "academy.binary.com",
            "blog.binary.com": "blog.binary.com",
          },
          l = (e) => (e ? e.replace(/(^\/|\/$|[^a-zA-Z0-9-_./()#])/g, "") : ""),
          c = (e) => {
            let t = (0, r.zY)();
            if (!t) return e;
            let i = new URL(e);
            if (Object.keys(n).includes(i.hostname)) i.hostname = n[i.hostname];
            else {
              if (!i.hostname.match(a)) return e;
              i.hostname = i.hostname.replace(RegExp(`\\.${a}`, "i"), `.${t}`);
            }
            return i.href;
          },
          d = function () {
            let e =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : "",
              t = window.location;
            return /^\/(br_)/.test(t.pathname)
              ? `/${t.pathname.split("/")[1]}${/^\//.test(e) ? e : `/${e}`}`
              : e;
          },
          u = (e) => {
            o = e;
          },
          h = function () {
            let e =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : "",
              t =
                arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
              i =
                arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
              r = i ? s.L.DERIV_COM_PRODUCTION_EU : s.L.DERIV_COM_PRODUCTION,
              a = null == o ? void 0 : o.toLowerCase();
            return ((a = a && "en" !== a ? `/${a}` : ""), t)
              ? `${r}/${l(e)}`
              : (r === s.L.DERIV_COM_PRODUCTION &&
                  a.includes("_") &&
                  (a = a.replace("_", "-")),
                `${r}${a}/${l(e)}`);
          };
      },
      40968: function (e, t, i) {
        "use strict";
        let o, s;
        i.d(t, { Cc: () => E, JL: () => c, bf: () => x });
        var r = i(52717),
          a = i(11016),
          n = i(46677);
        let l = (e) => null != e && e.toString().replace(/\s/g, "").length > 0,
          c = ". , ' : ; ( ) \xb0 @ # / -",
          d = (e, t) =>
            (null == t ? void 0 : t.is_required) && (!e || e.match(/^\s*$/))
              ? { is_ok: !1, message: null == s ? void 0 : s.empty_address() }
              : m(e, { min: 0, max: 70 })
              ? /^[\p{L}\p{Nd}\s'.,:;()\u00b0@#/-]{0,70}$/u.test(e)
                ? { is_ok: !0 }
                : { is_ok: !1, message: null == s ? void 0 : s.address() }
              : { is_ok: !1, message: null == s ? void 0 : s.maxNumber(70) },
          u = (e) => "" === e || /^[A-Za-z0-9][A-Za-z0-9\s-]*$/.test(e),
          h = (e) => /(?!^$|\s+)[A-Za-z0-9./\s-]$/.test(e),
          p = (e) => /^\+?([0-9-]+\s)*[0-9-]+$/.test(e),
          _ = (e) => /^(?!.*\s{2,})[\p{L}\s'.-]{2,50}$/u.test(e),
          m = function () {
            let e =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : "",
              t = arguments.length > 1 ? arguments[1] : void 0;
            return (
              (!t.min || e.length >= Number(t.min)) &&
              (!t.max || e.length <= Number(t.max))
            );
          },
          g = (e) => /^(?=.*[a-z])(?=.*\d)(?=.*[A-Z])[!-~]{8,25}$/.test(e),
          y = (e) =>
            /^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,63}$/.test(e),
          v = (e) => /^[+-]?\d+\.?\d*$/.test(e),
          f = (e) => !/[`~!@#$%^&*)(_=+[}{\]\\/";:?><|]+/.test(e),
          b = (e, t) => {
            var i;
            return null === (i = t.regex) || void 0 === i ? void 0 : i.test(e);
          },
          w = (e) => !!e,
          k = (e) => !/p[.\s]+o[.\s]+box/i.test(e),
          C = (e) => 8 === e.trim().length,
          T = (e, t) =>
            "float" === t.type ? +e > Number(t.max) : 1 === (0, n.qB)(e, t.max),
          N = (e, t) => {
            let i = (0, a.kI)(t),
              o = null;
            if (i.allow_empty && 0 === e.length) return { is_ok: !0 };
            let n = !0;
            if (
              ("min" in i && "function" == typeof i.min && (i.min = i.min()),
              "max" in i && "function" == typeof i.max && (i.max = i.max()),
              !("float" === i.type ? /^\d*(\.\d+)?$/ : /^\d+$/).test(e) ||
                isNaN(+e))
            )
              (n = !1), (o = s.number());
            else if (
              "min" in i &&
              "max" in i &&
              +i.min == +i.max &&
              +e != +i.min
            )
              (n = !1), (o = s.value((0, r.oC)(i.min, i.decimals)));
            else if (
              "min" in i &&
              "max" in i &&
              i.min > 0 &&
              (+e < +i.min || T(+e, i))
            ) {
              n = !1;
              let e = (0, r.oC)(i.min, i.decimals),
                t = (0, r.oC)(i.max, i.decimals);
              o = s.betweenMinMax(e, t);
            } else if (
              "float" === i.type &&
              i.decimals &&
              !RegExp(`^\\d+(\\.\\d{0,${i.decimals}})?$`).test(e)
            )
              (n = !1), (o = s.decimalPlaces(i.decimals));
            else if ("min" in i && +e < +i.min) {
              n = !1;
              let e = (0, r.oC)(i.min, i.decimals);
              o = s.minNumber(e);
            } else if ("max" in i && T(+e, i)) {
              n = !1;
              let e = (0, r.oC)(i.max, i.decimals);
              o = s.maxNumber(e);
            }
            return { is_ok: n, message: o };
          },
          S = () => ({
            address: { func: d, message: s.address },
            barrier: { func: v, message: s.barrier },
            email: { func: y, message: s.email },
            general: { func: f, message: s.general },
            length: { func: m, message: "" },
            name: { func: _, message: s.name },
            number: {
              func: function () {
                for (var e = arguments.length, t = Array(e), i = 0; i < e; i++)
                  t[i] = arguments[i];
                let [o, s] = t;
                return N(o, s);
              },
              message: s.number,
            },
            password: { func: g, message: s.password },
            phone: { func: p, message: s.phone },
            po_box: { func: k, message: s.po_box },
            postcode: { func: u, message: s.postcode },
            regular: { func: b, message: "" },
            req: { func: l, message: "" },
            confirm: { func: w, message: "" },
            signup_token: { func: C, message: s.signup_token },
            tax_id: { func: h, message: s.validTaxID },
          }),
          x = (e) => {
            o || ((s = e), (o = S()));
          },
          E = () => o;
      },
      419: function (e, t, i) {
        "use strict";
        i.d(t, { JL: () => o.JL });
        var o = i(40968);
        i(32750), i(63069);
      },
      45221: function (e, t, i) {
        "use strict";
        i.d(t, { Z: () => h });
        var o = i(85893);
        i(67294);
        var s = i(63387),
          r = i.n(s),
          a = i(89606),
          n = i(45452),
          l = i(29490);
        let c = (e) => {
            let {
                className: t,
                id: i,
                is_fullscreen: s = !0,
                is_slow_loading: a,
                status: n,
                theme: c,
              } = e,
              d = c ? `barspinner-${c}` : "barspinner-light";
            return (0, o.jsxs)("div", {
              "data-testid": "dt_initial_loader",
              className: r()(
                "initial-loader",
                { "initial-loader--fullscreen": s },
                t
              ),
              children: [
                (0, o.jsx)("div", {
                  id: i,
                  className: r()("initial-loader__barspinner", "barspinner", d),
                  children: Array.from([, , , , ,]).map((e, t) =>
                    (0, o.jsx)(
                      "div",
                      {
                        className: `initial-loader__barspinner--rect barspinner__rect barspinner__rect--${
                          t + 1
                        } rect${t + 1}`,
                      },
                      t
                    )
                  ),
                }),
                a &&
                  (null == n
                    ? void 0
                    : n.map((e, t) =>
                        (0, o.jsx)(
                          l.Z,
                          {
                            as: "h3",
                            color: "prominent",
                            size: "xs",
                            align: "center",
                            children: e,
                          },
                          t
                        )
                      )),
              ],
            });
          },
          d = (e) =>
            (0, o.jsx)(c, {
              ...e,
              is_fullscreen: !1,
              className: "initial-loader--btn",
            }),
          u = (e) => {
            let {
                black: t,
                blue: i,
                children: s,
                className: l = "",
                classNameSpan: c,
                green: u,
                has_effect: h,
                icon: p,
                id: _,
                is_disabled: m,
                is_loading: g,
                is_submit_success: y,
                is_button_toggle: v,
                is_circle: f,
                is_circular: b,
                is_plus: w,
                large: k,
                medium: C,
                onClick: T,
                rounded: N,
                tabIndex: S = 0,
                text: x,
                wrapperClassName: E,
                type: D,
                primary: O,
                primary_light: A,
                secondary: I,
                alternate: L,
                transparent: R,
                small: B,
                tertiary: P,
                renderText: j,
                ...U
              } = e,
              M = r()(
                "dc-btn",
                {
                  "dc-btn__effect": h,
                  "dc-btn--primary": O,
                  "dc-btn--black": t,
                  "dc-btn--blue": i,
                  "dc-btn--secondary": I,
                  "dc-btn--tertiary": P,
                  "dc-btn--primary__light": A,
                  "dc-btn--primary__blue": i && O,
                  "dc-btn--tertiary__blue": i && P,
                  "dc-btn--alternate": L,
                  "dc-btn--green": u,
                  "dc-btn__rounded": N,
                  "dc-btn__large": k,
                  "dc-btn__medium": C,
                  "dc-btn__small": B,
                  "dc-btn__toggle": v,
                  "dc-btn--plus": w,
                  "dc-btn--circle": f,
                  "dc-btn--circular": b,
                  "dc-btn--transparent": R,
                },
                l
              ),
              F = (0, o.jsxs)("button", {
                id: _,
                className: M,
                onClick: T,
                disabled: m,
                tabIndex: S,
                type: y ? "button" : D || "submit",
                ...U,
                children: [
                  p &&
                    (0, o.jsx)("div", {
                      className: r()("dc-btn__icon", {
                        "dc-btn__icon--circle": f,
                      }),
                      children: p,
                    }),
                  x &&
                    !(g || y) &&
                    (("function" == typeof j &&
                      j(x[0].toUpperCase() + x.substr(1))) ||
                      (0, o.jsx)(n.Z, {
                        size: "xs",
                        weight: "bold",
                        align: "center",
                        className: r()("dc-btn__text", c),
                        children: x[0].toUpperCase() + x.substr(1),
                      })),
                  g && (0, o.jsx)(d, {}),
                  y &&
                    (0, o.jsx)(a.J, {
                      icon: "IcCheckmark",
                      color: "active",
                      size: 24,
                    }),
                  w &&
                    (0, o.jsx)(a.J, {
                      icon: "IcAddBold",
                      color: "black",
                      size: 18,
                    }),
                  !x &&
                    !g &&
                    s &&
                    (0, o.jsx)(n.Z, {
                      size: "xs",
                      weight: "bold",
                      align: "center",
                      className: r()("dc-btn__text", c),
                      children: s,
                    }),
                ],
              }),
              G = (0, o.jsx)("div", { className: E, children: F });
            return E ? G : F;
          };
        u.Group = (e) => {
          let { children: t, className: i } = e;
          return (0, o.jsx)("div", {
            className: r()("dc-btn__group", i),
            children: t,
          });
        };
        let h = u;
      },
      10434: function (e, t, i) {
        "use strict";
        i.d(t, { Z: () => p });
        var o = i(85893),
          s = i(67294),
          r = i(63387),
          a = i.n(r),
          n = i(73935),
          l = i(81262),
          c = i(1051),
          d = i(76298),
          u = i(45221),
          h = i(45452);
        let p = (e) => {
          var t;
          let {
              disableApp: i,
              dismissable: r,
              enableApp: p,
              is_closed_on_cancel: _ = !0,
              is_closed_on_confirm: m = !0,
              is_visible: g,
              onCancel: y,
              onClose: v,
              onConfirm: f,
              onEscapeButtonCancel: b,
              ...w
            } = e,
            {
              cancel_button_text: k,
              className: C,
              children: T,
              confirm_button_text: N,
              is_loading: S,
              is_mobile_full_width: x = !0,
              is_content_centered: E,
              portal_element_id: D,
              title: O,
              has_close_icon: A,
            } = w,
            I = s.useRef();
          s.useEffect(() => {
            g && i && i();
          }, [g, i]),
            s.useEffect(() => {
              let e = (e) => {
                "Escape" === e.key && (null == b || b());
              };
              return (
                window.addEventListener("keydown", e),
                () => window.removeEventListener("keydown", e)
              );
            }, []);
          let L = () => {
              _ && p && p(), null == y || y();
            },
            R = () => {
              m && p && p(), f();
            },
            B = () => {
              v ? v() : y ? L() : R();
            };
          (0, c.t)(I, B, () => !!r || !!(A && g && _));
          let P = a()("dc-dialog__content", {
              "dc-dialog__content--centered": E,
            }),
            j =
              "string" == typeof T ||
              (s.isValidElement(T) &&
                "string" ==
                  typeof (null == T
                    ? void 0
                    : null === (t = T.props) || void 0 === t
                    ? void 0
                    : t.i18n_default_text)),
            U = (0, o.jsx)(l.Z, {
              appear: !0,
              in: g && !S,
              timeout: 50,
              classNames: {
                appear: "dc-dialog__wrapper--enter",
                enter: "dc-dialog__wrapper--enter",
                enterDone: "dc-dialog__wrapper--enter-done",
                exit: "dc-dialog__wrapper--exit",
              },
              unmountOnExit: !0,
              children: (0, o.jsx)("div", {
                className: a()("dc-dialog__wrapper", C, {
                  "dc-dialog__wrapper--has-portal": !!D,
                }),
                children: (0, o.jsxs)("div", {
                  className: a()("dc-dialog__dialog", {
                    "dc-dialog__dialog--has-margin": !x,
                  }),
                  role: "dialog",
                  ref: I,
                  children: [
                    (O || A) &&
                      (0, o.jsxs)("div", {
                        className: a()("dc-dialog__header-wrapper", {
                          "dc-dialog__header-wrapper--end": !O,
                        }),
                        children: [
                          !!O &&
                            (0, o.jsx)(h.Z, {
                              as: "h1",
                              color: "prominent",
                              weight: "bold",
                              className: "dc-dialog__header--title",
                              children: O,
                            }),
                          A &&
                            (0, o.jsx)("div", {
                              onClick: B,
                              className: "dc-dialog__header--close",
                              children: (0, o.jsx)(d.Z, {
                                height: "20px",
                                width: "20px",
                                fill: "var(--text-general)",
                                className: "icon-general-fill-path",
                              }),
                            }),
                        ],
                      }),
                    j
                      ? (0, o.jsx)(h.Z, {
                          as: "p",
                          size: "xs",
                          styles: { lineHeight: "1.43" },
                          className: P,
                          children: T,
                        })
                      : (0, o.jsx)("div", { className: P, children: T }),
                    (0, o.jsxs)("div", {
                      className: "dc-dialog__footer",
                      children: [
                        !!y &&
                          (0, o.jsx)(u.Z, {
                            className: "dc-dialog__button",
                            has_effect: !0,
                            text: k,
                            onClick: L,
                            secondary: !0,
                            large: !0,
                          }),
                        !!N &&
                          (0, o.jsx)(u.Z, {
                            className: "dc-dialog__button",
                            has_effect: !0,
                            text: N,
                            onClick: R,
                            primary: !0,
                            large: !0,
                          }),
                      ],
                    }),
                  ],
                }),
              }),
            });
          if (D) {
            let e = document.getElementById(D);
            if (e) return n.createPortal(U, e);
          }
          return U;
        };
      },
      87537: function (e, t, i) {
        "use strict";
        i.d(t, { Z: () => a });
        var o = i(85893),
          s = i(67294),
          r = i(66175);
        let a = s.memo((e) => {
          let {
              amount: t = 0,
              className: i,
              currency: a = "USD",
              has_sign: n,
              should_format: l = !0,
              show_currency: c = !1,
            } = e,
            d = "";
          Number(t) && (0 > Number(t) || n) && (d = Number(t) > 0 ? "+" : "-");
          let u = n || l ? Math.abs(Number(t)) : t,
            h = l ? (0, r.lby)(a, u, !0, 0, 0) : u;
          return (0, o.jsxs)(s.Fragment, {
            children: [
              (0, o.jsx)("span", { children: n && d }),
              (0, o.jsxs)("span", {
                "data-testid": "dt_span",
                className: i,
                children: [h, " ", c && (0, r.O$T)(a)],
              }),
            ],
          });
        });
      },
      31865: function (e, t, i) {
        "use strict";
        i.d(t, { Z: () => a });
        var o = i(85893);
        i(67294);
        var s = i(339),
          r = i(48059);
        let a = (e) => {
          let {
            href: t,
            is_document: i,
            is_eu_url: a = !1,
            children: n = null,
            ...l
          } = e;
          return (0, o.jsx)("a", {
            href: ((0, s.SM)((0, r.Jb)()), (0, s.RK)(t, i, a)),
            rel: "noopener noreferrer",
            target: "_blank",
            ...l,
            children: n,
          });
        };
      },
      45452: function (e, t, i) {
        "use strict";
        i.d(t, { Z: () => o });
        let o = i(29490).Z;
      },
      29490: function (e, t, i) {
        "use strict";
        i.d(t, { Z: () => n });
        var o = i(67294),
          s = i(63387),
          r = i.n(s),
          a = i(66175);
        let n = (e) => {
          let {
              children: t,
              size: i = "s",
              color: s = "general",
              align: n = "left",
              weight: l = "normal",
              lineHeight: c = "m",
              as: d,
              className: u,
              styles: h,
              ...p
            } = e,
            _ = {
              "--text-size": `var(--text-size-${i})`,
              "--text-color": `var(--text-${s})`,
              "--text-lh": `var(--text-lh-${c})`,
              "--text-weight": `var(--text-weight-${l})`,
              "--text-align": `var(--text-align-${n})`,
            },
            [m, g] = o.useState(_);
          o.useEffect(() => {
            (0, a.Qr$)(h) ? g(_) : g({ ..._, ...h });
          }, [i, s, c, l, n]);
          let y = r()("dc-text", u);
          return o.createElement(
            d || "span",
            { className: y, style: m, ...p },
            t
          );
        };
      },
      24335: function (e, t, i) {
        "use strict";
        i.d(t, {
          FK: () => a,
          R5: () => n,
          ve: () => s,
          xc: () => r,
          yj: () => o,
        });
        let o = Object.freeze({ WORKSPACE: "Workspace", CHART: "Chart" }),
          s = Object.freeze({
            DASHBOARD: 0,
            BOT_BUILDER: 1,
            CHART: 2,
            TUTORIAL: 3,
            ANALYSIS_TOOL: 4,
            ANALYSIS_TOOL2: 5,
            BOTS: 6,
            COPY_TRADING: 7,
            TRADING_VIEW: 8,
            RISK_MANAGER: 9,
          }),
          r = 10,
          a = [
            "id-dbot-dashboard",
            "id-bot-builder",
            "id-charts",
            "id-tutorials",
            "id-analysis-tool",
            "id-analysis-tool2",
            "id-bots",
            "id-copy-trading",
            "id-trading-view",
          ],
          n = 500;
      },
      80177: function (e, t, i) {
        "use strict";
        i.d(t, { K: () => o });
        let o = Object.freeze({
          NOT_RUNNING: 0,
          STARTING: 1,
          RUNNING: 2,
          PURCHASE_SENT: 3,
          PURCHASE_RECEIVED: 4,
          IS_STOPPING: 5,
          CONTRACT_CLOSED: 6,
        });
      },
      88817: function (e, t, i) {
        "use strict";
        i.d(t, { h8: () => n, sl: () => l });
        var o = i(66175),
          s = i(48059);
        let r = (e) => ({
            ACCU: { name: (0, s.NC)("Accumulators"), position: "top" },
            ASIANU: { name: (0, s.NC)("Asian Up"), position: "top" },
            ASIAND: { name: (0, s.NC)("Asian Down"), position: "bottom" },
            CALL: {
              name: e ? (0, s.NC)("Higher") : (0, s.NC)("Rise"),
              position: "top",
            },
            PUT: {
              name: e ? (0, s.NC)("Lower") : (0, s.NC)("Fall"),
              position: "bottom",
            },
            CALLE: { name: (0, s.NC)("Rise"), position: "top" },
            PUTE: { name: (0, s.NC)("Fall"), position: "bottom" },
            CALLSPREAD: { name: (0, s.NC)("Spread Up"), position: "top" },
            PUTSPREAD: { name: (0, s.NC)("Spread Down"), position: "bottom" },
            DIGITMATCH: { name: (0, s.NC)("Matches"), position: "top" },
            DIGITDIFF: { name: (0, s.NC)("Differs"), position: "bottom" },
            DIGITEVEN: { name: (0, s.NC)("Even"), position: "top" },
            DIGITODD: { name: (0, s.NC)("Odd"), position: "bottom" },
            DIGITOVER: { name: (0, s.NC)("Over"), position: "top" },
            DIGITUNDER: { name: (0, s.NC)("Under"), position: "bottom" },
            EXPIRYMISS: { name: (0, s.NC)("Ends Outside"), position: "top" },
            EXPIRYRANGE: {
              name: (0, s.NC)("Ends Between"),
              position: "bottom",
            },
            LBFLOATCALL: { name: (0, s.NC)("Close-to-Low"), position: "top" },
            LBFLOATPUT: { name: (0, s.NC)("High-to-Close"), position: "top" },
            LBHIGHLOW: { name: (0, s.NC)("High-to-Low"), position: "top" },
            MULTUP: { name: (0, s.NC)("Up"), position: "top" },
            MULTDOWN: { name: (0, s.NC)("Down"), position: "bottom" },
            ONETOUCH: { name: (0, s.NC)("Touch"), position: "top" },
            NOTOUCH: { name: (0, s.NC)("No Touch"), position: "bottom" },
            RANGE: { name: (0, s.NC)("Stays Between"), position: "top" },
            UPORDOWN: { name: (0, s.NC)("Goes Outside"), position: "bottom" },
            RESETCALL: { name: (0, s.NC)("Reset Call"), position: "top" },
            RESETPUT: { name: (0, s.NC)("Reset Put"), position: "bottom" },
            RUNHIGH: { name: (0, s.NC)("Only Ups"), position: "top" },
            RUNLOW: { name: (0, s.NC)("Only Downs"), position: "bottom" },
            TICKHIGH: { name: (0, s.NC)("High Tick"), position: "top" },
            TICKLOW: { name: (0, s.NC)("Low Tick"), position: "bottom" },
          }),
          a = (e) => ({ ...r(e) }),
          n = function (e) {
            let t =
              arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            return a(t)[e] ? a(t)[e.toUpperCase()].name : "";
          },
          l = () => ({
            has_contract_update_stop_loss: {
              trigger: "contract_update_stop_loss",
            },
            has_contract_update_take_profit: {
              trigger: "contract_update_take_profit",
            },
            contract_update_stop_loss: {
              rules: [
                [
                  "req",
                  {
                    condition: (e) => !e.contract_update_stop_loss,
                    message: (0, s.NC)("Please enter a stop loss amount."),
                  },
                ],
                [
                  "custom",
                  {
                    func: (e, t, i) => {
                      let s = (0, o.vMw)(i.contract_info);
                      return !(s < 0 && -e > s);
                    },
                    message: (0, s.NC)(
                      "Please enter a stop loss amount that's higher than the current potential loss."
                    ),
                  },
                ],
                [
                  "custom",
                  {
                    func: (e, t, i) => {
                      var o;
                      return (
                        e <
                        ((null == i
                          ? void 0
                          : null === (o = i.contract_info) || void 0 === o
                          ? void 0
                          : o.buy_price) || 0) +
                          1
                      );
                    },
                    message: (0, s.NC)(
                      "Invalid stop loss. Stop loss cannot be more than stake."
                    ),
                  },
                ],
              ],
            },
            contract_update_take_profit: {
              rules: [
                [
                  "req",
                  {
                    condition: (e) => !e.contract_update_take_profit,
                    message: (0, s.NC)("Please enter a take profit amount."),
                  },
                ],
                [
                  "custom",
                  {
                    func: (e, t, i) => {
                      let s = (0, o.vMw)(i.contract_info);
                      return !(s > 0 && +e < s);
                    },
                    message: (0, s.NC)(
                      "Please enter a take profit amount that's higher than the current potential profit."
                    ),
                  },
                ],
              ],
            },
          });
      },
      49985: function (e, t, i) {
        "use strict";
        i.d(t, { y: () => o });
        let o = Object.freeze({
          TAB_LOCAL: "local_tab",
          TAB_GOOGLE: "google_tab",
          TAB_RECENT: "recent_tab",
        });
      },
      68853: function (e, t, i) {
        "use strict";
        i.r(t),
          i.d(t, {
            OSCARS_GRIND: () => n,
            D_ALEMBERT: () => r,
            REVERSE_D_ALEMBERT: () => l,
            REVERSE_MARTINGALE: () => c,
            STRATEGY_1_3_2_6: () => d,
            MARTINGALE: () => a,
          });
        var o = i(21995),
          s = i(48059);
        let r = () => [
            {
              type: "subtitle",
              content: [
                (0, s.NC)("Exploring the D’Alembert strategy in Deriv Bot"),
              ],
              expanded: !0,
              no_collapsible: !1,
            },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "The D'Alembert strategy involves increasing your stake after a losing trade and reducing it after a successful trade by a predetermined number of units."
                ),
              ],
            },
            { type: "subtitle", content: [(0, s.NC)("Key parameters")] },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "These are the trade parameters used for D’Alembert strategy in Deriv Bot."
                ),
              ],
            },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "<strong>Initial stake:</strong> The amount that you are willing to place as a stake to enter a trade. This is the starting point for any changes in stake depending on the dynamic of the strategy being used."
                ),
              ],
            },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "<strong>Unit:</strong> The number of units that are added in the event of a trade resulting in loss or the number of units removed in the event of a trade resulting in profit. For example, if the unit is set at 2, the stake increases or decreases by two times the initial stake of 1 USD, meaning it changes by 2 USD."
                ),
              ],
            },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "<strong>Profit threshold:</strong> The bot will stop trading if your total profit exceeds this amount."
                ),
              ],
            },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "<strong>Loss threshold:</strong> The bot will stop trading if your total loss exceeds this amount."
                ),
              ],
            },
            {
              type: "subtitle",
              content: [(0, s.NC)("An example of D’Alembert strategy")],
            },
            {
              type: "media",
              src: (0, o.oY)("dalembert.svg"),
              alt: (0, s.NC)("An example of D’Alembert strategy"),
            },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "1. Start with the initial stake. In this example, we’ll use 1 USD."
                ),
                (0, s.NC)(
                  "2. Set your preferred unit. In this example, it is 2 units or 2 USD."
                ),
                (0, s.NC)(
                  "3. If the first trade results in profit, the stake for the following trade will not reduce but remain at the initial stake. The strategy minimally trades at the initial stake of 1 USD. See A1."
                ),
                (0, s.NC)(
                  "4. If the second trade results in a loss, the Deriv Bot will automatically increase your stake for the next trade by 2 USD. Deriv Bot will continue to add 2 USD to the previous round’s stake after every losing trade. See A2."
                ),
                (0, s.NC)(
                  "5. If the next trades are profitable, the stake for the following trade will be reduced by 2 USD. This can be shown above where the stake of 3 USD is reduced to 1 USD. See A3."
                ),
              ],
            },
            {
              type: "subtitle",
              content: [(0, s.NC)("Profit and loss thresholds")],
            },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "With Deriv Bot, traders can set the profit and loss thresholds to secure potential profits and limit potential losses. This means that the trading bot will automatically stop when either the profit or loss thresholds are reached. It's a form of risk management that can potentially enhance returns. For example, if a trader sets the profit threshold at 100 USD and the strategy exceeds 100 USD of profit from all trades, then the bot will stop running."
                ),
              ],
            },
            {
              type: "subtitle",
              content: [(0, s.NC)("Estimating the lifespan of your trades")],
            },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "The D’Alembert strategy is less risky than Martingale, but you can still determine how long your funds will last with this strategy before trading. Simply use this formula."
                ),
              ],
            },
            {
              type: "media",
              src: (0, o.oY)("dalembert_formula_1.svg"),
              dark_src: (0, o.oY)("dalembert_formula_dark_1.svg"),
              alt: (0, s.NC)("D’Alembert formula 1"),
              className: "formula",
              styles: { height: "6rem" },
            },
            {
              type: "text",
              content: [
                (0, s.NC)("Where:"),
                (0, s.NC)(
                  "R is the number of rounds a trader can sustain given a specific loss threshold."
                ),
                (0, s.NC)("B is the loss threshold."),
                (0, s.NC)("s is the initial stake."),
                (0, s.NC)("f is the unit increment."),
              ],
              className: "no-margin",
            },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "For instance, if a trader has a loss threshold (B) of 100 USD, with an initial stake (s) of 1 USD and 2 units of increment (f), the calculation would be as follows:"
                ),
              ],
              className: "top-margin",
            },
            {
              type: "media",
              src: (0, o.oY)("dalembert_formula_2.svg"),
              dark_src: (0, o.oY)("dalembert_formula_dark_2.svg"),
              alt: (0, s.NC)("D’Alembert formula 2"),
              className: "formula",
              styles: { height: "6rem" },
            },
            { type: "text", content: [(0, s.NC)("Number of rounds (R) = 10")] },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "This means after 10 rounds of consecutive losses, this trader will lose 100 USD. This reaches the loss threshold of 100 USD, stopping the bot."
                ),
              ],
            },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "This formula helps you plan your trades by considering the amount of money you have and your comfort level with risk. It involves determining your loss threshold and the initial stake you want to trade with. Then, you use this formula to calculate the number of rounds you can trade. This process provides insight into stake sizing and expectations."
                ),
              ],
            },
            { type: "subtitle", content: [(0, s.NC)("Summary")] },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "The D'Alembert system offers more balanced trading through controlled stake progression. With prudent risk management like stake limits, it can be effectively automated in Deriv Bot. However, traders should thoroughly assess their risk appetite, test strategies on a demo account to align with their trading style before trading with real money. This allows optimising the approach and striking a balance between potential gains and losses whilst managing risk."
                ),
              ],
            },
            {
              type: "text_italic",
              content: [(0, s.NC)("<strong>Disclaimer:</strong>")],
            },
            {
              type: "text_italic",
              content: [
                (0, s.NC)(
                  "Please be aware that while we may use rounded figures for illustration, a stake of a specific amount does not guarantee an exact amount in successful trades. For example, a 1 USD stake does not necessarily equate to a 1 USD profit in successful trades."
                ),
              ],
            },
            {
              type: "text_italic",
              content: [
                (0, s.NC)(
                  "Trading inherently involves risks, and actual profits can fluctuate due to various factors, including market volatility and other unforeseen variables. As such, exercise caution and conduct thorough research before engaging in any trading activities."
                ),
              ],
            },
          ],
          a = () => [
            {
              type: "subtitle",
              content: [
                (0, s.NC)("Exploring the Martingale strategy in Deriv Bot"),
              ],
              expanded: !0,
              no_collapsible: !1,
            },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "The Martingale strategy involves increasing your stake after each loss to recoup prior losses with a single successful trade."
                ),
                (0, s.NC)(
                  "This article explores the Martingale strategy integrated into Deriv Bot, a versatile trading bot designed to trade assets such as forex, commodities, and derived indices. We will delve into the strategy's core parameters, its application, and provide essential takeaways for traders looking to use the bot effectively."
                ),
              ],
            },
            { type: "subtitle", content: [(0, s.NC)("Key parameters")] },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "These are the trade parameters used in Deriv Bot with Martingale strategy."
                ),
              ],
            },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "<strong>Initial stake:</strong> The amount that you are willing to place as a stake to enter a trade. This is the starting point for any changes in stake depending on the dynamic of the strategy being used."
                ),
              ],
            },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "<strong>Multiplier:</strong> The multiplier used to increase your stake if you're losing a trade. The value must be greater than 1."
                ),
              ],
            },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "<strong>Profit threshold:</strong> The bot will stop trading if your total profit exceeds this amount."
                ),
              ],
            },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "<strong>Loss threshold:</strong> The bot will stop trading if your total loss exceeds this amount."
                ),
              ],
            },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "<strong>Maximum stake:</strong> The maximum amount you are willing to pay to enter a single trade. The stake for your next trade will reset to the initial stake if it exceeds this value. This is an optional risk management parameter."
                ),
              ],
            },
            {
              type: "subtitle",
              content: [(0, s.NC)("An example of Martingale strategy")],
            },
            {
              type: "media",
              src: (0, o.oY)("martingale.svg"),
              alt: (0, s.NC)("An example of Martingale strategy"),
            },
            {
              type: "text",
              content: [
                (0, s.NC)("1. Start with the initial stake. Let’s say 1 USD."),
                (0, s.NC)(
                  "2. Select your Martingale multiplier. In this example, it is 2."
                ),
                (0, s.NC)(
                  "3. If the first trade ends in a loss, Deriv Bot will automatically double your stake for the next trade to 2 USD. Deriv Bot will continue to double the stake after every losing trade."
                ),
                (0, s.NC)(
                  "4. If a trade ends in a profit, the stake for the following trade will be reset to the initial stake amount of 1 USD."
                ),
              ],
            },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "The idea is that successful trades may recoup previous losses. However, it is crucial to exercise caution as the risk can quickly increase with this strategy. With Deriv Bot, you can minimise your risk by setting a maximum stake. This is an optional risk management feature. Let’s say a maximum stake of 3 USD. If your stake for the next trade is set to exceed 3 USD, your stake will reset to the initial stake of 1 USD. If you didn't set a maximum stake, it would have increased beyond 3 USD."
                ),
              ],
            },
            {
              type: "subtitle",
              content: [(0, s.NC)("Profit and loss thresholds")],
            },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "With Deriv Bot, traders can set the profit and loss thresholds to secure potential profits and limit potential losses. This means that the trading bot will automatically stop when either the profit or loss thresholds are reached. It's a form of risk management that can potentially enhance returns. For example, if a trader sets the profit threshold at 100 USD and the strategy exceeds 100 USD of profit from all trades, then the bot will stop running."
                ),
              ],
            },
            {
              type: "subtitle",
              content: [(0, s.NC)("Estimating the lifespan of your trades")],
            },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "If you're about to start trading and haven't established a Maximum Stake as part of your risk management strategy, you can determine how long your funds will last by employing the Martingale strategy. Simply use this formula."
                ),
              ],
            },
            {
              type: "media",
              src: (0, o.oY)("martingale_formula_1.svg"),
              dark_src: (0, o.oY)("martingale_formula_dark_1.svg"),
              alt: (0, s.NC)("Martingale formula 1"),
              className: "formula",
              styles: { height: "6.5rem" },
            },
            {
              type: "text",
              content: [
                (0, s.NC)("Where:"),
                (0, s.NC)(
                  "R is the number of rounds a trader can sustain given a specific loss threshold."
                ),
                (0, s.NC)("B is the loss threshold."),
                (0, s.NC)("s is the initial stake."),
                (0, s.NC)("m is the Martingale multiplier."),
              ],
              className: "no-margin",
            },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "For instance, if a trader has a loss threshold (B) is 1000 USD, with an initial stake (s) is 1 USD, and the Martingale multiplier (m) is 2, the calculation would be as follows:"
                ),
              ],
              className: "top-margin",
            },
            {
              type: "media",
              src: (0, o.oY)("martingale_formula_2.svg"),
              dark_src: (0, o.oY)("martingale_formula_dark_2.svg"),
              alt: (0, s.NC)("Martingale formula 2"),
              className: "formula",
              styles: { height: "6.5rem" },
            },
            {
              type: "text",
              content: [
                (0, s.NC)("Number of rounds, R ≈ 9.965"),
                (0, s.NC)(
                  "This means that after 10 rounds of consecutive losses, this trader will lose 1023 USD which exceeds the loss threshold of 1000 USD, stopping the bot."
                ),
                (0, s.NC)(
                  "This formula helps you plan your trades by considering the amount of money you have and your comfort level with risk. It involves determining your loss threshold and the initial stake you want to trade with. Then, you use this formula to calculate the number of rounds you can trade. This process provides insight into stake sizing and expectations."
                ),
              ],
            },
            { type: "subtitle", content: [(0, s.NC)("Summary")] },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "The Martingale strategy in trading may offer substantial gains but also comes with significant risks. With your selected strategy, Deriv Bot provides automated trading with risk management measures like setting initial stake, stake size, maximum stake, profit threshold and loss threshold. It's crucial for traders to assess their risk tolerance, practice in a demo account, and understand the strategy before trading with real money."
                ),
              ],
            },
            {
              type: "text_italic",
              content: [(0, s.NC)("<strong>Disclaimer:</strong>")],
            },
            {
              type: "text_italic",
              content: [
                (0, s.NC)(
                  "Please be aware that while we may use rounded figures for illustration, a stake of a specific amount does not guarantee an exact amount in successful trades. For example, a 1 USD stake does not necessarily equate to a 1 USD profit in successful trades."
                ),
              ],
            },
            {
              type: "text_italic",
              content: [
                (0, s.NC)(
                  "Trading inherently involves risks, and actual profits can fluctuate due to various factors, including market volatility and other unforeseen variables. As such, exercise caution and conduct thorough research before engaging in any trading activities."
                ),
              ],
            },
          ],
          n = () => [
            {
              type: "subtitle",
              content: [
                (0, s.NC)("Exploring the Oscar’s Grind strategy in Deriv Bot"),
              ],
              expanded: !0,
              no_collapsible: !1,
            },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "The Oscar’s Grind strategy is designed to potentially gain a modest yet steady profit in each trading session. This strategy splits trades into sessions and has three principles."
                ),
              ],
            },
            { type: "subtitle", content: [(0, s.NC)("Key parameters")] },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "These are the trade parameters used for Oscar’s Grind strategy in Deriv Bot."
                ),
              ],
            },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "<strong>Initial stake:</strong> The amount that you are willing to place as a stake to enter a trade. This is the starting point for any changes in stake depending on the dynamic of the strategy being used."
                ),
              ],
            },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "<strong>Profit threshold:</strong> The bot will stop trading if your total profit exceeds this amount."
                ),
              ],
            },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "<strong>Loss threshold:</strong> The bot will stop trading if your total loss exceeds this amount."
                ),
              ],
            },
            {
              type: "subtitle",
              content: [(0, s.NC)("An example of Oscar’s Grind strategy")],
            },
            {
              type: "media",
              src: (0, o.oY)("oscars_grind.png"),
              alt: (0, s.NC)("An example of Oscar’s Grind strategy"),
            },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "<strong>Principle 1: Strategy aims to potentially make one unit of profit per session</strong>"
                ),
              ],
            },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "The table above demonstrates this principle by showing that when a successful trade occurs and meets the target of one unit of potential profit which is 1 USD in this example, the session ends. If trading continues, a new session will begin."
                ),
              ],
            },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "<strong>Principle 2: The stake only increases when a loss trade is followed by a successful trade</strong>"
                ),
              ],
            },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "The table illustrates this principle in the second session. After a trade resulting in loss in round 4 followed by a successful trade in round 5, the stake will increase to 2 USD for round 6. This is in line with the strategy's rule of raising the stake only after a loss is followed by a successful trade."
                ),
              ],
            },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "<strong>Principle 3: The stake adjusts to the gap size between current loss and the target profit for the session</strong>"
                ),
              ],
            },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "In round 7, the stake is adjusted downwards from 2 USD to 1 USD, to meet the target profit of 1 USD."
                ),
              ],
            },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "The stake adjustment: target session profit (1 USD) - current session profit (0 USD) = 1 USD"
                ),
              ],
            },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "The second session concludes upon reaching the aim of one unit of potential profit per session, equivalent to 1 USD. If trading continues, a new session will commence again."
                ),
              ],
            },
            {
              type: "subtitle",
              content: [(0, s.NC)("Profit and loss thresholds")],
            },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "With Deriv Bot, traders can set the profit and loss thresholds to secure potential profits and limit potential losses. This means that the trading bot will automatically stop when either the profit or loss threshold is reached. This is a form of risk management that can potentially boost successful trades whilst limiting the impact of loss. For example, if a trader sets the profit threshold at 100 USD and the strategy exceeds 100 USD of profit from all trades, then the bot will stop running."
                ),
              ],
            },
            { type: "subtitle", content: [(0, s.NC)("Summary")] },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "The Oscar's Grind strategy provides a disciplined approach for incremental gains through systematic stake progression. When integrated into Deriv Bot with proper risk management like profit or loss thresholds, it offers traders a potentially powerful automated trading technique. However, traders should first thoroughly assess their risk tolerance and first try trading on a demo account in order to familiarise with the strategy before trading with real funds."
                ),
              ],
            },
            {
              type: "text_italic",
              content: [(0, s.NC)("<strong>Disclaimer:</strong>")],
            },
            {
              type: "text_italic",
              content: [
                (0, s.NC)(
                  "Please be aware that while we may use rounded figures for illustration, a stake of a specific amount does not guarantee an exact amount in successful trades. For example, a 1 USD stake does not necessarily equate to a 1 USD profit in successful trades."
                ),
              ],
            },
            {
              type: "text_italic",
              content: [
                (0, s.NC)(
                  "Trading inherently involves risks, and actual profits can fluctuate due to various factors, including market volatility and other unforeseen variables. As such, exercise caution and conduct thorough research before engaging in any trading activities."
                ),
              ],
            },
          ],
          l = () => [
            {
              type: "subtitle",
              content: [
                (0, s.NC)(
                  "Exploring the Reverse D’Alembert strategy in Deriv Bot"
                ),
              ],
              expanded: !0,
              no_collapsible: !1,
            },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "The Reverse D'Alembert strategy involves increasing your stake after a successful trade and reducing it after a losing trade by a predetermined number of units."
                ),
              ],
            },
            { type: "subtitle", content: [(0, s.NC)("Key parameters")] },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "These are the trade parameters used in Deriv Bot with Reverse D’Alembert strategy."
                ),
              ],
            },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "<strong>Initial stake:</strong> The amount that you are willing to place as a stake to enter a trade. This is the starting point for any changes in stake depending on the dynamic of the strategy being used."
                ),
              ],
            },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "<strong>Unit:</strong> The number of units that are added in the event of successful trades or the number of units removed in the event of losing trades. For example, if the unit is set at 2, the stake increases or decreases by two times the initial stake of 1 USD, meaning it changes by 2 USD."
                ),
              ],
            },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "<strong>Profit threshold:</strong> The bot will stop trading if your total profit exceeds this amount."
                ),
              ],
            },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "<strong>Loss threshold:</strong> The bot will stop trading if your total loss exceeds this amount."
                ),
              ],
            },
            {
              type: "subtitle",
              content: [(0, s.NC)("An example of Reverse D’Alembert strategy")],
            },
            {
              type: "media",
              src: (0, o.oY)("reverse_dalembert.svg"),
              alt: (0, s.NC)("An example of Reverse D’Alembert strategy"),
            },
            {
              type: "text",
              content: [
                (0, s.NC)("1. Start with the initial stake. Let’s say 1 USD."),
                (0, s.NC)(
                  "2. Select your unit. In this example, it is 2 units or 2 USD."
                ),
                (0, s.NC)(
                  "3. For trades that result in a profit, the stake for the next trade will be increased by 2 USD. Deriv Bot will continue to add 2 USD for every successful trade. See A1."
                ),
                (0, s.NC)(
                  "4. For trades that result in a loss, there are two outcomes.  If it was traded at the initial stake, the next trade will remain at the same amount as the strategy trades minimally at the initial stake, see A2. If it was traded with a higher amount, the stake for the next trade would be reduced by 2 USD, see A3."
                ),
              ],
            },
            {
              type: "subtitle",
              content: [(0, s.NC)("Profit and loss thresholds")],
            },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "With Deriv Bot, traders can set the profit and loss thresholds to secure potential profits and limit potential losses. This means that the trading bot will automatically stop when either the profit or loss threshold is reached. This is a form of risk management that can potentially boost successful trades whilst limiting the impact of loss. For example, if a trader sets the profit threshold at 100 USD and the strategy exceeds 100 USD of profit from all trades, then the bot will stop running."
                ),
              ],
            },
            { type: "subtitle", content: [(0, s.NC)("Summary")] },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "Effective trading with the D'Alembert system requires careful consideration of its stake progression and risk management. Traders can automate this approach using Deriv Bot, setting profit and loss thresholds to ensure balanced and controlled trading. However, it is crucial for traders to assess their risk appetite, test strategies on a demo account, and align with their own trading style before transitioning to real money trading. This optimization process helps strike a balance between potential gains and losses while managing risk prudently."
                ),
              ],
            },
            {
              type: "text_italic",
              content: [(0, s.NC)("<strong>Disclaimer:</strong>")],
            },
            {
              type: "text_italic",
              content: [
                (0, s.NC)(
                  "Please be aware that while we may use rounded figures for illustration, a stake of a specific amount does not guarantee an exact amount in successful trades. For example, a 1 USD stake does not necessarily equate to a 1 USD  profit in successful trades."
                ),
              ],
            },
            {
              type: "text_italic",
              content: [
                (0, s.NC)(
                  "Trading inherently involves risks, and actual profits can fluctuate due to various factors, including market volatility and other unforeseen variables. As such, exercise caution and conduct thorough research before engaging in any trading activities."
                ),
              ],
            },
          ],
          c = () => [
            {
              type: "subtitle",
              content: [
                (0, s.NC)(
                  "Exploring the Reverse Martingale strategy in Deriv Bot"
                ),
              ],
              expanded: !0,
              no_collapsible: !1,
            },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "The Reverse Martingale strategy involves increasing your stake after each successful trade and resets to the initial stake for every losing trade as it aims to secure potential profits from consecutive wins."
                ),
                (0, s.NC)(
                  "This article explores the Reverse Martingale strategy integrated into Deriv Bot, a versatile trading bot designed to trade assets such as forex, commodities, and derived indices. We will delve into the strategy's core parameters, its application, and provide essential takeaways for traders looking to use the bot effectively."
                ),
              ],
            },
            { type: "subtitle", content: [(0, s.NC)("Key parameters")] },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "These are the trade parameters used in Deriv Bot with Reverse Martingale strategy."
                ),
              ],
            },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "<strong>Initial stake:</strong> The amount that you are willing to place as a stake to enter a trade. This is the starting point for any changes in stake depending on the dynamic of the strategy being used."
                ),
              ],
            },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "<strong>Multiplier:</strong> The multiplier used to increase your stake if your trade is successful. The value must be greater than 1."
                ),
              ],
            },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "<strong>Profit threshold:</strong> The bot will stop trading if your total profit exceeds this amount."
                ),
              ],
            },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "<strong>Loss threshold:</strong> The bot will stop trading if your total loss exceeds this amount."
                ),
              ],
            },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "<strong>Maximum stake:</strong> The maximum amount you are willing to pay to enter a single trade. The stake for your next trade will reset to the initial stake if it exceeds this value. This is an optional risk management parameter."
                ),
              ],
            },
            {
              type: "subtitle",
              content: [(0, s.NC)("An example of Reverse Martingale strategy")],
            },
            {
              type: "media",
              src: (0, o.oY)("reverse_martingale.svg"),
              alt: (0, s.NC)("An example of Martingale strategy"),
            },
            {
              type: "text",
              content: [
                (0, s.NC)("1. Start with the initial stake. Let’s say 1 USD."),
                (0, s.NC)(
                  "2. Select your Martingale multiplier. In this example, it is 2."
                ),
                (0, s.NC)(
                  "3. If the first trade is a successful trade, Deriv Bot will automatically double your stake for the next trade to 2 USD. Deriv Bot will continue to double the stake after every successful trade."
                ),
                (0, s.NC)(
                  "4. If a trade ends in a loss, the stake for the following trade will be reset to the initial stake amount of 1 USD."
                ),
              ],
            },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "The objective of Martingale strategy is to take advantage of consecutive successful trades and maximise potential profits from them. This strategy is beneficial only if there are consecutive successful trades. Therefore, it is important to set a maximum stake to secure all the potential profits gained from a number of consecutive successful trades, or you could lose all the profits you have accumulated, including your initial stake. For example, if your goal is to maximise profits within 2 consecutive successful trades, you set a maximum stake of 2 USD, given your initial stake is 1 USD. Similarly, if your goal is to maximise profits within 3 consecutive successful trades, you set a maximum stake of 4 USD, given your initial stake is 1 USD."
                ),
              ],
            },
            {
              type: "subtitle",
              content: [(0, s.NC)("Profit and loss thresholds")],
            },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "With Deriv Bot, traders can set the profit and loss thresholds to secure potential profits and limit potential losses. This means that the trading bot will automatically stop when either the profit or loss threshold is reached. This is a form of risk management that can potentially boost successful trades whilst limiting the impact of loss. For example, if a trader sets the profit threshold at 100 USD and the strategy exceeds 100 USD of profit from all trades, then the bot will stop running."
                ),
              ],
            },
            { type: "subtitle", content: [(0, s.NC)("Summary")] },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "The Reverse Martingale strategy in trading may offer substantial gains but also comes with significant risks. With your selected strategy, Deriv Bot provides automated trading with risk management measures like setting initial stake, stake size, maximum stake, profit threshold and loss threshold. It's crucial for traders to assess their risk tolerance, practice in a demo account, and understand the strategy before trading with real money."
                ),
              ],
            },
            {
              type: "text_italic",
              content: [(0, s.NC)("<strong>Disclaimer:</strong>")],
            },
            {
              type: "text_italic",
              content: [
                (0, s.NC)(
                  "Please be aware that while we may use rounded figures for illustration, a stake of a specific amount does not guarantee an exact amount in successful trades. For example, a 1 USD stake does not necessarily equate to a 1 USD profit in successful trades."
                ),
              ],
            },
            {
              type: "text_italic",
              content: [
                (0, s.NC)(
                  "Trading inherently involves risks, and actual profits can fluctuate due to various factors, including market volatility and other unforeseen variables. As such, exercise caution and conduct thorough research before engaging in any trading activities."
                ),
              ],
            },
          ],
          d = () => [
            {
              type: "subtitle",
              content: [
                (0, s.NC)("Exploring the 1-3-2-6 strategy in Deriv Bot"),
              ],
              expanded: !0,
              no_collapsible: !1,
            },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "The 1-3-2-6 strategy aims to maximise potential profits with four consecutive successful trades. One unit is equal to the amount of the initial stake. The stake will adjust from 1 unit to 3 units after the first successful trade, then to 2 units after your second successful trade, and to 6 units after the third successful trade. The stake for the next trade will reset to the initial stake if there is a losing trade or a completion of the trade cycle."
                ),
                (0, s.NC)(
                  "This article explores the strategy integrated into Deriv Bot, a versatile trading bot designed to trade assets such as Forex, Commodities, and Derived Indices. We will delve into the strategy's core parameters, its application, and provide essential takeaways for traders looking to use the bot effectively."
                ),
              ],
            },
            { type: "subtitle", content: [(0, s.NC)("Key parameters")] },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "These are the trade parameters used in Deriv Bot with 1-3-2-6 strategy."
                ),
              ],
            },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "<strong>Initial stake:</strong> The amount that you are willing to place as a stake to enter a trade. This is the starting point for any changes in stake depending on the dynamic of the strategy being used."
                ),
              ],
            },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "<strong>Profit threshold:</strong> The bot will stop trading if your total profit exceeds this amount."
                ),
              ],
            },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "<strong>Loss threshold:</strong> The bot will stop trading if your total loss exceeds this amount."
                ),
              ],
            },
            {
              type: "subtitle",
              content: [(0, s.NC)("An example of 1-3-2-6 strategy")],
            },
            {
              type: "media",
              src: (0, o.oY)("1-3-2-6.svg"),
              alt: (0, s.NC)("An example of 1-3-2-6 strategy"),
            },
            {
              type: "text",
              content: [
                (0, s.NC)("1. Start with the initial stake. Let’s say 1 USD."),
                (0, s.NC)(
                  "2. If the trade is successful, this strategy will automatically adjust your stake to 3 units of your initial stake for the next trade. In this case, the stake adjustment is 3 units and the initial stake is 1 USD, hence the next trade will start at 3 USD."
                ),
                (0, s.NC)(
                  "3. If the second trade is also successful, your stake will adjust to 2 USD or 2 units of the initial stake for the next trade."
                ),
                (0, s.NC)(
                  "4. However, if any trade results in a loss, your stake will reset back to the initial stake of 1 USD for the next trade. The third trade results in a loss hence the stake resets to the initial stake of 1 USD for the next trade."
                ),
                (0, s.NC)(
                  "5. Upon reaching the initial stake, if the next trade still results in a loss, your stake will remain at the initial stake of 1 USD. This strategy will minimally trade at the initial stake. Refer to the fourth and fifth trade."
                ),
                (0, s.NC)(
                  "6. If consecutive successful trades were to happen, the stake would follow a sequence of adjustment from 1 to 3, then 2, and 6 units of initial stake. After 4 consecutive successful trades, it completes one cycle and then the strategy will repeat itself for another cycle. If any trade results in a loss, your stake will reset back to the initial stake for the next trade."
                ),
              ],
            },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "The 1-3-2-6 strategy is designed to capitalise on consecutive successful trades while minimising losses during losing streaks. The rationale behind this strategy lies in statistical probabilities, with adjustments to stake sizes based on the perceived likelihood of success. There is a higher likelihood of success in the second trade after one successful trade. Hence the stake adjusts to 3 in the second trade. In the third trade, the stake adjusts to 2 units due to a lower probability of a successful trade. If the third trade is also successful, the strategy then allocates all the previous gains (a total of 6 units of initial stake) into the fourth trade with the aim of doubling the potential profits. If the fourth trade results in a positive outcome, the strategy helps achieve a total gain of 12 units. However, it is crucial to exercise caution, as the risk can escalate quickly with this strategy, and any loss in the fourth trade forfeits all previous gains."
                ),
              ],
            },
            {
              type: "subtitle",
              content: [(0, s.NC)("Profit and loss thresholds")],
            },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "With Deriv Bot, traders can set the profit and loss thresholds to secure potential profits and limit potential losses. This means that the trading bot will automatically stop when either the profit or loss threshold is reached. This is a form of risk management that can potentially boost successful trades whilst limiting the impact of loss. For example, if a trader sets the profit threshold at 100 USD and the strategy exceeds 100 USD of profit from all trades, then the bot will stop running."
                ),
              ],
            },
            { type: "subtitle", content: [(0, s.NC)("Summary")] },
            {
              type: "text",
              content: [
                (0, s.NC)(
                  "The 1-3-2-6 strategy in trading may offer substantial gains but also comes with significant risks. Each stake is independent, and the strategy does not increase your chances of successful trades in the long run. If you encounter a series of losses, the strategy can lead to significant losses. Therefore, it is crucial for traders to assess their risk tolerance, practice in a demo account, utilise profit and loss thresholds, and fully comprehend the strategy before engaging in real-money trading."
                ),
              ],
            },
            {
              type: "text_italic",
              content: [(0, s.NC)("<strong>Disclaimer:</strong>")],
            },
            {
              type: "text_italic",
              content: [
                (0, s.NC)(
                  "Please be aware that while we may use rounded figures for illustration, a stake of a specific amount does not guarantee an exact amount in successful trades. For example, a 1 USD stake does not necessarily equate to a 1 USD profit in successful trades."
                ),
                (0, s.NC)(
                  "Trading inherently involves risks, and actual profits can fluctuate due to various factors, including market volatility and other unforeseen variables. As such, exercise caution and conduct thorough research before engaging in any trading activities."
                ),
              ],
            },
          ];
      },
      33690: function (e, t, i) {
        "use strict";
        i.d(t, { i: () => o });
        let o = Object.freeze({ CONTRACT: "contract", DIVIDER: "divider" });
      },
      47962: function (e, t, i) {
        "use strict";
        i.d(t, { v: () => r });
        var o = i(48059);
        let s = ["BTC", "ETH", "LTC", "BCH", "UST"],
          r = () => ({
            lists: {
              PAYOUTTYPE: [[(0, o.NC)("Stake"), "stake"]],
              CRYPTO_CURRENCIES: s,
              DETAILS: [
                [(0, o.NC)("deal reference id"), "1"],
                [(0, o.NC)("purchase price"), "2"],
                [(0, o.NC)("payout"), "3"],
                [(0, o.NC)("profit"), "4"],
                [(0, o.NC)("contract type"), "5"],
                [(0, o.NC)("entry spot time"), "6"],
                [(0, o.NC)("entry spot price"), "7"],
                [(0, o.NC)("exit spot time"), "8"],
                [(0, o.NC)("exit spot price"), "9"],
                [(0, o.NC)("barrier"), "10"],
                [(0, o.NC)("result"), "11"],
              ],
              CHECK_RESULT: [
                [(0, o.NC)("Win"), "win"],
                [(0, o.NC)("Loss"), "loss"],
              ],
              CHECK_DIRECTION: [
                [(0, o.NC)("Rise"), "rise"],
                [(0, o.NC)("Fall"), "fall"],
                [(0, o.NC)("No Change"), ""],
              ],
              BALANCE_TYPE: [
                [(0, o.NC)("string"), "STR"],
                [(0, o.NC)("number"), "NUM"],
              ],
              NOTIFICATION_TYPE: [
                [(0, o.NC)("green"), "success"],
                [(0, o.NC)("blue"), "info"],
                [(0, o.NC)("yellow"), "warn"],
                [(0, o.NC)("red"), "error"],
              ],
              NOTIFICATION_SOUND: [
                [(0, o.NC)("Silent"), "silent"],
                [(0, o.NC)("Announcement"), "announcement"],
                [(0, o.NC)("Earned money"), "earned-money"],
                [(0, o.NC)("Job done"), "job-done"],
                [(0, o.NC)("Error"), "error"],
                [(0, o.NC)("Severe error"), "severe-error"],
              ],
              CURRENCY: ["USD", "EUR", "GBP", "AUD", ...s],
            },
            opposites: {
              ACCUMULATOR: [{ ACCU: (0, o.NC)("Buy") }],
              MULTIPLIER: [
                { MULTUP: (0, o.NC)("Up") },
                { MULTDOWN: (0, o.NC)("Down") },
              ],
              CALLPUT: [
                { CALL: (0, o.NC)("Rise") },
                { PUT: (0, o.NC)("Fall") },
              ],
              CALLPUTEQUAL: [
                { CALLE: (0, o.NC)("Rise Equals") },
                { PUTE: (0, o.NC)("Fall Equals") },
              ],
              HIGHERLOWER: [
                { CALL: (0, o.NC)("Higher") },
                { PUT: (0, o.NC)("Lower") },
              ],
              TOUCHNOTOUCH: [
                { ONETOUCH: (0, o.NC)("Touch") },
                { NOTOUCH: (0, o.NC)("No Touch") },
              ],
              ENDSINOUT: [
                { EXPIRYRANGE: (0, o.NC)("Ends Between") },
                { EXPIRYMISS: (0, o.NC)("Ends Outside") },
              ],
              STAYSINOUT: [
                { RANGE: (0, o.NC)("Stays Between") },
                { UPORDOWN: (0, o.NC)("Goes Outside") },
              ],
              ASIANS: [
                { ASIANU: (0, o.NC)("Asian Up") },
                { ASIAND: (0, o.NC)("Asian Down") },
              ],
              MATCHESDIFFERS: [
                { DIGITMATCH: (0, o.NC)("Matches") },
                { DIGITDIFF: (0, o.NC)("Differs") },
              ],
              EVENODD: [
                { DIGITEVEN: (0, o.NC)("Even") },
                { DIGITODD: (0, o.NC)("Odd") },
              ],
              OVERUNDER: [
                { DIGITOVER: (0, o.NC)("Over") },
                { DIGITUNDER: (0, o.NC)("Under") },
              ],
              HIGHLOWTICKS: [
                { TICKHIGH: (0, o.NC)("High Tick") },
                { TICKLOW: (0, o.NC)("Low Tick") },
              ],
              RESET: [
                { RESETCALL: (0, o.NC)("Reset Call") },
                { RESETPUT: (0, o.NC)("Reset Put") },
              ],
              RUNS: [
                { RUNHIGH: (0, o.NC)("Only Ups") },
                { RUNLOW: (0, o.NC)("Only Downs") },
              ],
              CALLPUTSPREAD: [
                { CALLSPREAD: (0, o.NC)("Call Spread") },
                { PUTSPREAD: (0, o.NC)("Put Spread") },
              ],
            },
            BARRIER_TYPES: [
              ["Offset +", "+"],
              ["Offset -", "-"],
            ],
            ohlcFields: [
              [(0, o.NC)("Open"), "open"],
              [(0, o.NC)("High"), "high"],
              [(0, o.NC)("Low"), "low"],
              [(0, o.NC)("Close"), "close"],
              [(0, o.NC)("Open Time"), "epoch"],
            ],
            candleIntervals: [
              [(0, o.NC)("Default"), "default"],
              [(0, o.NC)("1 minute"), "60"],
              [(0, o.NC)("2 minutes"), "120"],
              [(0, o.NC)("3 minutes"), "180"],
              [(0, o.NC)("5 minutes"), "300"],
              [(0, o.NC)("10 minutes"), "600"],
              [(0, o.NC)("15 minutes"), "900"],
              [(0, o.NC)("30 minutes"), "1800"],
              [(0, o.NC)("1 hour"), "3600"],
              [(0, o.NC)("2 hours"), "7200"],
              [(0, o.NC)("4 hours"), "14400"],
              [(0, o.NC)("8 hours"), "28800"],
              [(0, o.NC)("1 day"), "86400"],
            ],
            mainBlocks: [
              "trade_definition",
              "before_purchase",
              "during_purchase",
              "after_purchase",
            ],
            mandatoryMainBlocks: [
              "trade_definition",
              "purchase",
              "before_purchase",
            ],
            procedureDefinitionBlocks: [
              "procedures_defnoreturn",
              "procedures_defreturn",
            ],
            single_instance_blocks: [
              "trade_definition",
              "before_purchase",
              "during_purchase",
              "after_purchase",
            ],
            TRADE_TYPE_TO_CONTRACT_CATEGORY_MAPPING: {
              callput: ["callput", "higherlower"],
              asian: ["asians"],
              digits: ["matchesdiffers", "evenodd", "overunder"],
            },
            TRADE_TYPE_CATEGORIES: {
              multiplier: ["multiplier"],
              callput: ["callput", "callputequal", "higherlower"],
              touchnotouch: ["touchnotouch"],
              inout: ["endsinout", "staysinout"],
              asian: ["asians"],
              digits: ["matchesdiffers", "evenodd", "overunder"],
              reset: ["reset"],
              callputspread: ["callputspread"],
              highlowticks: ["highlowticks"],
              runs: ["runs"],
              accumulator: ["accumulator"],
            },
            TRADE_TYPE_CATEGORY_NAMES: {
              callput: (0, o.NC)("Up/Down"),
              touchnotouch: (0, o.NC)("Touch/No Touch"),
              inout: (0, o.NC)("In/Out"),
              asian: (0, o.NC)("Asians"),
              digits: (0, o.NC)("Digits"),
              reset: (0, o.NC)("Reset Call/Reset Put"),
              callputspread: (0, o.NC)("Call Spread/Put Spread"),
              highlowticks: (0, o.NC)("High/Low Ticks"),
              runs: (0, o.NC)("Only Ups/Only Downs"),
              multiplier: (0, o.NC)("Multipliers"),
              accumulator: (0, o.NC)("Accumulators"),
            },
            BARRIER_CATEGORIES: {
              euro_atm: ["callput", "callputequal"],
              euro_non_atm: ["endsinout", "higherlower", "callputspread"],
              american: [
                "staysinout",
                "touchnotouch",
                "highlowticks",
                "runs",
                "multiplier",
              ],
              non_financial: [
                "digits",
                "overunder",
                "evenodd",
                "matchesdiffers",
              ],
              asian: ["asians"],
              reset: ["reset"],
              lookback: ["lookback"],
              accumulator: ["accumulator"],
            },
            DEFAULT_DURATION_DROPDOWN_OPTIONS: [
              [(0, o.NC)("Ticks"), "t"],
              [(0, o.NC)("Seconds"), "s"],
              [(0, o.NC)("Minutes"), "m"],
              [(0, o.NC)("Hours"), "h"],
              [(0, o.NC)("Days"), "d"],
            ],
            BARRIER_LABELS: [
              (0, o.NC)("High barrier"),
              (0, o.NC)("Low barrier"),
            ],
            ABSOLUTE_BARRIER_DROPDOWN_OPTION: [
              [(0, o.NC)("Absolute"), "absolute"],
            ],
            NOT_AVAILABLE_DROPDOWN_OPTIONS: [
              [(0, o.NC)("Not available"), "na"],
            ],
            NOT_AVAILABLE_DURATIONS: [
              { display: (0, o.NC)("Not available"), unit: "na", min: 0 },
            ],
            BARRIER_TRADE_TYPES: [
              "higherlower",
              "touchnotouch",
              "endsinout",
              "staysinout",
              "callputspread",
            ],
            PREDICTION_TRADE_TYPES: [
              "matchesdiffers",
              "overunder",
              "highlowticks",
            ],
            DIGIT_CATEGORIES: ["digits", "highlowticks"],
            INDEPEDENT_BLOCKS: [
              "block_holder",
              "tick_analysis",
              "loader",
              "procedures_defreturn",
              "procedures_defnoreturn",
            ],
            bbResult: [
              [(0, o.NC)("upper"), "1"],
              [(0, o.NC)("middle"), "0"],
              [(0, o.NC)("lower"), "2"],
            ],
            macdFields: [
              [(0, o.NC)("Histogram"), "0"],
              [(0, o.NC)("MACD"), "1"],
              [(0, o.NC)("Signal"), "2"],
            ],
            GOOGLE_DRIVE: {
              SCOPE: "https://www.googleapis.com/auth/drive.file",
              DISCOVERY_DOCS:
                "https://www.googleapis.com/discovery/v1/apis/drive/v3/rest",
            },
            workspaces: {
              flyoutWorkspacesStartScale: 0.7,
              mainWorkspaceStartScale: 0.9,
              previewWorkspaceStartScale: 0.6,
              indentWorkspace: { x: 0, y: 60 },
            },
            strategies: {
              martingale: {
                index: 0,
                label: (0, o.NC)("Martingale"),
                description: (0, o.NC)(
                  "The Martingale Strategy is a classic trading technique that has been used for more than a hundred years, popularised by the French mathematician Paul Pierre Levy in the 18th century."
                ),
              },
              dalembert: {
                index: 1,
                label: (0, o.NC)("D'Alembert"),
                description: (0, o.NC)(
                  "The concept of the D’Alembert Strategy is said to be similar to the Martingale Strategy where you will increase your contract size after a loss. With the D’Alembert Strategy, you will also decrease your contract size after a successful trade."
                ),
              },
              oscars_grind: {
                index: 2,
                label: (0, o.NC)("Oscar's Grind"),
                description: (0, o.NC)(
                  "The Oscar's Grind Strategy is a low-risk positive progression strategy that first appeared in 1965. By using this strategy, the size of your contract will increase after successful trades, but remains unchanged after unsuccessful trades."
                ),
              },
            },
            default_file_name: (0, o.NC)("Untitled Bot"),
            DISABLED_SYMBOLS: [
              "frxGBPNOK",
              "frxUSDNOK",
              "frxUSDNEK",
              "frxUSDSEK",
            ],
            DISABLED_SUBMARKETS: ["energy"],
            QUICK_STRATEGY: {
              DISABLED: {
                SYMBOLS: ["1HZ150V", "1HZ250V"],
                SUBMARKETS: ["crash_index", "non_stable_coin", "step_index"],
                BARRIER_TRADE_TYPES: [
                  "higherlower",
                  "touchnotouch",
                  "endsinout",
                  "staysinout",
                  "callputspread",
                  "accumulator",
                ],
                PREDICTION_TRADE_TYPES: ["highlowticks"],
              },
              DEFAULT: {
                symbol: "1HZ100V",
                tradetype: "callput",
                durationtype: "t",
                size: 1,
                unit: 1,
                prediction: 0,
              },
            },
          });
      },
      87920: function (e, t, i) {
        "use strict";
        i.d(t, {
          Jr: () => s.Jr,
          Rg: () => r.R,
          ZB: () => s.ZB,
          u: () => s.u,
          v9: () => s.v9,
          vc: () => o.v,
        });
        var o = i(47962),
          s = i(51434),
          r = i(30810);
      },
      51434: function (e, t, i) {
        "use strict";
        i.d(t, { Jr: () => o, ZB: () => l, u: () => n, v9: () => c });
        let o = [
          "InsufficientBalance",
          "CustomLimitsReached",
          "OfferingsValidationError",
          "InvalidCurrency",
          "ContractBuyValidationError",
          "NotDefaultCurrency",
          "PleaseAuthenticate",
          "FinancialAssessmentRequired",
          "PositiveIntegerExpected",
          "OptionError",
          "IncorrectPayoutDecimals",
          "IncorrectStakeDecimals",
          "NoMFProfessionalClient",
          "AuthorizationRequired",
          "InvalidToken",
          "DailyLossLimitExceeded",
          "InputValidationFailed",
          "ClientUnwelcome",
          "PriceMoved",
        ];
        var s,
          r,
          a,
          n =
            (((s = {}).ERROR = "error"),
            (s.NOTIFY = "notify"),
            (s.SUCCESS = "success"),
            s),
          l =
            (((r = {}).RECOVERABLE_ERRORS = "recoverable_errors"),
            (r.UNRECOVERABLE_ERRORS = "unrecoverable_errors"),
            r),
          c =
            (((a = {}).LOAD_BLOCK = "load_block"),
            (a.PURCHASE = "purchase"),
            (a.SELL = "sell"),
            (a.NOT_OFFERED = "not_offered"),
            (a.PROFIT = "profit"),
            (a.LOST = "lost"),
            (a.WELCOME_BACK = "welcome_back"),
            (a.WELCOME = "welcome"),
            a);
      },
      30810: function (e, t, i) {
        "use strict";
        i.d(t, { R: () => o });
        let o = Object.freeze({
          UNSAVED: "unsaved",
          LOCAL: "local",
          GOOGLE_DRIVE: "google drive",
        });
      },
      88199: function (e, t, i) {
        "use strict";
        i.r(t),
          i.d(t, {
            TradingTimes: () => a.tI,
            DBot: () => r.Z,
            api_base: () => a.DO,
            handleError: () => n.S3,
            extractBlocksFromXml: () => n.mT,
            getContractTypeName: () => n.ZT,
            runGroupedEvents: () => s.UR,
            timeSince: () => n.VG,
            trackAndEmitError: () => n.N_,
            convertStrategyToIsDbot: () => n.Xt,
            observer: () => n.Pi,
            MessageTypes: () => o.u,
            ApiHelpers: () => a.ST,
            removeErrorHandlingEventListener: () => n.GZ,
            config: () => o.vc,
            ActiveSymbols: () => a.E9,
            save_types: () => o.Rg,
            unrecoverable_errors: () => o.Jr,
            updateWorkspaceName: () => s.Hh,
            runIrreversibleEvents: () => s.$9,
            LogTypes: () => o.v9,
            removeExistingWorkspace: () => n.lY,
            ContractsFor: () => a.HP,
            NetworkMonitor: () => a.YS,
            initErrorHandlingListener: () => n.tZ,
            importExternal: () => n.Vc,
            ServerTime: () => a.Xc,
            save: () => s.a1,
            saveWorkspaceToRecent: () => n.l5,
            createError: () => n.Tr,
            setColors: () => n.Ow,
            load: () => s.zD,
            sortBlockChild: () => n.X6,
            ErrorTypes: () => o.ZB,
            scrollWorkspace: () => s.yW,
            compareXml: () => n.dY,
            onWorkspaceResize: () => n.N0,
            pipe: () => n.zG,
            getSavedWorkspaces: () => n.WN,
          });
        var o = i(87920),
          s = i(2776),
          r = i(94120),
          a = i(5046),
          n = i(94576);
      },
      63999: function (e, t, i) {
        "use strict";
        i.d(t, { Gh: () => n, QT: () => l, wd: () => a });
        var o = i(5046),
          s = i(85872);
        let r = {
            amount: void 0,
            basis: "stake",
            contract_type: "ACCU",
            currency: void 0,
            symbol: void 0,
            growth_rate: void 0,
            proposal: 1,
            subscribe: 1,
          },
          a = async (e) => {
            if (e && !e.is_bot_running) {
              var t;
              await (null === o.DO || void 0 === o.DO
                ? void 0
                : null === (t = o.DO.api) || void 0 === t
                ? void 0
                : t.send({ forget_all: "proposal" })),
                (e.subscription_id_for_accumulators = null),
                (e.is_proposal_requested_for_accumulators = !1),
                (window.Blockly.accumulators_request = {});
            }
          },
          n = (e) => {
            var t, i, o;
            let a = null == e ? void 0 : e.getTopParent(),
              n =
                null == a
                  ? void 0
                  : a.getChildByType("trade_definition_market"),
              l = null == n ? void 0 : n.getFieldValue("SYMBOL_LIST"),
              c = s.Z.instance.client.currency,
              d =
                (null == e ? void 0 : e.getFieldValue("GROWTHRATE_LIST")) ||
                0.01,
              u =
                (null == e
                  ? void 0
                  : null === (o = e.childBlocks_) || void 0 === o
                  ? void 0
                  : null === (i = o[0]) || void 0 === i
                  ? void 0
                  : null === (t = i.getField("NUM")) || void 0 === t
                  ? void 0
                  : t.getValue()) || 0,
              h = { ...r, amount: u, currency: c, symbol: l, growth_rate: d };
            window.Blockly.accumulators_request = h;
          },
          l = (e, t) => {
            let {
                amount: i,
                currency: o,
                symbol: s,
                growth_rate: a,
                limit_order: n,
              } = e,
              { take_profit: l } = n,
              c = {
                ...r,
                amount: i,
                currency: o,
                symbol: s,
                growth_rate: a,
                subscribe: void 0,
                limit_order: { take_profit: l },
              };
            return null == t
              ? void 0
              : t
                  .send(c)
                  .then((e) => (e.error ? Promise.reject(e.error) : e))
                  .catch((e) => {
                    throw e;
                  });
          };
      },
      85872: function (e, t, i) {
        "use strict";
        i.d(t, { Z: () => l });
        var o = i(27412),
          s = i(68949),
          r = i(83241);
        class a {
          constructor() {
            (0, o._)(this, "handleFileChange", () => {
              throw Error("handleFileChange has not been implemented.");
            }),
              (0, o._)(this, "toggleStrategyModal", () => {
                throw Error("handleFileChange has not been implemented.");
              });
          }
        }
        class n extends a {
          static setInstance(e) {
            return (this.singleton = new n(e)), this.instance;
          }
          static get instance() {
            return this.singleton;
          }
          constructor(e) {
            super(),
              (this.is_mobile = e.is_mobile || !1),
              (this.is_dark_mode_on = e.is_dark_mode_on || !1),
              (this.client = e.client),
              (this.dashboard = e.dashboard),
              (this.flyout = e.flyout),
              (this.toolbar = e.toolbar),
              (this.toolbox = e.toolbox),
              (this.save_modal = e.save_modal),
              (this.load_modal = e.load_modal),
              (this.setContractUpdateConfig = e.setContractUpdateConfig),
              (this.toggleStrategyModal = e.toggleStrategyModal),
              (this.handleFileChange = e.handleFileChange),
              (this.setLoading = e.setLoading),
              (0, s.U5)(
                () => this.client.loginid,
                () => r.D.createNewInstance(this.client.loginid)
              );
          }
        }
        (0, o._)(n, "singleton", null);
        let l = n;
      },
      94120: function (e, t, i) {
        "use strict";
        let o, s, r;
        i.d(t, { Z: () => tu });
        var a = i(27412),
          n = i(87920),
          l = i(47962),
          c = i(83241),
          d = i(13604),
          u = i(66175);
        let h = (function () {
          let e, t, i;
          function o(e, t) {
            return null != t && e instanceof t;
          }
          try {
            e = Map;
          } catch (t) {
            e = function () {};
          }
          try {
            t = Set;
          } catch (e) {
            t = function () {};
          }
          try {
            i = Promise;
          } catch (e) {
            i = function () {};
          }
          function s(r, n, l, c, d) {
            "object" == typeof n &&
              ((l = n.depth),
              (c = n.prototype),
              (d = n.includeNonEnumerable),
              (n = n.circular));
            let u = [],
              h = [],
              p = "undefined" != typeof Buffer;
            return (
              void 0 === n && (n = !0),
              void 0 === l && (l = 1 / 0),
              (function r(l, _) {
                let m, g;
                if (null === l) return null;
                if (0 === _ || "object" != typeof l) return l;
                if (o(l, e)) m = new e();
                else if (o(l, t)) m = new t();
                else if (o(l, i))
                  m = new i(function (e, t) {
                    l.then(
                      function (t) {
                        e(r(t, _ - 1));
                      },
                      function (e) {
                        t(r(e, _ - 1));
                      }
                    );
                  });
                else if (s.__isArray(l)) m = [];
                else if (s.__isRegExp(l))
                  (m = new RegExp(l.source, a(l))),
                    l.lastIndex && (m.lastIndex = l.lastIndex);
                else if (s.__isDate(l)) m = new Date(l.getTime());
                else {
                  if (p && Buffer.isBuffer(l))
                    return (
                      Buffer.from
                        ? (m = Buffer.from(l))
                        : ((m = new Buffer(l.length)), l.copy(m)),
                      m
                    );
                  o(l, Error)
                    ? (m = Object.create(l))
                    : void 0 === c
                    ? (m = Object.create(Object.getPrototypeOf(l)))
                    : (m = Object.create(c));
                }
                if (n) {
                  let e = u.indexOf(l);
                  if (-1 != e) return h[e];
                  u.push(l), h.push(m);
                }
                for (var y in (o(l, e) &&
                  l.forEach(function (e, t) {
                    let i = r(t, _ - 1),
                      o = r(e, _ - 1);
                    m.set(i, o);
                  }),
                o(l, t) &&
                  l.forEach(function (e) {
                    let t = r(e, _ - 1);
                    m.add(t);
                  }),
                l)) {
                  if (Object.getOwnPropertyDescriptor(l, y)) {
                    if (0 > Object.keys(l).indexOf(y)) continue;
                    m[y] = r(l[y], _ - 1);
                  }
                  try {
                    let e = Object.getOwnPropertyDescriptor(l, y);
                    if ("undefined" === e.set) continue;
                    m[y] = r(l[y], _ - 1);
                  } catch (e) {
                    if (e instanceof TypeError || e instanceof ReferenceError)
                      continue;
                  }
                }
                if (Object.getOwnPropertySymbols) {
                  let e = Object.getOwnPropertySymbols(l);
                  for (var y = 0; y < e.length; y++) {
                    let t = e[y];
                    var v = Object.getOwnPropertyDescriptor(l, t);
                    (!v || v.enumerable || d) &&
                      ((m[t] = r(l[t], _ - 1)), Object.defineProperty(m, t, v));
                  }
                }
                if (d) {
                  let e = Object.getOwnPropertyNames(l);
                  for (var y = 0; y < e.length; y++) {
                    let t = e[y];
                    var v = Object.getOwnPropertyDescriptor(l, t);
                    (!v || !v.enumerable) &&
                      ((m[t] = r(l[t], _ - 1)), Object.defineProperty(m, t, v));
                  }
                }
                return m;
              })(r, l)
            );
          }
          function r(e) {
            return Object.prototype.toString.call(e);
          }
          function a(e) {
            let t = "";
            return (
              e.global && (t += "g"),
              e.ignoreCase && (t += "i"),
              e.multiline && (t += "m"),
              t
            );
          }
          return (
            (s.clonePrototype = function (e) {
              if (null === e) return null;
              let t = function () {};
              return (t.prototype = e), new t();
            }),
            (s.__objToStr = r),
            (s.__isDate = function (e) {
              return "object" == typeof e && "[object Date]" === r(e);
            }),
            (s.__isArray = function (e) {
              return "object" == typeof e && "[object Array]" === r(e);
            }),
            (s.__isRegExp = function (e) {
              return "object" == typeof e && "[object RegExp]" === r(e);
            }),
            (s.__getRegExpFlags = a),
            s
          );
        })();
        var p = i(88203),
          _ = i.n(p),
          m = i(51434),
          g = i(65464),
          y = i(71526),
          v = i(22598),
          f = i(48059),
          b = i(50043),
          w = i(39338);
        let k = (e) => Number.isFinite(e) && e > 0,
          C = (e) => k(e) && Number.isInteger(e),
          T = (e, t) => {
            if (!C(e)) throw (0, b.T)("PositiveIntegerExpected", t);
            return e;
          },
          N = (e) => {
            let { symbol: t, contractTypes: i } = e;
            if (!t)
              throw (0, b.T)(
                "OptionError",
                (0, f.NC)("Underlying market is not selected")
              );
            if (!i[0])
              throw (0, b.T)(
                "OptionError",
                (0, f.NC)("Contract type is not selected")
              );
          },
          S = (e) => {
            let [t, i] = e;
            if (!t) throw (0, b.T)("LoginError", (0, f.NC)("Please login"));
            return N(i), e;
          },
          x = (e) =>
            e instanceof Object &&
            ["open", "high", "low", "close"].every((t) => k(e[t])) &&
            C(e.epoch),
          E = (e) => {
            if (!x(e))
              throw (0, b.T)(
                "CandleExpected",
                (0, f.NC)("Given candle is not valid")
              );
            return e;
          },
          D = (e) => {
            if (!(e instanceof Array) || !e.every((e) => x(e)))
              throw (0, b.T)(
                "CandleListExpected",
                (0, f.NC)("Given candle list is not valid")
              );
            return e;
          },
          O = "BEFORE_PURCHASE",
          A = "DURING_PURCHASE",
          I = "PROPOSALS_READY",
          L = "CLEAR_PROPOSALS",
          R = "PURCHASE_SUCCESSFUL",
          B = "OPEN_CONTRACT",
          P = "SELL",
          j = "START",
          U = "STOP",
          M = "NEW_TICK",
          F = (e) => {
            let { dispatch: t, getState: i, data: o, scope: s } = e,
              { scope: r } = i();
            r === s && t(o);
          },
          G = () => (e, t) =>
            F({ dispatch: e, getState: t, data: { type: j }, scope: U }),
          H = () => ({ type: I }),
          V = () => ({ type: L }),
          W = (e) => F({ ...e, scope: O }),
          Y = (e) => {
            let { getState: t } = e,
              { proposalsReady: i } = t();
            i && W(e), F({ ...e, scope: O });
          },
          $ = () => (e, t) =>
            Y({ dispatch: e, getState: t, data: { type: R } }),
          q = () => (e, t) => {
            let { scope: i } = t();
            i === A && e({ type: B }),
              Y({ dispatch: e, getState: t, data: { type: B } });
          },
          z = () => (e, t) =>
            F({ dispatch: e, getState: t, data: { type: P }, scope: A }),
          K = { scope: U, proposalsReady: !1 },
          X = function () {
            let e =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : K,
              t = arguments.length > 1 ? arguments[1] : void 0;
            switch (t.type) {
              case j:
                return { scope: O, proposalsReady: e.proposalsReady };
              case I:
                return { ...e, proposalsReady: !0 };
              case L:
                return { ...e, proposalsReady: !1 };
              case R:
                return {
                  scope: A,
                  openContract: !1,
                  proposalsReady: e.proposalsReady,
                };
              case B:
                return {
                  scope: A,
                  openContract: !0,
                  proposalsReady: e.proposalsReady,
                };
              case P:
                return { scope: U, proposalsReady: e.proposalsReady };
              case M:
                return { ...e, newTick: t.payload };
              default:
                return e;
            }
          };
        var Z = i(85872),
          J = i(21796);
        let Q = "",
          ee = (e) =>
            class extends e {
              observeBalance() {
                if (!c.D.api) return;
                let e = c.D.api.onMessage().subscribe((e) => {
                  let { data: t } = e;
                  if (
                    (null == t ? void 0 : t.msg_type) === "balance" &&
                    (null == t ? void 0 : t.balance)
                  ) {
                    let {
                      balance: { balance: e, currency: i },
                    } = t;
                    (Q = (0, u.drH)(e, i)),
                      this.accountInfo &&
                        (0, J.um)({
                          accountID: this.accountInfo.loginid,
                          balance: Q,
                        });
                  }
                });
                c.D.pushSubscription(e);
              }
              getBalance(e) {
                let { client: t } = Z.Z.instance,
                  i = (t && t.balance) || 0;
                return (Q = (0, u.drH)(i, t.currency, !1)), "STR" === e ? Q : i;
              }
            },
          et = (e) =>
            class extends e {
              observeOpenContract() {
                if (!c.D.api) return;
                let e = c.D.api.onMessage().subscribe((e) => {
                  let { data: t } = e;
                  if ("proposal_open_contract" === t.msg_type) {
                    let e = t.proposal_open_contract;
                    if (
                      !e ||
                      !this.expectedContractId(
                        null == e ? void 0 : e.contract_id
                      )
                    )
                      return;
                    this.setContractFlags(e),
                      (this.data.contract = e),
                      (0, J.LJ)({ accountID: c.D.account_info.loginid, ...e }),
                      this.isSold
                        ? ((this.contractId = ""),
                          clearTimeout(this.transaction_recovery_timeout),
                          this.updateTotals(e),
                          (0, J.x_)({
                            id: "contract.sold",
                            data: e.transaction_ids.sell,
                            contract: e,
                          }),
                          this.afterPromise && this.afterPromise(),
                          this.store.dispatch(z()))
                        : this.store.dispatch(q());
                  }
                });
                c.D.pushSubscription(e);
              }
              waitForAfter() {
                return new Promise((e) => {
                  this.afterPromise = e;
                });
              }
              setContractFlags(e) {
                let {
                  is_expired: t,
                  is_valid_to_sell: i,
                  is_sold: o,
                  entry_tick: s,
                } = e;
                (this.isSold = !!o),
                  (this.isSellAvailable = !this.isSold && !!i),
                  (this.isExpired = !!t),
                  (this.hasEntryTick = !!s);
              }
              expectedContractId(e) {
                return this.contractId && e === this.contractId;
              }
              getSellPrice() {
                let {
                  bid_price: e,
                  buy_price: t,
                  currency: i,
                } = this.data.contract;
                return (0, u.bfN)(Number(e) - Number(t), i);
              }
            },
          ei = (e) =>
            class extends e {
              makeProposals(e) {
                this.isNewTradeOption(e) &&
                  (this.regeneratePurchaseReference(),
                  (this.trade_option = e),
                  (this.proposal_templates = (0, w.pH)(
                    e,
                    this.getPurchaseReference()
                  )),
                  this.renewProposalsOnPurchase());
              }
              selectProposal(e) {
                let { proposals: t } = this.data;
                if (0 === t.length)
                  throw Error((0, f.NC)("Proposals are not ready"));
                let i = t.find((t) => {
                  if (
                    t.contract_type === e &&
                    t.purchase_reference === this.getPurchaseReference()
                  ) {
                    if (t.error) throw t.error;
                    return t;
                  }
                  return !1;
                });
                if (!i)
                  throw Error((0, f.NC)("Selected proposal does not exist"));
                return { id: i.id, askPrice: i.ask_price };
              }
              renewProposalsOnPurchase() {
                (this.data.proposals = []),
                  this.store.dispatch(V()),
                  this.requestProposals();
              }
              requestProposals() {
                let e = !1;
                Promise.all(
                  this.proposal_templates.map((t) => {
                    (0, w.l6)(() => c.D.api.send(t)).catch((t) => {
                      var i;
                      return (
                        (null == t
                          ? void 0
                          : null === (i = t.error) || void 0 === i
                          ? void 0
                          : i.code) === "ContractBuyValidationError"
                          ? this.data.proposals.push({
                              ...t.error.echo_req,
                              ...t.echo_req.passthrough,
                              error: t,
                            })
                          : e ||
                            ((e = !0),
                            this.$scope.observer.emit("Error", t.error)),
                        null
                      );
                    });
                  })
                );
              }
              observeProposals() {
                if (!c.D.api) return;
                let e = c.D.api.onMessage().subscribe((e) => {
                  if ("proposal" === e.data.msg_type) {
                    let { passthrough: t, proposal: i } = e.data;
                    i &&
                      -1 ===
                        this.data.proposals.findIndex((e) => e.id === i.id) &&
                      (this.data.proposals.push({ ...i, ...t }),
                      this.checkProposalReady());
                  }
                });
                c.D.pushSubscription(e);
              }
              checkProposalReady() {
                let { proposals: e } = this.data;
                e.length > 0 &&
                  this.proposal_templates &&
                  this.proposal_templates.every(
                    (t) =>
                      -1 !==
                      e.findIndex(
                        (e) =>
                          e.purchase_reference ===
                            t.passthrough.purchase_reference &&
                          e.contract_type === t.contract_type
                      )
                  ) &&
                  this.startPromise.then(() => this.store.dispatch(H()));
              }
              isNewTradeOption(e) {
                return this.trade_option
                  ? [
                      "amount",
                      "barrierOffset",
                      "basis",
                      "duration",
                      "duration_unit",
                      "prediction",
                      "secondBarrierOffset",
                      "symbol",
                    ].some((t) => this.trade_option[t] !== e[t])
                  : ((this.trade_option = e), !0);
              }
            },
          eo = 0,
          es = (e) =>
            class extends e {
              purchase(e) {
                if (this.store.getState().scope !== O) return Promise.resolve();
                let t = (t) => {
                  let { buy: i } = t;
                  (0, J.x_)({
                    id: "contract.purchase_received",
                    data: i.transaction_id,
                    buy: i,
                  }),
                    (this.contractId = i.contract_id),
                    this.store.dispatch($()),
                    this.is_proposal_subscription_required &&
                      this.renewProposalsOnPurchase(),
                    (eo = 0),
                    (0, J.cM)(m.v9.PURCHASE, {
                      longcode: i.longcode,
                      transaction_id: i.transaction_id,
                    }),
                    (0, J.um)({
                      accountID: this.accountInfo.loginid,
                      totalRuns: this.updateAndReturnTotalRuns(),
                      transaction_ids: { buy: i.transaction_id },
                      contract_type: e,
                      buy_price: i.buy_price,
                    });
                };
                if (this.is_proposal_subscription_required) {
                  let { id: i, askPrice: o } = this.selectProposal(e),
                    s = () => c.D.api.send({ buy: i, price: o });
                  return ((this.isSold = !1),
                  (0, J.x_)({ id: "contract.purchase_sent", data: o }),
                  this.options.timeMachineEnabled)
                    ? (0, w.Kn)(
                        s,
                        (e, t) => {
                          "DisconnectError" !== e
                            ? this.renewProposalsOnPurchase()
                            : this.clearProposals();
                          let i = this.store.subscribe(() => {
                            let { scope: e, proposalsReady: o } =
                              this.store.getState();
                            e === O &&
                              o &&
                              (t().then(() =>
                                this.observer.emit("REVERT", "before")
                              ),
                              i());
                          });
                        },
                        ["PriceMoved", "InvalidContractProposal"],
                        eo++
                      ).then(t)
                    : (0, w.l6)(s).then(t);
                }
                let i = (0, w.nD)(e, this.tradeOptions),
                  o = () => c.D.api.send(i);
                return ((this.isSold = !1),
                (0, J.x_)({
                  id: "contract.purchase_sent",
                  data: this.tradeOptions.amount,
                }),
                this.options.timeMachineEnabled)
                  ? (0, w.Kn)(
                      o,
                      (e, t) => {
                        "DisconnectError" === e && this.clearProposals();
                        let i = this.store.subscribe(() => {
                          let { scope: e } = this.store.getState();
                          e === O &&
                            (t().then(() =>
                              this.observer.emit("REVERT", "before")
                            ),
                            i());
                        });
                      },
                      ["PriceMoved", "InvalidContractProposal"],
                      eo++
                    ).then(t)
                  : (0, w.l6)(o).then(t);
              }
              constructor(...e) {
                super(...e),
                  (0, a._)(this, "getPurchaseReference", () => o),
                  (0, a._)(this, "regeneratePurchaseReference", () => {
                    o = (0, w.Fs)();
                  });
              }
            },
          er = (e) =>
            class extends e {
              isSellAtMarketAvailable() {
                return (
                  this.contractId &&
                  !this.isSold &&
                  this.isSellAvailable &&
                  !this.isExpired
                );
              }
              sellAtMarket() {
                if ((g.P.emit("bot.sell"), this.store.getState().scope !== A))
                  return Promise.resolve();
                if (!this.isSellAtMarketAvailable())
                  return (0, J.cM)(m.v9.NOT_OFFERED), Promise.resolve();
                let e = 1;
                return new Promise((t) => {
                  let i = (i) => {
                      if (((e = 1), i)) {
                        let { sold_for: e } = i.sell;
                        (0, J.cM)(m.v9.SELL, { sold_for: e });
                      }
                      (0, J.x_)("purchase.sold"), this.waitForAfter(), t();
                    },
                    o = this.contractId,
                    s = () =>
                      (0, w.l6)(() => c.D.api.send({ sell: o, price: 0 }))
                        .then((e) => {
                          (0, w.l6)(() =>
                            c.D.api.send({
                              proposal_open_contract: 1,
                              contract_id: o,
                            })
                          ).then(() => e);
                        })
                        .catch((e) => {
                          let t = e.error;
                          if ("InvalidOfferings" === t.code)
                            return Promise.resolve();
                          let i = {
                            name: t.code,
                            message: t.message,
                            msg_type: e.msg_type,
                            error: { ...t.error },
                          };
                          return "RateLimit" === t.code
                            ? Promise.reject(i)
                            : (0, w.l6)(() =>
                                c.D.api.send({
                                  proposal_open_contract: 1,
                                  contract_id: o,
                                })
                              ).then((e) => {
                                let { proposal_open_contract: t } = e;
                                return t.is_sold
                                  ? Promise.resolve({
                                      sell: { sold_for: t.sell_price },
                                    })
                                  : Promise.reject(i);
                              });
                        }),
                    r = [
                      "NoOpenPosition",
                      "InvalidSellContractProposal",
                      "UnrecognisedRequest",
                    ];
                  return this.options.timeMachineEnabled
                    ? (0, w.Kn)(
                        s,
                        (e, t) =>
                          t().then(() =>
                            this.observer.emit("REVERT", "during")
                          ),
                        r,
                        e++
                      ).then((e) => i(e))
                    : (0, w.l6)(s, r)
                        .then((e) => i(e))
                        .catch((e) => e);
                });
              }
            };
        var ea = i(91296),
          en = i.n(ea);
        let el = (e) => e && (0 === e.length ? void 0 : e[e.length - 1]),
          ec = (e) =>
            e.times.map((t, i) => ({ epoch: +t, quote: +e.prices[i] })),
          ed = (e) =>
            class extends e {
              async watchTicks(e) {
                if (e && this.symbol !== e) {
                  this.symbol = e;
                  let { ticksService: t } = this.$scope;
                  await t.stopMonitor({ symbol: e, key: s }),
                    (s = await t.monitor({
                      symbol: e,
                      callback: (e) => {
                        this.is_proposal_subscription_required &&
                          this.checkProposalReady();
                        let { epoch: t } = e.slice(-1)[0];
                        this.store.dispatch({ type: M, payload: t });
                      },
                    }));
                }
              }
              checkTicksPromiseExists() {
                return this.$scope.ticksService.ticks_history_promise;
              }
              getTicks() {
                let e =
                  arguments.length > 0 &&
                  void 0 !== arguments[0] &&
                  arguments[0];
                return new Promise((t) => {
                  this.$scope.ticksService
                    .request({ symbol: this.symbol })
                    .then((i) => {
                      t(
                        i.map((t) =>
                          e ? t.quote.toFixed(this.getPipSize()) : t.quote
                        )
                      );
                    });
                });
              }
              getLastTick(e) {
                let t =
                  arguments.length > 1 &&
                  void 0 !== arguments[1] &&
                  arguments[1];
                return new Promise((i) =>
                  this.$scope.ticksService
                    .request({ symbol: this.symbol })
                    .then((o) => {
                      let s = e ? el(o) : el(o).quote;
                      !e && t && (s = s.toFixed(this.getPipSize())), i(s);
                    })
                    .catch((e) => {
                      "MarketIsClosed" === e.code &&
                        (g.P.emit("Error", e), i(e.code));
                    })
                );
              }
              getLastDigit() {
                return new Promise((e) =>
                  this.getLastTick(!1, !0).then((t) => e((0, w.VM)(t)))
                );
              }
              getLastDigitList() {
                return new Promise((e) =>
                  this.getTicks().then((t) => e(this.getLastDigitsFromList(t)))
                );
              }
              getLastDigitsFromList(e) {
                return e.map((e) => (0, w.VM)(e.toFixed(this.getPipSize())));
              }
              checkDirection(e) {
                return new Promise((t) =>
                  this.$scope.ticksService
                    .request({ symbol: this.symbol })
                    .then((i) => t((0, w.Mg)(i) === e))
                );
              }
              getOhlc(e) {
                let {
                  granularity: t = this.options.candleInterval || 60,
                  field: i,
                } = e || {};
                return new Promise((e) =>
                  this.$scope.ticksService
                    .request({ symbol: this.symbol, granularity: t })
                    .then((t) => e(i ? t.map((e) => e[i]) : t))
                );
              }
              getOhlcFromEnd(e) {
                let { index: t = 1 } = e || {},
                  i = T(
                    Number(t),
                    (0, f.NC)("Index must be a positive integer")
                  );
                return new Promise((t) =>
                  this.getOhlc(e).then((e) => t(e.slice(-i)[0]))
                );
              }
              getPipSize() {
                return this.$scope.ticksService.pipSizes[this.symbol];
              }
              async requestAccumulatorStats() {
                var e, t, i, o, s, r;
                let a = this.subscription_id_for_accumulators,
                  n = this.is_proposal_requested_for_accumulators,
                  l = {
                    ...window.Blockly.accumulators_request,
                    amount:
                      null === this || void 0 === this
                        ? void 0
                        : null === (e = this.tradeOptions) || void 0 === e
                        ? void 0
                        : e.amount,
                    basis:
                      null === this || void 0 === this
                        ? void 0
                        : null === (t = this.tradeOptions) || void 0 === t
                        ? void 0
                        : t.basis,
                    contract_type: "ACCU",
                    currency:
                      null === this || void 0 === this
                        ? void 0
                        : null === (i = this.tradeOptions) || void 0 === i
                        ? void 0
                        : i.currency,
                    growth_rate:
                      null === this || void 0 === this
                        ? void 0
                        : null === (o = this.tradeOptions) || void 0 === o
                        ? void 0
                        : o.growth_rate,
                    proposal: 1,
                    subscribe: 1,
                    symbol:
                      null === this || void 0 === this
                        ? void 0
                        : null === (s = this.tradeOptions) || void 0 === s
                        ? void 0
                        : s.symbol,
                  };
                a ||
                  n ||
                  ((this.is_proposal_requested_for_accumulators = !0),
                  l &&
                    (await (null === c.D || void 0 === c.D
                      ? void 0
                      : null === (r = c.D.api) || void 0 === r
                      ? void 0
                      : r.send(l))));
              }
              async handleOnMessageForAccumulators() {
                let e = [];
                return new Promise((t) => {
                  let i = c.D.api.onMessage().subscribe((i) => {
                    let { data: o } = i;
                    if ("proposal" === o.msg_type)
                      try {
                        (this.subscription_id_for_accumulators =
                          o.subscription.id),
                          (e = [
                            ...(
                              o.proposal.contract_details.ticks_stayed_in || []
                            )
                              .flat()
                              .reverse(),
                            ...e,
                          ]).length > 0 && t(e);
                      } catch (e) {
                        g.P.emit(
                          "Unexpected message type or no proposal found:",
                          e
                        );
                      }
                  });
                  c.D.pushSubscription(i);
                });
              }
              async fetchStatsForAccumulators() {
                try {
                  return (
                    en()(() => this.requestAccumulatorStats(), 300)(),
                    await this.handleOnMessageForAccumulators()
                  );
                } catch (e) {
                  throw (g.P.emit("Error in subscription promise:", e), e);
                } finally {
                  var e;
                  await (null === c.D || void 0 === c.D
                    ? void 0
                    : null === (e = c.D.api) || void 0 === e
                    ? void 0
                    : e.send({ forget_all: "proposal" })),
                    (this.is_proposal_requested_for_accumulators = !1),
                    (this.subscription_id_for_accumulators = null);
                }
              }
              async getCurrentStat() {
                try {
                  let e = await this.fetchStatsForAccumulators();
                  return null == e ? void 0 : e[0];
                } catch (e) {
                  g.P.emit("Error fetching current stat:", e);
                }
              }
              async getStatList() {
                try {
                  let e = await this.fetchStatsForAccumulators();
                  return null == e ? void 0 : e.slice(0, 100);
                } catch (e) {
                  g.P.emit("Error fetching current stat:", e);
                }
              }
              async getDelayTickValue(e) {
                return new Promise((t, i) => {
                  try {
                    let i = [],
                      o = this.symbol,
                      s = () => {
                        this.$scope.ticksService.stopMonitor({
                          symbol: o,
                          key: "",
                        }),
                          t(i),
                          (i.length = 0);
                      },
                      r = (t) => {
                        i.push(t), i.length === e && s();
                      };
                    0 >= Number(e) && s(),
                      this.$scope.ticksService.monitor({
                        symbol: o,
                        callback: (e) => r(e),
                      });
                  } catch (e) {
                    i(Error(`Failed to start tick monitoring: ${e.message}`));
                  }
                });
              }
            },
          eu = {
            totalProfit: 0,
            totalWins: 0,
            totalLosses: 0,
            totalStake: 0,
            totalPayout: 0,
            totalRuns: 0,
          },
          eh = {},
          ep = (e) =>
            class extends e {
              clearStatistics() {
                if (
                  ((this.sessionRuns = 0),
                  (this.sessionProfit = 0),
                  !this.accountInfo)
                )
                  return;
                let { loginid: e } = this.accountInfo;
                eh[e] = { ...eu };
              }
              updateTotals(e) {
                let { sell_price: t, buy_price: i, currency: o } = e,
                  s = (0, u.bfN)(Number(t) - Number(i), o),
                  r = s > 0,
                  a = this.getAccountStat();
                (a.totalWins += +!!r),
                  (a.totalLosses += +!r),
                  (this.sessionProfit = (0, u.bfN)(
                    Number(this.sessionProfit) + Number(s),
                    o
                  )),
                  (a.totalProfit = (0, u.bfN)(
                    Number(a.totalProfit) + Number(s),
                    o
                  )),
                  (a.totalStake = (0, u.bfN)(
                    Number(a.totalStake) + Number(i),
                    o
                  )),
                  (a.totalPayout = (0, u.bfN)(
                    Number(a.totalPayout) + Number(t),
                    o
                  )),
                  (0, J.um)({
                    profit: s,
                    contract: e,
                    accountID: this.accountInfo.loginid,
                    totalProfit: a.totalProfit,
                    totalWins: a.totalWins,
                    totalLosses: a.totalLosses,
                    totalStake: a.totalStake,
                    totalPayout: a.totalPayout,
                  }),
                  (0, J.cM)(r ? m.v9.PROFIT : m.v9.LOST, {
                    currency: o,
                    profit: s,
                  });
              }
              updateAndReturnTotalRuns() {
                this.sessionRuns++;
                let e = this.getAccountStat();
                return ++e.totalRuns;
              }
              getTotalRuns() {
                return this.getAccountStat().totalRuns;
              }
              getTotalProfit(e, t) {
                let i = this.getAccountStat();
                return e && 0 !== i.totalProfit
                  ? (0, u.bfN)(+i.totalProfit, t)
                  : +i.totalProfit;
              }
              checkLimits(e) {
                if (!e.limitations) return;
                let {
                  limitations: { maxLoss: t, maxTrades: i },
                } = e;
                if (t && i) {
                  if (this.sessionRuns >= i)
                    throw (0, b.T)(
                      "CustomLimitsReached",
                      (0, f.NC)("Maximum number of trades reached")
                    );
                  if (this.sessionProfit <= -t)
                    throw (0, b.T)(
                      "CustomLimitsReached",
                      (0, f.NC)("Maximum loss amount reached")
                    );
                }
              }
              validateTradeOptions(e) {
                let t = e.take_profit,
                  i = e.stop_loss;
                return (
                  t && (e.limit_order.take_profit = t),
                  i && (e.limit_order.stop_loss = i),
                  e
                );
              }
              getAccountStat() {
                let { loginid: e } = this.accountInfo;
                return e in eh || (eh[e] = { ...eu }), eh[e];
              }
              constructor() {
                super(),
                  (this.sessionRuns = 0),
                  (this.sessionProfit = 0),
                  g.P.register(
                    "statistics.clear",
                    this.clearStatistics.bind(this)
                  );
              }
            },
          e_ = (e) =>
            eg({
              store: e,
              stopScope: A,
              passScope: O,
              passFlag: "proposalsReady",
            }),
          em = (e) =>
            eg({
              store: e,
              stopScope: U,
              passScope: A,
              passFlag: "openContract",
            }),
          eg = (e) => {
            let { store: t, stopScope: i, passScope: o, passFlag: s } = e;
            return t.getState().scope === i
              ? Promise.resolve(!1)
              : new Promise((e) => {
                  let a = t.subscribe(() => {
                    let n = t.getState();
                    n.newTick !== r &&
                      ((r = n.newTick),
                      n.scope === o && n[s] && (a(), e(!0)),
                      n.scope === i && (a(), e(!1)));
                  });
                });
          };
        class ey extends ee(es(er(et(ei(ed(ep(class {}))))))) {
          init() {
            for (var e = arguments.length, t = Array(e), i = 0; i < e; i++)
              t[i] = arguments[i];
            let [o, s] = S(t),
              { symbol: r } = s;
            (this.initArgs = t),
              (this.options = s),
              (this.startPromise = this.loginAndGetBalance(o)),
              this.checkTicksPromiseExists() || this.watchTicks(r);
          }
          start(e) {
            if (!this.options)
              throw (0, b.T)(
                "NotInitialized",
                (0, f.NC)("Bot.init is not called")
              );
            g.P.emit("bot.running");
            let t = this.validateTradeOptions(e);
            (this.tradeOptions = { ...t, symbol: this.options.symbol }),
              this.store.dispatch(G()),
              this.checkLimits(t),
              this.makeDirectPurchaseDecision();
          }
          loginAndGetBalance(e) {
            return this.token === e
              ? Promise.resolve()
              : ((this.accountInfo = c.D.account_info),
                (this.token = c.D.token),
                new Promise((e) => {
                  let t = c.D.api.onMessage().subscribe((t) => {
                    let { data: i } = t;
                    "transaction" === i.msg_type &&
                      "sell" === i.transaction.action &&
                      (this.transaction_recovery_timeout = setTimeout(() => {
                        let { contract: e } = this.data,
                          t = e.contract_id === i.transaction.contract_id,
                          o = "open" === e.status;
                        t &&
                          o &&
                          (0, w.l6)(() => {
                            c.D.api.send({
                              proposal_open_contract: 1,
                              contract_id: e.contract_id,
                            });
                          }, ["PriceMoved"]);
                      }, 1500)),
                      e();
                  });
                  c.D.pushSubscription(t);
                }));
          }
          observe() {
            this.observeOpenContract(),
              this.observeBalance(),
              this.observeProposals();
          }
          watch(e) {
            return "before" === e ? e_(this.store) : em(this.store);
          }
          makeDirectPurchaseDecision() {
            let { has_payout_block: e, is_basis_payout: t } = (0, w.vo)();
            (this.is_proposal_subscription_required = e || t),
              this.is_proposal_subscription_required
                ? (this.makeProposals({
                    ...this.options,
                    ...this.tradeOptions,
                  }),
                  this.checkProposalReady())
                : this.store.dispatch(H());
          }
          constructor(e) {
            super(),
              (this.observer = e.observer),
              (this.$scope = e),
              this.observe(),
              (this.data = { contract: {}, proposals: [] }),
              (this.subscription_id_for_accumulators = null),
              (this.is_proposal_requested_for_accumulators = !1),
              (this.store = (0, y.MT)(X, (0, y.md)(v.I)));
          }
        }
        let ev = (e, t) =>
            t.data.proposals.find(
              (i) =>
                i.contract_type === e &&
                i.purchase_reference === t.getPurchaseReference()
            ),
          ef = (e) => e.getSellPrice(),
          eb = (e) => {
            let t = (t) => (0, w.mh)(e.data.contract)[t];
            return {
              init: function () {
                for (var t = arguments.length, i = Array(t), o = 0; o < t; o++)
                  i[o] = arguments[o];
                return e.init(...i);
              },
              start: function () {
                for (var t = arguments.length, i = Array(t), o = 0; o < t; o++)
                  i[o] = arguments[o];
                return e.start(...i);
              },
              stop: function () {
                for (var t = arguments.length, i = Array(t), o = 0; o < t; o++)
                  i[o] = arguments[o];
                return e.stop(...i);
              },
              purchase: (t) => e.purchase(t),
              getAskPrice: (t) => Number(ev(t, e).ask_price),
              getPayout: (t) => Number(ev(t, e).payout),
              getPurchaseReference: () => e.getPurchaseReference(),
              isSellAvailable: () => e.isSellAtMarketAvailable(),
              sellAtMarket: () => e.sellAtMarket(),
              getSellPrice: () => ef(e),
              isResult: (e) => t(10) === e,
              isTradeAgain: (e) => g.P.emit("bot.trade_again", e),
              readDetails: (e) => t(e - 1),
            };
          },
          ew = (e) => ({
            getDelayTickValue: function () {
              for (var t = arguments.length, i = Array(t), o = 0; o < t; o++)
                i[o] = arguments[o];
              return e.getDelayTickValue(...i);
            },
            getCurrentStat: function () {
              for (var t = arguments.length, i = Array(t), o = 0; o < t; o++)
                i[o] = arguments[o];
              return e.getCurrentStat(...i);
            },
            getStatList: function () {
              for (var t = arguments.length, i = Array(t), o = 0; o < t; o++)
                i[o] = arguments[o];
              return e.getStatList(...i);
            },
            getLastTick: function () {
              for (var t = arguments.length, i = Array(t), o = 0; o < t; o++)
                i[o] = arguments[o];
              return e.getLastTick(...i);
            },
            getLastDigit: function () {
              for (var t = arguments.length, i = Array(t), o = 0; o < t; o++)
                i[o] = arguments[o];
              return e.getLastDigit(...i);
            },
            getTicks: function () {
              for (var t = arguments.length, i = Array(t), o = 0; o < t; o++)
                i[o] = arguments[o];
              return e.getTicks(...i);
            },
            checkDirection: function () {
              for (var t = arguments.length, i = Array(t), o = 0; o < t; o++)
                i[o] = arguments[o];
              return e.checkDirection(...i);
            },
            getOhlcFromEnd: function () {
              for (var t = arguments.length, i = Array(t), o = 0; o < t; o++)
                i[o] = arguments[o];
              return e.getOhlcFromEnd(...i);
            },
            getOhlc: function () {
              for (var t = arguments.length, i = Array(t), o = 0; o < t; o++)
                i[o] = arguments[o];
              return e.getOhlc(...i);
            },
            getLastDigitList: function () {
              for (var t = arguments.length, i = Array(t), o = 0; o < t; o++)
                i[o] = arguments[o];
              return e.getLastDigitList(...i);
            },
          }),
          ek = () => ({
            isCandleBlack: (e) => E(e) && e.close < e.open,
            candleValues: (e, t) => D(e).map((e) => e[t]),
            candleField: (e, t) => E(e)[t],
          }),
          eC = (e, t) => e.map((e) => (t ? e[t] : e)),
          eT = (e, t, i) =>
            eC(e.slice(t > e.length ? 0 : e.length - t, e.length), i),
          eN = (e) => e.reduce((e, t) => e + t, 0),
          eS = (e) => e.reduce((e, t) => e + t, 0) / e.length,
          ex = (e) => {
            let t = eS(e);
            return Math.sqrt(eS(e.map((e) => (e - t) ** 2)));
          },
          eE = (e, t) => {
            let { periods: i, field: o } = t;
            if (e.length < i) throw Error("Periods longer than data length");
            return eN(eT(e, i, o)) / i;
          },
          eD = (e, t) => {
            let { periods: i, pipSize: o = 2 } = t;
            return (0, u.vPG)(e.length - i + 1).map(
              (s, r) => +eE(e.slice(r, r + i), t).toFixed(o)
            );
          },
          eO = (e, t) => {
            let {
                periods: i = 20,
                field: o,
                stdDevUp: s = 2,
                stdDevDown: r = 2,
                pipSize: a = 2,
              } = t,
              n = eT(e, i, o),
              l = eE(n, { periods: i }),
              c = ex(n),
              d = l + c * s,
              u = l - c * r;
            return [+l.toFixed(a), +d.toFixed(a), +u.toFixed(a)];
          },
          eA = (e, t) => {
            let { periods: i } = t;
            return (0, u.vPG)(e.length - i + 1).map((o, s) =>
              eO(e.slice(s, s + i), t)
            );
          },
          eI = (e, t, i) => {
            let { periods: o, field: s, pipSize: r = 2 } = t,
              a = 2 / (o + 1),
              n = eC(e, s);
            if (i) return (n[0] - i) * a + i;
            if (e.length < o) throw Error("Periods longer than data length");
            let l = eS(eC(e.slice(0, o), s));
            return +n
              .slice(o)
              .reduce((e, t) => (t - e) * a + e, l)
              .toFixed(r);
          },
          eL = (e, t) => {
            let { periods: i } = t,
              o = eI(e.slice(0, i), t);
            return e.slice(i - 1).map((e, i) => (i ? (o = eI([e], t, o)) : o));
          },
          eR = (e, t) => {
            let i = [];
            return (i.length = t - e.length), i.fill(0), [...i, ...e];
          },
          eB = (e, t) => {
            let {
                field: i,
                fastEmaPeriod: o = 12,
                slowEmaPeriod: s = 26,
                signalEmaPeriod: r = 9,
                pipSize: a = 2,
              } = t,
              n = eC(e, i),
              l = n.length,
              c = eR(eL(n, { periods: o, pipSize: 20, field: i }), l),
              d = eR(eL(n, { periods: s, pipSize: 20, field: i }), l),
              u = eR(
                d.map((e, t) => +(c[t] - e).toFixed(a)),
                l
              ),
              h = eR(
                eL(u.slice(s - 1), { periods: r, pipSize: 20, field: i }),
                l
              );
            return u
              .map((e, t) => [+(e - h[t]).toFixed(a), e, +h[t].toFixed(a)])
              .slice(s + r - 2);
          },
          eP = (e, t) => (t > e ? t - e : 0),
          ej = (e, t) => (t < e ? e - t : 0),
          eU = (e, t, i) => {
            let o;
            return (
              e.reduce((e, i, s) => {
                1 === s && (o = e);
                let r = t(o, i);
                return (o = i), r + (1 === s ? 0 : e);
              }) / i
            );
          },
          eM = (e, t, i, o) => {
            let s;
            return 1 === e.length
              ? o
              : e.reduce((e, r, a) => {
                  1 === a && (s = e);
                  let n = t(s, r);
                  return (s = r), ((1 === a ? o : e) * (i - 1) + n) / i;
                });
          },
          eF = (e, t, i) => {
            let o, s, r;
            let { periods: a, field: n } = t;
            if (e.length < a) throw Error("Periods longer than data length");
            if (e.length === a) return 0;
            let l = eC(e.slice(0, a + 1), n);
            i && "gain" in i
              ? ((o = eC(e.slice(-2), n)), (s = i.gain), (r = i.loss))
              : ((o = eC(e.slice(a, e.length), n)),
                (s = eU(l, eP, a)),
                (r = eU(l, ej, a)));
            let c = eM(o, eP, a, s),
              d = eM(o, ej, a, r);
            return (i && ((i.gain = c), (i.loss = d)), 0 === c)
              ? 0
              : 0 === d
              ? 100
              : 100 - 100 / (1 + c / d);
          },
          eG = (e, t) => {
            let { periods: i, pipSize: o = 2 } = t,
              s = {};
            return (0, u.vPG)(e.length - i).map(
              (r, a) => +eF(e.slice(0, a + i + 1), t, s).toFixed(o)
            );
          },
          eH = function (e, t, i, o) {
            for (
              var s = arguments.length, r = Array(s > 4 ? s - 4 : 0), a = 4;
              a < s;
              a++
            )
              r[a - 4] = arguments[a];
            return e(t, { pipSize: i.getPipSize(), ...o }, ...r);
          },
          eV = (e) => ({
            sma: (t, i) => eH(eE, t, e, { periods: i }),
            smaa: (t, i) => eH(eD, t, e, { periods: i }),
            ema: (t, i) => eH(eI, t, e, { periods: i }),
            emaa: (t, i) => eH(eL, t, e, { periods: i }),
            rsi: (t, i) => eH(eF, t, e, { periods: i }),
            rsia: (t, i) => eH(eG, t, e, { periods: i }),
            bb: (t, i, o) => eH(eO, t, e, i)[o],
            bba: (t, i, o) => eH(eA, t, e, i).map((e) => e[o]),
            macda: (t, i, o) => eH(eB, t, e, i).map((e) => e[o]),
          }),
          eW = (e) => ({
            notify: (e) => g.P.emit("ui.log.notify", e),
            console: (e) => {
              let { type: t, message: i } = e;
              return console[t](i);
            },
            notifyTelegram: (e, t, i) => {
              let o = () =>
                (0, J.h4)(
                  "warn",
                  (0, f.NC)("The Telegram notification could not be sent")
                );
              fetch(`https://api.telegram.org/bot${e}/sendMessage`, {
                method: "POST",
                mode: "cors",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ chat_id: t, text: i }),
              })
                .then((e) => {
                  e.ok || o();
                })
                .catch(o);
            },
            getTotalRuns: () => e.getTotalRuns(),
            getBalance: (t) => e.getBalance(t),
            getTotalProfit: (t) => e.getTotalProfit(t, e.tradeOptions.currency),
          }),
          eY = (e) => ({
            dateTimeStringToTimestamp: (e) => {
              let t;
              let i = (0, f.NC)("Invalid date/time: {{ datetime_string }}", {
                datetime_string: e,
              });
              if ("string" != typeof e) return i;
              let o = e
                  .replace(/[^0-9.:-\s]/g, "")
                  .replace(/\s+/g, " ")
                  .trim()
                  .split(" "),
                s = /^[12]\d{3}-(0[1-9]|1[0-2])-(0[1-9]|[12]\d|3[01])$/;
              if (
                (t =
                  o.length >= 2
                    ? s.test(o[0]) &&
                      /^(0[0-9]|1[0-9]|2[0-3]):([0-5][0-9])(:([0-5][0-9])?)?$/.test(
                        o[1]
                      )
                      ? `${o[0]}T${o[1]}`
                      : null
                    : 1 === o.length && s.test(o[0])
                    ? o[0]
                    : null)
              ) {
                let e = new Date(t);
                if (e instanceof Date && !isNaN(e)) return e.getTime() / 1e3;
              }
              return i;
            },
            getTime: () => parseInt(new Date().getTime() / 1e3),
            ...ek(),
            ...eW(e),
            ...eV(e),
            highlightBlock: (e) => {
              let t = window.Blockly.derivWorkspace.getBlockById(e);
              (window.Blockly.BlockSvg.prototype.highlightExecutedBlock =
                function () {
                  let e = "block--execution-highlighted";
                  window.Blockly.utils.dom.hasClass(this.svgGroup_, e) ||
                    (window.Blockly.utils.dom.addClass(this.svgGroup_, e),
                    setTimeout(() => {
                      this.svgGroup_ &&
                        window.Blockly.utils.dom.removeClass(this.svgGroup_, e);
                    }, 1505));
                }),
                t && t.highlightExecutedBlock(t);
            },
          }),
          e$ = function (e) {
            let t =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : 1;
            return new Promise(
              (i) =>
                setTimeout(() => {
                  i(), setTimeout(() => e.emit("CONTINUE"), 0);
                }, 1e3 * t),
              () => {}
            );
          },
          eq = (e) => {
            let t = new ey(e),
              { observer: i } = e;
            return {
              tradeEngine: t,
              observer: i,
              getInterface: () => ({
                ...eb(t),
                ...eY(t),
                getTicksInterface: ew(t),
                watch: function () {
                  for (
                    var e = arguments.length, i = Array(e), o = 0;
                    o < e;
                    o++
                  )
                    i[o] = arguments[o];
                  return t.watch(...i);
                },
                sleep: function () {
                  for (
                    var e = arguments.length, t = Array(e), o = 0;
                    o < e;
                    o++
                  )
                    t[o] = arguments[o];
                  return e$(i, ...t);
                },
                alert: function () {
                  for (
                    var e = arguments.length, t = Array(e), i = 0;
                    i < e;
                    i++
                  )
                    t[i] = arguments[i];
                  return alert(...t);
                },
                prompt: function () {
                  for (
                    var e = arguments.length, t = Array(e), i = 0;
                    i < e;
                    i++
                  )
                    t[i] = arguments[i];
                  return prompt(...t);
                },
                console: {
                  log() {
                    for (
                      var e = arguments.length, t = Array(e), i = 0;
                      i < e;
                      i++
                    )
                      t[i] = arguments[i];
                    console.log(new Date().toLocaleTimeString(), ...t);
                  },
                },
              }),
            };
          };
        var ez = i(35369);
        let eK = (e) => ({ epoch: +e.epoch, quote: +e.quote }),
          eX = (e) => ({
            open: +e.open,
            high: +e.high,
            low: +e.low,
            close: +e.close,
            epoch: +(e.open_time || e.epoch),
          }),
          eZ = (e) => e.map((e) => eX(e)),
          eJ = (e, t) => (el(e).epoch >= t.epoch ? e : [...e.slice(1), t]),
          eQ = (e, t) => {
            let i = el(e);
            return (i.open === t.open &&
              i.high === t.high &&
              i.low === t.low &&
              i.close === t.close &&
              i.epoch === t.epoch) ||
              i.epoch > t.epoch
              ? e
              : [...(i.epoch === t.epoch ? e.slice(0, -1) : e.slice(1)), t];
          },
          e0 = (e) => (e ? "candles" : "ticks");
        class e1 {
          requestPipSizes() {
            return this.pipSizes
              ? Promise.resolve(this.pipSizes)
              : (this.active_symbols_promise ||
                  (this.active_symbols_promise = new Promise((e) => {
                    (this.pipSizes = c.D.pip_sizes), e(this.pipSizes);
                  })),
                this.active_symbols_promise);
          }
          async request(e) {
            return new Promise((t, i) => {
              let { symbol: o, granularity: s } = e,
                r = e0(s);
              "ticks" === r && this.ticks.has(o) && t(this.ticks.get(o)),
                "candles" === r &&
                  this.candles.hasIn([o, Number(s)]) &&
                  t(this.candles.getIn([o, Number(s)])),
                this.requestStream({ ...e, style: r })
                  .then((e) => {
                    t(e);
                  })
                  .catch((e) => {
                    i(e);
                  });
            });
          }
          monitor(e) {
            return new Promise((t, i) => {
              let { symbol: o, granularity: s, callback: r } = e,
                a = e0(s),
                n = (0, w.Fs)();
              this.request(e)
                .then(() => {
                  "ticks" === a
                    ? ((this.tickListeners = this.tickListeners.setIn(
                        [o, n],
                        r
                      )),
                      g.P.emit("bot.bot_ready"),
                      c.D.toggleRunButton(!1))
                    : (this.ohlcListeners = this.ohlcListeners.setIn(
                        [o, Number(s), n],
                        r
                      )),
                    t(n);
                })
                .catch((e) => {
                  g.P.emit("Error", e),
                    (this.ticks_history_promise = null),
                    c.D.toggleRunButton(!1),
                    i(e);
                });
            });
          }
          async stopMonitor(e) {
            let { symbol: t, granularity: i, key: o } = e,
              s = e0(i);
            "ticks" === s &&
              this.tickListeners.hasIn([t, o]) &&
              (this.tickListeners = this.tickListeners.deleteIn([t, o])),
              "candles" === s &&
                this.ohlcListeners.hasIn([t, Number(i), o]) &&
                (this.ohlcListeners = this.ohlcListeners.deleteIn([
                  t,
                  Number(i),
                  o,
                ])),
              await this.unsubscribeIfEmptyListeners(e);
          }
          async unsubscribeIfEmptyListeners(e) {
            let { symbol: t, granularity: i } = e,
              o = !1,
              s = this.tickListeners.get(t);
            s &&
              !s.size &&
              ((this.tickListeners = this.tickListeners.delete(t)),
              (this.ticks = this.ticks.delete(t)),
              (o = !0));
            let r = this.ohlcListeners.getIn([t, Number(i)]);
            r &&
              !r.size &&
              ((this.ohlcListeners = this.ohlcListeners.deleteIn([
                t,
                Number(i),
              ])),
              (this.candles = this.candles.deleteIn([t, Number(i)])),
              (o = !0)),
              o && (await this.unsubscribeAllAndSubscribeListeners(t));
          }
          unsubscribeAllAndSubscribeListeners(e) {
            let t = this.subscriptions.getIn(["ohlc", e]);
            Promise.all(
              [...(t ? Array.from(t.values()) : [])].map((e) =>
                (0, w.l6)(() => c.D.api.forget(e))
              )
            ),
              (this.subscriptions = new ez.D5());
          }
          updateTicksAndCallListeners(e, t) {
            if (this.ticks.get(e) === t) return;
            this.ticks = this.ticks.set(e, t);
            let i = this.tickListeners.get(e);
            i && i.forEach((t) => t(this.ticks.get(e)));
          }
          updateCandlesAndCallListeners(e, t) {
            if (this.ticks.getIn(e) === t) return;
            this.candles = this.candles.setIn(e, t);
            let i = this.ohlcListeners.getIn(e);
            i && i.forEach((t) => t(this.candles.getIn(e)));
          }
          observe() {
            if (c.D.api) {
              let e = c.D.api.onMessage().subscribe((e) => {
                let { data: t } = e;
                if ("tick" === t.msg_type) {
                  let { tick: e } = t,
                    { symbol: i, id: o } = e;
                  this.ticks.has(i) &&
                    ((this.subscriptions = this.subscriptions.setIn(
                      ["tick", i],
                      o
                    )),
                    this.updateTicksAndCallListeners(
                      i,
                      eJ(this.ticks.get(i), eK(e))
                    ));
                }
                if ("ohlc" === t.msg_type) {
                  let { ohlc: e } = t,
                    { symbol: i, granularity: o, id: s } = e;
                  if (this.candles.hasIn([i, Number(o)])) {
                    this.subscriptions = this.subscriptions.setIn(
                      ["ohlc", i, Number(o)],
                      s
                    );
                    let t = [i, Number(o)];
                    this.updateCandlesAndCallListeners(
                      t,
                      eQ(this.candles.getIn(t), eX(e))
                    );
                  }
                }
              });
              c.D.pushSubscription(e);
            }
          }
          requestStream(e) {
            let { style: t } = e,
              i = JSON.stringify(e);
            if ("ticks" === t) {
              var o;
              return (
                (null === (o = this.ticks_history_promise) || void 0 === o
                  ? void 0
                  : o.stringified_options) !== i &&
                  (this.ticks_history_promise = {
                    promise: this.requestPipSizes().then(() =>
                      this.requestTicks(e)
                    ),
                    stringified_options: i,
                  }),
                this.ticks_history_promise.promise
              );
            }
            return "candles" === t
              ? ((this.candles_promise &&
                  this.candles_promise.stringified_options === i) ||
                  (this.candles_promise = {
                    promise: this.requestPipSizes().then(() =>
                      this.requestTicks(e)
                    ),
                    stringified_options: i,
                  }),
                this.candles_promise.promise)
              : [];
          }
          requestTicks(e) {
            let { symbol: t, granularity: i, style: o } = e,
              s = {
                ticks_history: t,
                subscribe: 1,
                end: "latest",
                count: 1e3,
                granularity: i ? Number(i) : void 0,
                style: o,
              };
            return new Promise((e, r) => {
              c.D.api || e([]),
                (0, w.l6)(() => c.D.api.send(s), [], c.D)
                  .then((s) => {
                    if ("ticks" === o) {
                      let i = ec(s.history);
                      this.updateTicksAndCallListeners(t, i), e(i);
                    } else {
                      let o = eZ(s.candles);
                      this.updateCandlesAndCallListeners([t, Number(i)], o),
                        e(o);
                    }
                  })
                  .catch(r);
            });
          }
          unsubscribeFromTicksService() {
            return new Promise((e, t) => {
              this.forget()
                .then(() => {
                  this.forgetCandleSubscription()
                    .then(() => {
                      e();
                    })
                    .catch(t);
                })
                .catch(t),
                (this.ticks_history_promise = null);
            });
          }
          constructor() {
            (0, a._)(
              this,
              "forget",
              () =>
                new Promise((e, t) => {
                  (null === c.D || void 0 === c.D ? void 0 : c.D.api)
                    ? c.D.api
                        .forgetAll("ticks")
                        .then(() => {
                          e();
                        })
                        .catch(t)
                    : e();
                })
            ),
              (0, a._)(
                this,
                "forgetCandleSubscription",
                () =>
                  new Promise((e, t) => {
                    (null === c.D || void 0 === c.D ? void 0 : c.D.api)
                      ? c.D.api
                          .forgetAll("candles")
                          .then(() => {
                            e();
                          })
                          .catch(t)
                      : e();
                  })
              ),
              (this.ticks = new ez.D5()),
              (this.candles = new ez.D5()),
              (this.tickListeners = new ez.D5()),
              (this.ohlcListeners = new ez.D5()),
              (this.subscriptions = new ez.D5()),
              (this.ticks_history_promise = null),
              (this.active_symbols_promise = null),
              (this.candles_promise = null),
              this.observe();
          }
        }
        let e2 = () => {
          let e = new g.Z();
          return { observer: e, ticksService: new e1(), stopped: !1 };
        };
        (_().prototype.takeStateSnapshot = function () {
          return h(this.stateStack, void 0, void 0, void 0, !0);
        }),
          (_().prototype.restoreStateSnapshot = function (e) {
            (this.stateStack = h(e, void 0, void 0, void 0, !0)),
              (this.global =
                this.stateStack[0].scope.object || this.stateStack[0].scope),
              this.initFunc_(this, this.global);
          });
        let e5 = (e) => e && e.tradeEngine.options,
          e3 = (e) => e5(e) && e.tradeEngine.tradeOptions,
          e6 = function (e) {
            let t =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : "";
            return (
              !m.Jr.includes(t) &&
              e5(e) &&
              e.tradeEngine.options.shouldRestartOnError
            );
          },
          e8 = function (e) {
            let t =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : "";
            return !!(
              [
                "SellNotAvailableCustom",
                "ContractCreationFailure",
                "InvalidtoBuy",
              ].includes(t) && e5(e)
            );
          },
          e9 = (e) => e5(e) && e.tradeEngine.options.timeMachineEnabled,
          e4 = () => {
            let e,
              t = e2(),
              i = eq(t),
              o = {};
            function s(e) {
              o.restoreStateSnapshot(e), (o.paused_ = !1), r();
            }
            function r() {
              (t.stopped || !o.run()) && e(o.pseudoToNative(o.value));
            }
            function a(e, i) {
              let o = function () {
                for (var o = arguments.length, s = Array(o), a = 0; a < o; a++)
                  s[a] = arguments[a];
                let n = s.pop(),
                  l = s.slice().reverse(),
                  c = l.findIndex((e) => void 0 !== e);
                i(
                  ...(c < 0 ? [] : l.slice(c).reverse()).map((t) =>
                    e.pseudoToNative(t)
                  )
                )
                  .then((t) => {
                    n(e.nativeToPseudo(t)), r();
                  })
                  .catch((e) => {
                    t.observer.emit("Error", e.error || e);
                  });
              };
              return (
                Object.defineProperty(o, "length", { value: 101 }),
                e.createAsyncFunction(o)
              );
            }
            function n(e, s) {
              let r = i.getInterface(),
                {
                  getTicksInterface: n,
                  alert: l,
                  prompt: c,
                  sleep: d,
                  console: u,
                } = r;
              e.setProperty(s, "console", e.nativeToPseudo(u)),
                e.setProperty(s, "alert", e.nativeToPseudo(l)),
                e.setProperty(s, "prompt", e.nativeToPseudo(c)),
                e.setProperty(
                  s,
                  "getPurchaseReference",
                  e.nativeToPseudo(r.getPurchaseReference)
                );
              let h = e.nativeToPseudo(r);
              Object.entries(n).forEach((t) => {
                let [i, o] = t;
                return e.setProperty(h, i, a(e, o));
              }),
                e.setProperty(
                  h,
                  "start",
                  e.nativeToPseudo(function () {
                    for (
                      var o = arguments.length, s = Array(o), a = 0;
                      a < o;
                      a++
                    )
                      s[a] = arguments[a];
                    let { start: n } = r;
                    e6(i) && (t.startState = e.takeStateSnapshot()), n(...s);
                  })
                ),
                e.setProperty(h, "purchase", a(e, r.purchase)),
                e.setProperty(h, "sellAtMarket", a(e, r.sellAtMarket)),
                e.setProperty(s, "Bot", h),
                e.setProperty(
                  s,
                  "watch",
                  a(e, (e) => {
                    let { watch: s } = i.getInterface();
                    if (e9(i)) {
                      let i = o.takeStateSnapshot();
                      "before" === e
                        ? (t.beforeState = i)
                        : (t.duringState = i);
                    }
                    return s(e);
                  })
                ),
                e.setProperty(s, "sleep", a(e, d));
            }
            async function l() {
              return new Promise((e, i) => {
                try {
                  (t.stopped = !0),
                    (t.is_error_triggered = !1),
                    g.P.emit("bot.stop");
                  let { ticksService: i } = t;
                  c.D.clearSubscriptions(),
                    i.unsubscribeFromTicksService().then(() => {
                      e();
                    });
                } catch (e) {
                  i(e);
                }
              });
            }
            return (
              t.observer.register("REVERT", (e) =>
                s("before" === e ? t.beforeState : t.duringState)
              ),
              {
                stop: async function e() {
                  return new Promise((e, o) => {
                    try {
                      var s, r, a;
                      let o = g.P.getState("global_timeouts") ?? [],
                        n = Object.keys(o).every((e) => o[e].is_cancellable);
                      !i.tradeEngine.contractId && n
                        ? ((c.D.is_stopping = !0),
                          o.forEach((e) => clearTimeout(o[e])),
                          l().then(() => {
                            (c.D.is_stopping = !1), e();
                          }))
                        : !1 === i.tradeEngine.isSold &&
                          !t.is_error_triggered &&
                          (0, u.L8o)(
                            (null == i
                              ? void 0
                              : null === (a = i.tradeEngine) || void 0 === a
                              ? void 0
                              : null === (r = a.data) || void 0 === r
                              ? void 0
                              : null === (s = r.contract) || void 0 === s
                              ? void 0
                              : s.contract_type) ?? ""
                          )
                        ? g.P.register("contract.status", async (t) => {
                            "contract.sold" === t.id && l().then(() => e());
                          })
                        : ((c.D.is_stopping = !0),
                          l().then(() => {
                            (c.D.is_stopping = !1), e();
                          }));
                    } catch (e) {
                      o(e);
                    }
                  });
                },
                run: function (a) {
                  return new Promise((c, d) => {
                    let u = (r) => {
                      if (t.stopped) return;
                      if ("InvalidToken" === r.code) {
                        g.P.emit("client.invalid_token");
                        return;
                      }
                      if (e8(i, null == r ? void 0 : r.code)) {
                        g.P.emit("ui.log.error", r.message),
                          g.P.emit("bot.click_stop");
                        return;
                      }
                      if (
                        ((t.is_error_triggered = !0), !e6(i, r.code) || !e3(i))
                      ) {
                        d(r);
                        return;
                      }
                      g.P.emit("Error", r);
                      let { initArgs: a, tradeOptions: n } = i.tradeEngine;
                      l(),
                        (i = eq((t = e2()))),
                        (o = {}),
                        (e = () => {}),
                        t.observer.register("Error", u),
                        i.tradeEngine.init(...a),
                        i.tradeEngine.start(n),
                        t.startState &&
                          (null == o
                            ? void 0
                            : o.restoreStateSnapshot) instanceof Function &&
                          s(t.startState);
                    };
                    t.observer.register("Error", u),
                      (o = new (_())(a, n)),
                      (e = c),
                      r();
                  });
                },
                terminateSession: l,
                bot: i,
                unsubscribeFromTicksService: async function e() {
                  let { ticksService: e } = t;
                  return new Promise((t, i) => {
                    try {
                      e.unsubscribeFromTicksService().then(() => {
                        t();
                      });
                    } catch (e) {
                      i(e);
                    }
                  });
                },
              }
            );
          };
        var e7 = i(94576),
          te = i(66345),
          tt = i(26855),
          ti = i(56505),
          to = i(63999),
          ts = i(5466),
          tr = i(8813);
        let ta = {};
        (ta.inherits = function (e, t) {
          function i() {}
          (i.prototype = t.prototype),
            (e.superClass_ = t.prototype),
            (e.prototype = new i()),
            (e.prototype.constructor = e),
            (e.base = function (e, i) {
              for (
                var o = arguments.length, s = Array(o > 2 ? o - 2 : 0), r = 2;
                r < o;
                r++
              )
                s[r - 2] = arguments[r];
              return t.prototype[i].apply(e, s);
            });
        }),
          (ta.math = {}),
          (ta.isDef = function (e) {
            return void 0 !== e;
          }),
          (ta.math.Size = function (e, t) {
            (this.width = e), (this.height = t);
          }),
          (ta.isNumber = function (e) {
            return /^\s*-?\d+(\.\d+)?\s*$/.test(e);
          }),
          (ta.dom = {}),
          (ta.dom.removeNode = function (e) {
            let t = e.parentNode;
            e &&
              t &&
              (null == t ? void 0 : t.contains(e)) &&
              (null == t || t.removeChild(e));
          }),
          (ta.math.Coordinate = function (e, t) {
            (this.x = ta.isDef(e) ? e : 0), (this.y = ta.isDef(t) ? t : 0);
          }),
          (ta.math.Coordinate.prototype.scale = function (e, t) {
            return (
              (t = ta.isNumber(t) ? t : e), (this.x *= e), (this.y *= t), this
            );
          }),
          (ta.math.Coordinate.difference = function (e, t) {
            return new ta.math.Coordinate(e.x - t.x, e.y - t.y);
          }),
          (window.goog = ta);
        let tn = () => {
            ["blockInline"].forEach((e) => {
              window.Blockly.ContextMenuRegistry.registry.getItem(
                e
              ).preconditionFn = () => "hidden";
            });
            let e = {
              undoWorkspace: (0, f.NC)("Undo"),
              redoWorkspace: (0, f.NC)("Redo"),
              cleanWorkspace: (0, f.NC)("Clean up Blocks"),
              collapseWorkspace: (0, f.NC)("Collapse Blocks"),
              expandWorkspace: (0, f.NC)("Expand Blocks"),
              workspaceDelete: (0, f.NC)("Delete All Blocks"),
            };
            Object.keys(e).forEach((t) => {
              window.Blockly.ContextMenuRegistry.registry.getItem(
                t
              ).displayText = (0, f.NC)(e[t]);
            });
          },
          tl = async (e) => {
            let t = await i.e("551").then(i.t.bind(i, 34948, 23));
            (window.Blockly = t.default), (window.Blockly.Colours = {});
            let o = new window.Blockly.Generator("code"),
              s = { ...ts, ...o };
            (window.Blockly.JavaScript = s),
              (window.Blockly.Themes.zelos_renderer =
                window.Blockly.Theme.defineTheme("zelos_renderer", {
                  base: window.Blockly.Themes.Zelos,
                  componentStyles: {},
                })),
              tn(),
              (0, tr.O)(e),
              await i.e("463").then(i.bind(i, 62471)),
              await i.e("378").then(i.bind(i, 3365));
          };
        var tc = i(2776);
        class td {
          async initWorkspace(e, t, o, s, r) {
            await tl(r);
            let a = await (0, te.WN)();
            this.interpreter = e4();
            var n = this;
            return (
              (window.Blockly.Blocks.trade_definition_tradetype.onchange =
                function (e) {
                  if (
                    !this.workspace ||
                    window.Blockly.derivWorkspace.isFlyoutVisible ||
                    this.workspace.isDragging()
                  )
                    return;
                  this.enforceLimitations();
                  let { name: t, type: i } = e;
                  if (i === window.Blockly.Events.BLOCK_CHANGE) {
                    let i = "SYMBOL_LIST" === t,
                      r = "TRADETYPECAT_LIST" === t;
                    if (i || r) {
                      var o, s;
                      let { contracts_for: t } =
                          (null === d.Z || void 0 === d.Z
                            ? void 0
                            : d.Z.instance) ?? {},
                        a = this.getTopParent().getChildByType(
                          "trade_definition_market"
                        ),
                        l = a.getFieldValue("MARKET_LIST"),
                        c = a.getFieldValue("SUBMARKET_LIST"),
                        u = a.getFieldValue("SYMBOL_LIST"),
                        h = this.getFieldValue("TRADETYPECAT_LIST"),
                        p = this.getFieldValue("TRADETYPE_LIST");
                      if (("accumulator" !== p && (0, to.wd)(n), i)) {
                        if (
                          (null == t ||
                            null === (o = t.getTradeTypeCategories) ||
                            void 0 === o ||
                            o.call(t, l, c, u).then((t) => {
                              let i = this.getField("TRADETYPECAT_LIST");
                              i &&
                                i.updateOptions(t, {
                                  default_value: h,
                                  should_pretend_empty: !0,
                                  event_group: e.group,
                                });
                            }),
                          (n.symbol = u),
                          !n.is_bot_running &&
                            n.interpreter &&
                            !this.workspace.options.readOnly &&
                            u !== n.interpreter.bot.tradeEngine.symbol)
                        ) {
                          let e = document.querySelector(
                            "#db-animation__run-button"
                          );
                          e && (e.disabled = !0),
                            n.interpreter
                              .unsubscribeFromTicksService()
                              .then(async () => {
                                var e;
                                await (null === (e = n.interpreter) ||
                                void 0 === e
                                  ? void 0
                                  : e.bot.tradeEngine.watchTicks(u));
                              });
                        }
                      } else
                        r &&
                          e.blockId === this.id &&
                          (null == t ||
                            null === (s = t.getTradeTypes) ||
                            void 0 === s ||
                            s.call(t, l, c, u, h).then((t) => {
                              this.getField("TRADETYPE_LIST").updateOptions(t, {
                                default_value: p,
                                should_pretend_empty: !0,
                                event_group: e.group,
                              });
                            }));
                    }
                  }
                }),
              new Promise((r, n) => {
                (i.p = e), d.Z.setInstance(o), Z.Z.setInstance(t);
                let c = window.innerWidth;
                try {
                  let e = 0.7,
                    { handleFileChange: t } = Z.Z.instance;
                  if (c < 1640) {
                    if (s) e = 0.6;
                    else {
                      var u;
                      e =
                        (null ===
                          (u = document.getElementById("scratch_div")) ||
                        void 0 === u
                          ? void 0
                          : u.offsetWidth) /
                        c /
                        1.5;
                    }
                  }
                  let i = document.getElementById("scratch_div");
                  if (!i) return;
                  (this.workspace = window.Blockly.inject(i, {
                    media: "assets/media/",
                    renderer: "zelos",
                    trashcan: !s,
                    zoom: { wheel: !0, startScale: e },
                    scrollbars: !0,
                    theme: window.Blockly.Themes.zelos_renderer,
                  })),
                    (this.workspace.RTL = (0, tt.rK)()),
                    (this.workspace.cached_xml = { main: ti.default }),
                    this.workspace.addChangeListener(
                      this.valueInputLimitationsListener.bind(this)
                    ),
                    this.workspace.addChangeListener((e) =>
                      (0, tc.P_)(this.workspace, e)
                    ),
                    this.workspace.addChangeListener((e) =>
                      this.workspace.dispatchBlockEventEffects(e)
                    ),
                    this.workspace.addChangeListener((e) => {
                      if (
                        ("drag" !== e.type || e.isStart || s || (0, tc.Y2)(),
                        e.type == window.Blockly.Events.BLOCK_CHANGE)
                      ) {
                        let t = this.workspace.getBlockById(e.blockId);
                        s &&
                          t &&
                          "collapsed" == e.element &&
                          (t.contextMenu = !1);
                      }
                    }),
                    (window.Blockly.derivWorkspace = this.workspace);
                  let o = new window.Blockly.Names("window");
                  (o.variableMap =
                    window.Blockly.derivWorkspace.getVariableMap()),
                    (window.Blockly.JavaScript.variableDB_ = o),
                    this.addBeforeRunFunction(this.unselectBlocks.bind(this)),
                    this.addBeforeRunFunction(
                      this.disableStrayBlocks.bind(this)
                    ),
                    this.addBeforeRunFunction(
                      this.checkForErroredBlocks.bind(this)
                    ),
                    this.addBeforeRunFunction(
                      this.checkForRequiredBlocks.bind(this)
                    ),
                    (this.workspace.current_strategy_id =
                      window.Blockly.utils.idGenerator.genUid()),
                    (window.Blockly.derivWorkspace.strategy_to_load =
                      ti.default),
                    (window.Blockly.getMainWorkspace().strategy_to_load =
                      ti.default),
                    (window.Blockly.getMainWorkspace().RTL = (0, tt.rK)());
                  let n = (0, l.v)().default_file_name;
                  if (a && a.length) {
                    let e = a[0];
                    (window.Blockly.derivWorkspace.strategy_to_load = e.xml),
                      (window.Blockly.getMainWorkspace().strategy_to_load =
                        e.xml),
                      (n = e.name),
                      (window.Blockly.derivWorkspace.current_strategy_id =
                        e.id),
                      (window.Blockly.getMainWorkspace().current_strategy_id =
                        e.id);
                  }
                  let d = `dbot-load${Date.now()}`;
                  window.Blockly.Events.setGroup(d),
                    window.Blockly.Xml.domToWorkspace(
                      window.Blockly.utils.xml.textToDom(
                        window.Blockly.derivWorkspace.strategy_to_load
                      ),
                      this.workspace
                    );
                  let { save_modal: h } = Z.Z.instance;
                  h.updateBotName(n),
                    this.workspace.cleanUp(0, s ? 60 : 56),
                    this.workspace.clearUndo(),
                    window.dispatchEvent(new Event("resize")),
                    window.addEventListener("dragover", td.handleDragOver),
                    window.addEventListener("drop", (e) =>
                      td.handleDropOver(e, t)
                    ),
                    (i.parentNode.style.overflow = "hidden"),
                    r();
                } catch (e) {
                  throw (n(e), e);
                }
              })
            );
          }
          isStrategyUpdated(e, t) {
            if (t && t.length) {
              var i;
              let o =
                null ===
                  (i = t.filter((e) => {
                    var t;
                    return (
                      (null == e ? void 0 : e.id) ===
                      (null === (t = this.workspace) || void 0 === t
                        ? void 0
                        : t.current_strategy_id)
                    );
                  })) || void 0 === i
                  ? void 0
                  : i[0];
              if (null == o ? void 0 : o.xml) {
                let t = null == o ? void 0 : o.xml,
                  i = window.Blockly.Xml.domToText(e);
                if ((0, e7.dY)(t, i)) return !1;
              }
            }
            return !0;
          }
          async saveRecentWorkspace() {
            var e, t;
            let i = (null === this || void 0 === this ? void 0 : this.workspace)
              ? null === (t = Blockly) || void 0 === t
                ? void 0
                : null === (e = t.Xml) || void 0 === e
                ? void 0
                : e.workspaceToDom(this.workspace)
              : null;
            try {
              let e = await (0, te.WN)();
              i &&
                this.isStrategyUpdated(i, e) &&
                (await (0, te.l5)(i, n.Rg.UNSAVED));
            } catch (e) {
              e7.Pi.emit("Error", e), await (0, te.l5)(i, n.Rg.UNSAVED);
            }
          }
          addBeforeRunFunction(e) {
            this.before_run_funcs.push(e);
          }
          shouldRunBot() {
            return this.before_run_funcs.every((e) => !!e());
          }
          async initializeInterpreter() {
            this.interpreter && (await this.interpreter.terminateSession()),
              (this.interpreter = e4());
          }
          runBot() {
            if (!c.D.is_stopping)
              try {
                c.D.is_stopping = !1;
                let e = this.generateCode();
                this.interpreter.bot.tradeEngine.checkTicksPromiseExists() ||
                  (this.interpreter = e4()),
                  (this.is_bot_running = !0),
                  c.D.setIsRunning(!0),
                  this.interpreter.run(e).catch((e) => {
                    e7.Pi.emit("Error", e), this.stopBot();
                  });
              } catch (e) {
                e7.Pi.emit("Error", e), this.interpreter && this.stopBot();
              }
          }
          generateCode() {
            let e =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : {};
            return `
            var BinaryBotPrivateInit;
            var BinaryBotPrivateStart;
            var BinaryBotPrivateBeforePurchase; 
            var BinaryBotPrivateDuringPurchase;
            var BinaryBotPrivateAfterPurchase;
            var BinaryBotPrivateLastTickTime;
            var BinaryBotPrivateTickAnalysisList = [];
            var BinaryBotPrivateHasCalledTradeOptions = false;

           
            function recursiveList(list, final_list){
                for(var i=0; i < list.length; i++){
                    if(typeof(list[i]) === 'object'){
                        recursiveList(list[i], final_list);
                    }
                    if(typeof(list[i]) == 'number'){
                        final_list.push(list[i]);   
                                  
                    }
                }
                return final_list;
            }

            function BinaryBotPrivateRun(f, arg) {
                if (f) return f(arg);
                return false;
            }
            function BinaryBotPrivateTickAnalysis() {
                var currentTickTime = Bot.getLastTick(true);
                while (currentTickTime === 'MarketIsClosed') {
                    sleep(5);
                    currentTickTime = Bot.getLastTick(true);
                }
                currentTickTime = currentTickTime.epoch;
                if (currentTickTime === BinaryBotPrivateLastTickTime) {
                    return;
                }
                BinaryBotPrivateLastTickTime = currentTickTime;
                for (var BinaryBotPrivateI = 0; BinaryBotPrivateI < BinaryBotPrivateTickAnalysisList.length; BinaryBotPrivateI++) {
                    BinaryBotPrivateRun(BinaryBotPrivateTickAnalysisList[BinaryBotPrivateI]);
                }
            }
            var BinaryBotPrivateLimitations = ${JSON.stringify(e)};
            ${window.Blockly.JavaScript.javascriptGenerator.workspaceToCode(
              this.workspace
            )}
            BinaryBotPrivateRun(BinaryBotPrivateInit);
            while (true) {
                BinaryBotPrivateTickAnalysis();
                BinaryBotPrivateRun(BinaryBotPrivateStart);
                if (!BinaryBotPrivateHasCalledTradeOptions) {
                    sleep(1);
                    continue;
                }
                while (watch('before')) {
                    BinaryBotPrivateTickAnalysis();
                    BinaryBotPrivateRun(BinaryBotPrivateBeforePurchase);
                }
                while (watch('during')) {
                    BinaryBotPrivateTickAnalysis();
                    BinaryBotPrivateRun(BinaryBotPrivateDuringPurchase);
                }
                BinaryBotPrivateTickAnalysis();
                if (!BinaryBotPrivateRun(BinaryBotPrivateAfterPurchase)) {
                    break;
                }
            }
            
            `;
          }
          async stopBot() {
            c.D.is_stopping ||
              (c.D.setIsRunning(!1),
              await this.interpreter.stop(),
              (this.is_bot_running = !1),
              (this.interpreter = null),
              (this.interpreter = e4()),
              await this.interpreter.bot.tradeEngine.watchTicks(this.symbol),
              (0, to.wd)(this));
          }
          async terminateBot() {
            this.interpreter &&
              (await this.interpreter.terminateSession(),
              (this.interpreter = null),
              (this.interpreter = e4()),
              await this.interpreter.bot.tradeEngine.watchTicks(this.symbol));
          }
          unselectBlocks() {
            return (
              window.Blockly.getSelected() &&
                window.Blockly.getSelected().unselect(),
              !0
            );
          }
          disableStrayBlocks() {
            return (
              this.workspace.getTopBlocks().forEach((e) => {
                e.isMainBlock() ||
                  e.isIndependentBlock() ||
                  this.disableBlocksRecursively(e);
              }),
              !0
            );
          }
          disableBlocksRecursively(e) {
            var t;
            e.setDisabled(!0),
              (null === (t = e.nextConnection) || void 0 === t
                ? void 0
                : t.targetConnection) &&
                this.disableBlocksRecursively(
                  e.nextConnection.targetConnection.sourceBlock_
                );
          }
          checkForErroredBlocks() {
            this.valueInputLimitationsListener({}, !0);
            let e = this.workspace
              .getAllBlocks(!0)
              .filter((e) => e.is_error_highlighted && !e.disabled)
              .filter(
                (e, t, i) =>
                  t === i.findIndex((t) => t.error_message === e.error_message)
              );
            return (
              !e.length ||
              (this.workspace.centerOnBlock(e[0].id),
              e.forEach((e) => {
                e7.Pi.emit("ui.log.error", e.error_message);
              }),
              !1)
            );
          }
          centerAndHighlightBlock(e) {
            let t =
                arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
              i = this.workspace.getBlockById(e);
            i &&
              (this.workspace
                .getAllBlocks()
                .forEach((e) => e.setErrorHighlighted(!1)),
              t && i.blink(),
              i.setErrorHighlighted(!0),
              this.workspace.centerOnBlock(i.id));
          }
          unHighlightAllBlocks() {
            var e;
            null === (e = this.workspace) ||
              void 0 === e ||
              e.getAllBlocks().forEach((e) => e.setErrorHighlighted(!1));
          }
          checkForRequiredBlocks() {
            return (0, tc.nf)(this.workspace);
          }
          valueInputLimitationsListener(e) {
            let t =
              arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            if (!t && (!this.workspace || this.workspace.isDragging())) return;
            window.Blockly.JavaScript.javascriptGenerator.init(this.workspace),
              t && window.Blockly.hideChaff(!1);
            let i = () =>
                e.type === window.Blockly.Events.BLOCK_DRAG && !e.isStart,
              o = () => e.type === window.Blockly.Events.BLOCK_DELETE,
              s = () => e.type === window.Blockly.Events.BLOCK_CREATE,
              r = () =>
                e.type === window.Blockly.Events.UI &&
                ("click" === e.element || "selected" === e.element),
              a = (t) =>
                e.type === window.Blockly.Events.BLOCK_CHANGE &&
                e.blockId === t.id,
              n = (t) =>
                e.type === window.Blockly.Events.BLOCK_CHANGE &&
                t.inputList.some((t) => {
                  if (t.connection) {
                    let i = t.connection.targetBlock();
                    return i && e.blockId === i.id;
                  }
                  return !1;
                }),
              l = (t) => {
                if (
                  e.type === window.Blockly.Events.BLOCK_CHANGE &&
                  "disabled" === e.element
                ) {
                  let i = t.getParent();
                  for (; null !== i; ) {
                    if (i.id === e.blockId) return !0;
                    i = i.getParent();
                  }
                }
                return !1;
              };
            this.workspace.getAllBlocks(!0).forEach((e) => {
              if (t || i() || o() || s() || r() || a(e) || n(e) || l(e)) {
                if (e.disabled) {
                  let t = (e) => {
                    e.forEach((e) => {
                      e.setErrorHighlighted(!1), t(e.getChildren());
                    });
                  };
                  t([e]);
                  return;
                }
                if (!e.getRequiredValueInputs) return;
                let i = e.getRequiredValueInputs(),
                  o = Object.keys(i).some((t) => {
                    let o = window.Blockly.getSelected() === e,
                      s = e.disabled || e.getInheritedDisabled();
                    if (o || s) return !1;
                    if (e.isCollapsed() && e.hasErrorHighlightedDescendant())
                      return !0;
                    let r = e.getInput(t);
                    if (r || e.domToMutation) {
                      if (r.connection) {
                        let o =
                            window.Blockly.JavaScript.javascriptGenerator
                              .ORDER_ATOMIC,
                          s =
                            window.Blockly.JavaScript.javascriptGenerator.valueToCode(
                              e,
                              t,
                              o
                            ),
                          r = i[t];
                        return "function" == typeof r ? !!r(s) : !s;
                      }
                    } else
                      console.warn("Detected a non-existent required input.", {
                        input_name: t,
                        type: e.type,
                      });
                    return !0;
                  });
                if (
                  (o && e.removeSelect(),
                  e.setErrorHighlighted(o, e.error_message || void 0),
                  t &&
                    (e.is_error_highlighted ||
                      e.hasErrorHighlightedDescendant()))
                ) {
                  let t = e;
                  for (; t; ) t.setCollapsed(!1), (t = t.getParent());
                }
              }
            });
          }
          getStrategySounds() {
            let e = this.workspace
                .getAllBlocks()
                .filter((e) => "notify" === e.type),
              t = [];
            return (
              e.forEach((e) => {
                let i = e.inputList[0].fieldRow[3].value_;
                "silent" !== i && t.push(i);
              }),
              t
            );
          }
          static handleDragOver(e) {
            e.stopPropagation(),
              e.preventDefault(),
              (e.dataTransfer.dropEffect = "copy");
          }
          static handleDropOver(e, t) {
            let i = document.getElementById("scratch_div"),
              o = document.getElementById("load-strategy__local-dropzone-area");
            i.contains(e.target)
              ? t(e)
              : o && o.contains(e.target)
              ? t(e, !1)
              : (e.stopPropagation(),
                e.preventDefault(),
                (e.dataTransfer.effectAllowed = "none"),
                (e.dataTransfer.dropEffect = "none"));
          }
          constructor() {
            (0, a._)(this, "terminateConnection", () => {
              c.D.terminate();
            }),
              (this.interpreter = null),
              (this.workspace = null),
              (this.before_run_funcs = []),
              (this.symbol = null),
              (this.is_bot_running = !1);
          }
        }
        let tu = new td();
      },
      8813: function (e, t, i) {
        "use strict";
        i.d(t, { O: () => s });
        let o = () => {
            let e = Blockly;
            (e.Colours.RootBlock = {
              colour: "#064e72",
              colourSecondary: "#064e72",
              colourTertiary: "#6d7278",
            }),
              (e.Colours.Base = {
                colour: "#e5e5e5",
                colourSecondary: "#ffffff",
                colourTertiary: "#6d7278",
              }),
              (e.Colours.Special1 = {
                colour: "#e5e5e5",
                colourSecondary: "#ffffff",
                colourTertiary: "#6d7278",
              }),
              (e.Colours.Special2 = {
                colour: "#e5e5e5",
                colourSecondary: "#ffffff",
                colourTertiary: "#6d7278",
              }),
              (e.Colours.Special3 = {
                colour: "#e5e5e5",
                colourSecondary: "#ffffff",
                colourTertiary: "#6d7278",
              }),
              (e.Colours.Special4 = {
                colour: "#e5e5e5",
                colourSecondary: "#000000",
                colourTertiary: "#0e0e0e",
              });
          },
          s = () => o();
      },
      1560: function (e, t, i) {
        "use strict";
        i.d(t, { M: () => n, p: () => a });
        var o = i(93162),
          s = i.n(o),
          r = i(47962);
        let a = (e) => {
            let { data: t, filename: i, type: o } = e,
              r = new Blob([t], { type: o });
            s().saveAs(r, i);
          },
          n = (e, t) => {
            let i = (0, r.v)().opposites[t.toUpperCase()];
            if (!i) return (0, r.v)().NOT_AVAILABLE_DROPDOWN_OPTIONS;
            let o = i.map((e) => Object.entries(e)[0].reverse());
            return "both" !== e ? o.filter((t) => t[1] === e) : o;
          };
      },
      2776: function (e, t, i) {
        "use strict";
        i.d(t, {
          NW: () => ei,
          AA: () => ee,
          $9: () => H,
          ox: () => f,
          ei: () => z,
          Z3: () => J,
          dd: () => b,
          a1: () => S,
          zD: () => E,
          Tj: () => v,
          j3: () => Q,
          TU: () => et,
          oG: () => I,
          yW: () => F,
          cM: () => Y,
          P_: () => W,
          UR: () => G,
          Hh: () => T,
          Y2: () => C,
          zJ: () => V,
          nf: () => M,
        });
        var o = i(64736),
          s = i(59462),
          r = i(66175),
          a = i(48059),
          n = i(47962),
          l = i(51434),
          c = i(55967),
          d = i(66345),
          u = i(65464),
          h = i(26855),
          p = i(13604),
          _ = i(94576);
        class m {
          getConversions() {
            var e = this;
            let t = (e, t, i, o) => {
                let s = this.workspace.newBlock(t),
                  r = Array.from(e.children),
                  a = r.find((e) => "mutation" === e.tagName.toLowerCase());
                if (a) {
                  let e = parseInt(a.getAttribute("items")) || 0;
                  if (e > 0) {
                    for (let t = 0; t < e; t++) s.onIconClick();
                    r.filter(
                      (e) => "value" === e.tagName.toLowerCase()
                    ).forEach((e) => {
                      let t = parseInt(
                        e.getAttribute("name").replace(/[^0-9]+/g, "")
                      );
                      Array.from(e.children).forEach((e) => {
                        let i = this.convertBlockNode(e, s);
                        s.getBlocksInStatement("STACK")
                          .find((e, i) => t === i)
                          .getInput(o)
                          .connection.connect(i.outputConnection);
                      });
                      let i = e.parentNode;
                      i &&
                        e &&
                        (null == i ? void 0 : i.contains(e)) &&
                        (null == i || i.removeChild(e));
                    });
                  }
                }
                let n = this.generateUniqueVariable(i),
                  l = this.workspace.newBlock("variables_get");
                return (
                  l.setFieldValue(n.getId(), "VAR"),
                  s.setFieldValue(n.getId(), "VARIABLE"),
                  { block_to_attach: l, statement_blocks: [s] }
                );
              },
              i = (e, t, i) => {
                let o = this.workspace.newBlock(t),
                  s = {
                    input_list: [{ old: "INPUT", new: "INPUT_LIST" }],
                    period: [{ old: "PERIOD", new: "PERIOD" }],
                    fast_ema_period: [
                      { old: "FAST_EMA_PERIOD", new: "FAST_EMA_PERIOD" },
                    ],
                    signal_ema_period: [
                      { old: "SMA_PERIOD", new: "SIGNAL_EMA_PERIOD" },
                      { old: "SIGNAL_EMA_PERIOD", new: "SIGNAL_EMA_PERIOD" },
                    ],
                    slow_ema_period: [
                      { old: "SLOW_EMA_PERIOD", new: "SLOW_EMA_PERIOD" },
                    ],
                    std_dev_multiplier_up: [
                      { old: "UPMULTIPLIER", new: "UPMULTIPLIER" },
                    ],
                    std_dev_multiplier_down: [
                      { old: "DOWNMULTIPLIER", new: "DOWNMULTIPLIER" },
                    ],
                  };
                switch (t) {
                  case "bb_statement":
                  case "bba_statement": {
                    let t = o.getField("BBRESULT_LIST");
                    t && t.setValue(this.getFieldValue(e, "BBRESULT_LIST"));
                    break;
                  }
                  case "macda_statement": {
                    let t = o.getField("MACDFIELDS_LIST");
                    t && t.setValue(this.getFieldValue(e, "MACDFIELDS_LIST"));
                  }
                }
                (o.required_child_blocks || []).forEach((e) => {
                  let t = this.workspace.newBlock(e);
                  o.getLastConnectionInStatement("STATEMENT").connect(
                    t.previousConnection
                  );
                }),
                  o.getBlocksInStatement("STATEMENT").forEach((t) => {
                    let i = s[t.type];
                    i &&
                      i.forEach((i) => {
                        let s = e.querySelector(`value[name="${i.old}"]`);
                        if (s) {
                          let e = t.getInput(i.new);
                          Array.from(s.children).forEach((t) => {
                            let i = this.convertBlockNode(t, o);
                            "shadow" === t.tagName.toLowerCase() &&
                              i.setShadow(!0),
                              e.connection.connect(i.outputConnection);
                          });
                          let a = null == s ? void 0 : s.parentNode;
                          if (a && s && (null == a ? void 0 : a.contains(s))) {
                            var r;
                            null == s ||
                              null === (r = s.parentNode) ||
                              void 0 === r ||
                              r.removeChild(s);
                          }
                        }
                      });
                  });
                let r = this.generateUniqueVariable(i),
                  a = this.workspace.newBlock("variables_get");
                return (
                  a.setFieldValue(r.getId(), "VAR"),
                  o.setFieldValue(r.getId(), "VARIABLE"),
                  { block_to_attach: a, statement_blocks: [o] }
                );
              },
              o = function (t) {
                let i =
                    arguments.length > 1 &&
                    void 0 !== arguments[1] &&
                    arguments[1],
                  o = e.workspace.newBlock("trade_definition_tradeoptions");
                if (i) return !1;
                let s = Array.from(t.children),
                  r = 0,
                  a = !1;
                return (
                  s
                    .filter((e) => "value" === e.tagName.toLowerCase())
                    .forEach((e) => {
                      let t = e.getAttribute("name");
                      "BARRIEROFFSET" === t || "SECONDBARRIEROFFSET" === t
                        ? r++
                        : "PREDICTION" === t && (a = !0);
                    }),
                  r > 0 &&
                    o.createBarrierInputs({
                      allow_both_types: !0,
                      values: [1, -1],
                    }),
                  a && o.createPredictionInput([0]),
                  [
                    "DURATIONTYPE_LIST",
                    "CURRENCY_LIST",
                    "BARRIEROFFSETTYPE_LIST",
                    "SECONDBARRIEROFFSETTYPE_LIST",
                  ].forEach((i) => {
                    let s = o.getField(i);
                    s && s.setValue(e.getFieldValue(t, i));
                  }),
                  { block_to_attach: o }
                );
              };
            return {
              bb: (e) => i(e, "bb_statement", "bb"),
              bba: (e) => i(e, "bba_statement", "bba"),
              ema: (e) => i(e, "ema_statement", "ema"),
              emaa: (e) => i(e, "emaa_statement", "emaa"),
              lists_create_with: (e) =>
                t(e, "lists_create_with", (0, a.NC)("list"), "VALUE"),
              macda: (e) => i(e, "macda_statement", "macda"),
              market: (e) => ((this.has_market_block = !0), o(e)),
              rsi: (e) => i(e, "rsi_statement", "rsi"),
              rsia: (e) => i(e, "rsia_statement", "rsia"),
              sma: (e) => i(e, "sma_statement", "sma"),
              smaa: (e) => i(e, "smaa_statement", "smaa"),
              text_join: (e) => t(e, "text_join", (0, a.NC)("text"), "TEXT"),
              trade: (e) => {
                let t = this.workspace.newBlock("trade_definition"),
                  i = {
                    trade_definition_market: [
                      "MARKET_LIST",
                      "SUBMARKET_LIST",
                      "SYMBOL_LIST",
                    ],
                    trade_definition_tradetype: [
                      "TRADETYPECAT_LIST",
                      "TRADETYPE_LIST",
                    ],
                    trade_definition_contracttype: ["TYPE_LIST"],
                    trade_definition_candleinterval: ["CANDLEINTERVAL_LIST"],
                    trade_definition_restartbuysell: ["TIME_MACHINE_ENABLED"],
                    trade_definition_restartonerror: ["RESTARTONERROR"],
                  },
                  o = {};
                return (
                  Object.keys(i).forEach((t) => {
                    let s = this.workspace.newBlock(t);
                    i[t].forEach((t) => {
                      s.setFieldValue(this.getFieldValue(e, t), t);
                    }),
                      (o[t] = s);
                  }),
                  Object.values(o).forEach((e) => {
                    t.getLastConnectionInStatement("TRADE_OPTIONS").connect(
                      e.previousConnection
                    );
                  }),
                  { block_to_attach: t }
                );
              },
              tradeOptions: o,
            };
          }
          getIllegalBlocks() {
            var e;
            let t = [],
              { active_symbols: i } = (null === p.Z || void 0 === p.Z
                ? void 0
                : null === (e = p.Z.instance) || void 0 === e
                ? void 0
                : e.active_symbols) ?? { active_symbols: [] },
              { opposites: o } = (0, n.v)();
            return (
              i.forEach((e) => {
                let i = e.symbol.toLowerCase();
                t.includes(i) || t.push(i);
              }),
              Object.keys(o).forEach((e) => t.push(e)),
              t
            );
          }
          createWorkspace() {
            let e = new window.Blockly.Options({ media: "assets/images" }),
              t = new DocumentFragment();
            return window.Blockly.createVirtualWorkspace_(t, e, !1, !1);
          }
          getFieldValue(e, t) {
            let i = e.querySelector(`field[name="${t}"]`);
            return i ? i.textContent : "";
          }
          getFirstBlockInStack(e) {
            let t = e.previousConnection,
              i = e.getPreviousBlock();
            if (!t) return e;
            for (; i && i !== e.getSurroundParent(); )
              (t = i.previousConnection), (i = i.getPreviousBlock());
            return t.sourceBlock_;
          }
          updateRenamedFields(e) {
            let t = {
              MARKET_LIST: { volidx: "synthetic_index" },
              TRADETYPECAT_LIST: {
                endsinout: "inout",
                staysinout: "inout",
                callputequal: "callput",
              },
              TRADETYPE_LIST: {
                risefall: "callput",
                risefallequals: "callputequal",
              },
            };
            return (
              Object.keys(t).forEach((i) => {
                let o = e.querySelector(`field[name="${i}"]`);
                if (o) {
                  let e = o.innerText;
                  Object.keys(t[i]).forEach((s) => {
                    e === s && (o.innerText = t[i][s]);
                  });
                }
              }),
              e
            );
          }
          naivelyFixLegacyStrategyAfterConversion() {
            var e;
            let t =
                null === (e = this.workspace) || void 0 === e
                  ? void 0
                  : e.getTradeDefinitionBlock(),
              i =
                (null == t
                  ? void 0
                  : t.getBlocksInStatement("INITIALIZATION").length) > 0;
            t &&
              t.getBlocksInStatement("SUBMARKET").forEach((e) => {
                if (
                  "trade_definition_tradeoptions" !== e.type &&
                  this.has_market_block &&
                  !i
                ) {
                  let i = t.getLastConnectionInStatement("INITIALIZATION");
                  e.unplug(!0), i.connect(e.previousConnection);
                }
              });
          }
          generateUniqueVariable(e) {
            let t = e,
              i = 0;
            for (; Object.values(this.workspace_variables).includes(t); )
              t = e + ++i;
            let o = window.Blockly.Variables.getOrCreateVariablePackage(
              this.workspace,
              "",
              t,
              ""
            );
            return (this.workspace_variables[o.id_] = t), o;
          }
          convertStrategy(e, t) {
            window.Blockly.Events.disable();
            let i = this.updateRenamedFields(e);
            if (
              e.hasAttribute("is_dbot") &&
              "true" === e.getAttribute("is_dbot")
            )
              return window.Blockly.Events.enable(), i;
            if (
              this.getIllegalBlocks().some((e) => {
                if (!this.exception_blocks.includes(e))
                  return !!i.querySelector(`block[type="${e}"]`);
              })
            )
              return (
                t && t(),
                window.Blockly.Events.enable(),
                window.Blockly.utils.xml.textToDom("<xml />")
              );
            let o = [],
              s = [];
            Array.from(i.children).forEach((e) => {
              switch (e.nodeName.toLowerCase()) {
                case "block":
                case "shadow":
                  s.push(e);
                  break;
                case "variables":
                  o.push(...e.children);
              }
            });
            let r = (e) => {
              e.forEach((e) => {
                let t = e.getAttribute("id"),
                  i = e.textContent;
                if (!this.workspace_variables[t]) {
                  let e = window.Blockly.Variables.getOrCreateVariablePackage(
                    this.workspace,
                    t,
                    i,
                    ""
                  );
                  this.workspace_variables[e.id_] = e.name;
                }
              });
            };
            r(o),
              r(i.querySelectorAll('field[name="VAR"]')),
              s.forEach((e) => this.convertBlockNode(e)),
              Object.keys(this.blocks_pending_reconnect).forEach((e) => {
                let t = this.workspace.getBlockById(e),
                  i = this.blocks_pending_reconnect[e],
                  o = t.previousConnection;
                if (o) {
                  let e = o.targetConnection,
                    s = o;
                  if (
                    (i.reverse().forEach((e) => {
                      s.connect(e.nextConnection), (s = e.previousConnection);
                    }),
                    e)
                  ) {
                    let i = t.previousConnection,
                      o = t.getPreviousBlock();
                    for (; o && o !== o.getSurroundParent(); )
                      (i = o.previousConnection), (o = o.getPreviousBlock());
                    e.connect(i);
                  }
                }
              }),
              this.naivelyFixLegacyStrategyAfterConversion(),
              this.workspace.getAllBlocks(!0).forEach((e) => {
                e.initSvg(), e.renderEfficiently();
              }),
              this.workspace.cleanUp();
            let a = window.Blockly.Xml.workspaceToDom(this.workspace);
            return (
              (0, _.Xt)(a),
              (this.workspace = null),
              window.Blockly.Events.enable(),
              a
            );
          }
          convertBlockNode(e) {
            let t =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : null,
              i = this.getConversions(),
              o = e.getAttribute("type"),
              s = Object.keys(i).includes(o),
              r = null,
              a =
                (e.getAttribute("collapsed") &&
                  "true" === e.getAttribute("collapsed")) ||
                !1,
              n =
                e.getAttribute("movable") &&
                "false" === e.getAttribute("movable"),
              l =
                e.getAttribute("deletable") &&
                "false" === e.getAttribute("deletable"),
              c =
                e.getAttribute("disabled") &&
                "true" === e.getAttribute("disabled"),
              d = (e) => {
                e.setCollapsed(a),
                  e.setMovable(!n),
                  e.setDeletable(!l),
                  e.setDisabled(c);
              };
            if (s) {
              let s = i[o](e);
              s.block_to_attach && d((r = s.block_to_attach)),
                t &&
                  s.statement_blocks &&
                  s.statement_blocks.forEach((e) => {
                    d(e);
                    let i = this.getClosestLegalPreviousConnection(t);
                    if (i) {
                      let t = i.sourceBlock_;
                      this.blocks_pending_reconnect[t.id] ||
                        (this.blocks_pending_reconnect[t.id] = []),
                        this.blocks_pending_reconnect[t.id].push(e);
                    }
                  });
            } else if (
              Object.keys(window.Blockly.Blocks).includes(o) &&
              (d((r = this.workspace.newBlock(o))), r)
            ) {
              let t = Array.from(e.children).find(
                (e) => "mutation" === e.tagName.toLowerCase()
              );
              t && r.domToMutation && r.domToMutation(t);
            }
            return r
              ? (t && (r.conversion_parent = t),
                Array.from(e.children).forEach((e) => {
                  switch (e.tagName.toLowerCase()) {
                    case "field": {
                      let t = e.getAttribute("name"),
                        i = r.getField(t);
                      if (i) {
                        if (i instanceof window.Blockly.FieldVariable) {
                          let t = e.getAttribute("id"),
                            o = e.innerText.trim(),
                            s =
                              window.Blockly.Variables.getOrCreateVariablePackage(
                                this.workspace,
                                t,
                                o,
                                ""
                              );
                          (this.workspace_variables[s.id_] = o),
                            i.setValue(s.id_);
                        } else i.setValue(e.innerText);
                      }
                      break;
                    }
                    case "value":
                      this.processValueInputs(r, e);
                      break;
                    case "statement": {
                      let t = e.getAttribute("name");
                      this.processStatementInputs(r, t, e);
                      break;
                    }
                    case "next": {
                      let t = e.closest("statement");
                      if (t) {
                        let i = t.getAttribute("name");
                        this.processStatementInputs(
                          r,
                          i,
                          e,
                          r.conversion_parent
                        );
                      } else
                        r.nextConnection &&
                          Array.from(e.children).forEach((e) => {
                            let t = this.convertBlockNode(e);
                            r.nextConnection.connect(t.previousConnection);
                          });
                    }
                  }
                }),
                r)
              : (console.warn("Unrecognised block found.", o), !1);
          }
          processValueInputs(e, t) {
            let i = t.getAttribute("name"),
              o = e.getInput(i);
            if (!o) return console.warn("Unrecognised value input", i), !1;
            Array.from(t.children).forEach((t) => {
              let i = this.convertBlockNode(t, e);
              if (!i)
                return (
                  console.warn("Illegal child.", t.getAttribute("type")), !1
                );
              "shadow" === t.tagName.toLowerCase() && i.setShadow(!0),
                o.connection.connect(i.outputConnection);
            });
          }
          processStatementInputs(e, t, i) {
            let o =
                arguments.length > 3 && void 0 !== arguments[3]
                  ? arguments[3]
                  : null,
              s = o || e;
            if (!s.getInput(t))
              return console.warn("Unrecognised statement input", t), !1;
            Array.from(i.children).forEach((e) => {
              let i = this.convertBlockNode(e, s);
              if (!i)
                return (
                  console.warn(
                    "Unrecognised child in statement",
                    e.getAttribute("type")
                  ),
                  !1
                );
              let o = s.getInput(t);
              o &&
                i.previousConnection &&
                o.connection.connect(i.previousConnection);
            });
          }
          getClosestLegalPreviousConnection(e) {
            if ((0, n.v)().procedureDefinitionBlocks.includes(e.type)) {
              if (0 === e.getBlocksInStatement("STACK").length) {
                let t = e.getInput("STACK"),
                  i = this.workspace.newBlock("useless_block");
                return (
                  t.connection.connect(i.previousConnection),
                  i.previousConnection
                );
              }
              return e.getInputTargetBlock("STACK").previousConnection;
            }
            let t = this.getFirstBlockInStack(e),
              i = this.isConnectedToProtectedStatementInput(t);
            for (; i; ) {
              let e = t.getParent();
              e &&
                ((t = e), (i = this.isConnectedToProtectedStatementInput(t)));
            }
            return t.previousConnection
              ? t.previousConnection
              : !!e.conversion_parent &&
                  this.getClosestLegalPreviousConnection(e.conversion_parent);
          }
          isConnectedToProtectedStatementInput(e) {
            let t = this.getFirstBlockInStack(e).previousConnection;
            if (t) {
              let e = t.targetConnection;
              if (e) {
                let t = e.sourceBlock_,
                  i = t.getInputWithConnection(e),
                  o = t.protected_statements || [];
                if (i && o.includes(i.name)) return !0;
              }
            }
            return !1;
          }
          constructor() {
            (this.blocks_pending_reconnect = {}),
              (this.workspace = this.createWorkspace()),
              (this.workspace_variables = {}),
              (this.has_market_block = !1),
              (this.exception_blocks = ["r_100"]);
          }
        }
        var g = i(85872),
          y = i(1560);
        let v = {
            media: "assets/images/",
            zoom: {
              wheel: !0,
              startScale: (0, n.v)().workspaces.previewWorkspaceStartScale,
            },
            readOnly: !0,
            scrollbars: !0,
            renderer: "zelos",
          },
          f = (e) => {
            if (!window.Blockly) return;
            let { strategy_id: t, convertedDom: i, file_name: o, from: s } = e;
            window.Blockly.xmlValues = {
              ...window.Blockly.xmlValues,
              strategy_id: t,
              convertedDom: i,
              file_name: o,
              from: s,
            };
          },
          b = function () {
            let e =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : window.Blockly.derivWorkspace,
              t = e
                .getAllBlocks(!0)
                .find((e) => "trade_definition_tradetype" === e.type),
              i = null == t ? void 0 : t.getFieldValue("TRADETYPE_LIST"),
              o = "trade_definition_tradeoptions";
            return (
              "multiplier" === i && (o = "trade_definition_multiplier"),
              "accumulator" === i && (o = "trade_definition_accumulator"),
              o
            );
          },
          w = (e) => {
            let t = e.match(
              /translate\((-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)\)/
            );
            return t && t.length > 2
              ? { x: parseFloat(t[1]), y: parseFloat(t[2]) }
              : null;
          },
          k = () => {
            var e, t, i;
            let o = w(
              null === (i = window.Blockly) || void 0 === i
                ? void 0
                : null === (t = i.derivWorkspace) || void 0 === t
                ? void 0
                : null === (e = t.trashcan) || void 0 === e
                ? void 0
                : e.svgGroup.getAttribute("transform")
            );
            return (
              o || u.P.emit("Error", "Invalid String"),
              { translate_X: o.x, translate_Y: o.y }
            );
          },
          C = () => {
            var e, t, i, o, s, r, a;
            let { translate_X: n, translate_Y: l } = k(),
              d =
                null === (e = window.Blockly.getSelected()) || void 0 === e
                  ? void 0
                  : e.getSvgRoot().getBoundingClientRect(),
              h = (null == d ? void 0 : d.left) || 0,
              p = (null == d ? void 0 : d.top) || 0,
              _ = [b(), "trade_definition", "purchase", "before_purchase"];
            (null == _
              ? void 0
              : _.includes(
                  null === (i = window.Blockly) || void 0 === i
                    ? void 0
                    : null === (t = i.getSelected()) || void 0 === t
                    ? void 0
                    : t.type
                )) &&
              p >= l - 200 &&
              p <= l + 200 &&
              h >= n - 200 &&
              h <= n + 200 &&
              u.P.emit(
                "ui.log.error",
                null === c.T || void 0 === c.T
                  ? void 0
                  : null === (a = (0, c.T)()) || void 0 === a
                  ? void 0
                  : null ===
                      (o =
                        a[
                          null === (r = window.Blockly) || void 0 === r
                            ? void 0
                            : null === (s = r.getSelected()) || void 0 === s
                            ? void 0
                            : s.type
                        ]) || void 0 === o
                  ? void 0
                  : o.default
              );
          },
          T = () => {
            var e, t;
            if (!(null === g.Z || void 0 === g.Z ? void 0 : g.Z.instance))
              return;
            let { load_modal: i } = g.Z.instance,
              o =
                (null == i
                  ? void 0
                  : null === (t = i.dashboard_strategies) || void 0 === t
                  ? void 0
                  : null === (e = t[0]) || void 0 === e
                  ? void 0
                  : e.name) ?? (0, n.v)().default_file_name;
            if (document.title.indexOf("-") > -1) {
              let e = document.title.substr(document.title.indexOf("-")),
                t = document.title.replace(e, `- ${o}`);
              document.title = t;
            } else document.title += ` - ${o}`;
          },
          N = (e, t, i) => {
            let { clientX: o = 0, clientY: s = 0 } = t || {},
              r = i.getMetrics(),
              a = 1 / i.scale,
              n = r.absoluteLeft - r.viewLeft,
              l = document.body.offsetHeight - r.viewHeight - r.viewTop;
            i.cleanUp(o ? (o - n) * a : 0, s ? (s - l - 76) * a : 0, e);
          },
          S = function () {
            let e =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : "@deriv/bot",
              t =
                arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
              i = arguments.length > 2 ? arguments[2] : void 0;
            i.setAttribute("is_dbot", "true"),
              i.setAttribute("collection", t ? "true" : "false");
            let o = window.Blockly.Xml.domToPrettyText(i);
            (0, y.p)({
              data: o,
              type: "text/xml;charset=utf-8",
              filename: `${e}.xml`,
            });
          },
          x = (e) => new Promise((t) => setTimeout(t, e)),
          E = async (e) => {
            let t,
              {
                block_string: i,
                drop_event: r,
                file_name: n,
                strategy_id: c,
                from: p,
                workspace: _,
                showIncompatibleStrategyDialog: y,
              } = e;
            if (!(null === g.Z || void 0 === g.Z ? void 0 : g.Z.instance) || !_)
              return;
            let { setLoading: v, load_modal: b } = g.Z.instance,
              { setOpenButtonDisabled: w, setLoadedLocalFile: k } = b;
            v(!0), await x(100);
            let C = () => {
              k(null), (0, o.J)((0, s.xG)().invalid_xml), v(!1);
              let e = (0, a.NC)(
                "XML file contains unsupported elements. Please check or modify file."
              );
              return u.P.emit("ui.log.error", e), { error: e };
            };
            try {
              if (
                new DOMParser()
                  .parseFromString(i, "application/xml")
                  .getElementsByTagName("parsererror").length
              )
                return C();
            } catch (e) {
              return C();
            }
            try {
              t = window.Blockly.utils.xml.textToDom(i);
            } catch (e) {
              return C();
            }
            let T = (t = new m().convertStrategy(t, y)).querySelectorAll(
              "block"
            );
            if (
              !T.length ||
              Array.from(T).some((e) => {
                let t = e.getAttribute("type");
                return !Object.keys(window.Blockly.Blocks).includes(t);
              })
            )
              return C();
            try {
              let e =
                  t.hasAttribute("collection") &&
                  "true" === t.getAttribute("collection"),
                i = e
                  ? `load_collection${Date.now()}`
                  : `dbot-load${Date.now()}`;
              if (
                (window.Blockly.Events.setGroup(i),
                (0, h.kH)(
                  _,
                  Array.from(T).map((e) => e.getAttribute("type"))
                ),
                f({ strategy_id: c, convertedDom: t, file_name: n, from: p }),
                e)
              )
                D(t, r, i, _);
              else if (
                (await O(t, i, _), _ === window.Blockly.derivWorkspace)
              ) {
                let { save_modal: e } = g.Z.instance;
                e.updateBotName(n),
                  _.clearUndo(),
                  (_.current_strategy_id =
                    c || window.Blockly.utils.idGenerator.genUid()),
                  await (0, d.l5)(t, p);
              }
              _.getAllBlocks().forEach((e) => {
                e.disabled && (e.is_user_disabled_state = !0);
              }),
                _ === window.Blockly.derivWorkspace &&
                  u.P.emit("ui.log.success", { log_type: l.v9.LOAD_BLOCK });
            } catch (e) {
              return console.error(e), C();
            } finally {
              v(!1), w(!1);
            }
          },
          D = (e, t, i, o) => {
            window.Blockly.Events.setGroup(i);
            let s = window.Blockly.Xml.domToWorkspace(e, o).map((e) =>
              o.getBlockById(e)
            );
            t && 0 !== Object.keys(t).length ? N(s, t, o) : o.cleanUp();
          },
          O = async (e, t, i) => {
            window.Blockly.Events.setGroup(t),
              await i.asyncClear(),
              window.Blockly.Xml.clearWorkspaceAndLoadFromXml(e, i),
              i.cleanUp();
          },
          A = (e, t) =>
            new Promise((i, o) => {
              let s;
              try {
                s = window.Blockly.utils.xml.textToDom(e);
              } catch (e) {
                return o((0, a.NC)("Unrecognized file format"));
              }
              try {
                (s.hasAttribute("collection") &&
                  "true" === s.getAttribute("collection")) ||
                  o((0, a.NC)("Remote blocks to load must be a collection.")),
                  L(s)
                    .then(() => {
                      Array.from(s.children).forEach((e) => R(e, t)), i();
                    })
                    .catch(() => {
                      o();
                    });
              } catch (e) {
                o((0, a.NC)("Unable to load the block file."));
              }
            }),
          I = (e) =>
            new Promise((t, i) => {
              let o = e.getFieldValue("URL");
              -1 === o.indexOf("http") && (o = `http://${o}`);
              let s = "/" === o.slice(-1)[0];
              if (!o.match(/[^/]*\.[a-zA-Z]{3}$/) && !s)
                return i((0, a.NC)("Target must be an XML file"));
              if ((s && (o += "index.xml"), e.isKnownUrl(o)))
                return (
                  e.setDisabled(!0), i((0, a.NC)("This URL is already loaded"))
                );
              let r = () =>
                i((0, a.NC)("An error occured while trying to load the URL"));
              fetch(o)
                .then((i) => {
                  i.ok
                    ? i.text().then((i) => {
                        A(i, e)
                          .then(() => t(e))
                          .catch(r);
                      })
                    : r();
                })
                .catch(r);
            }),
          L = (e) =>
            new Promise((t, i) => {
              let o = [];
              Array.from(e.children).forEach((e) => {
                if ("loader" === e.getAttribute("type")) {
                  e.remove();
                  let t = window.Blockly.Xml.domToBlock(
                    e,
                    window.Blockly.derivWorkspace
                  );
                  o.push(I(t));
                }
              }),
                o.length ? Promise.all(o).then(t, i) : t([]);
            }),
          R = function (e) {
            let t =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : null;
            if ("variables" === e.tagName.toLowerCase())
              return window.Blockly.Xml.domToVariables(
                e,
                window.Blockly.derivWorkspace
              );
            let i = e.getAttribute("type"),
              o = new m(),
              s = window.Blockly.Xml.blockToDom(o.convertBlockNode(e));
            Array.from(s.getElementsByTagName("arg")).forEach((e) => {
              e.hasAttribute("varid") &&
                e.setAttribute("varId", e.getAttribute("varid"));
            }),
              (0, h.kH)(window.Blockly.derivWorkspace, i);
            let r = window.Blockly.Xml.domToBlock(
              s,
              window.Blockly.derivWorkspace
            );
            return t && t.blocks_added_by_me.push(r), r;
          },
          B = (e, t) =>
            e.getAllBlocks().filter((e) => {
              if (t.includes(e.type))
                return (
                  (0 === e.childBlocks_.length && t.includes(e.category_)) ||
                  null === e.parentBlock_
                );
            }),
          P = (e, t) =>
            t.filter((t) => !e.getAllBlocks().some((e) => e.type === t)),
          j = (e) => {
            let t = window.Blockly.derivWorkspace,
              i = [b(t), ...(0, n.v)().mandatoryMainBlocks],
              o = Object.fromEntries(
                t
                  .getAllBlocks()
                  .filter((e) => i.includes(e.type))
                  .map((e) => [e.type, e.disabled])
              );
            return [
              "before_purchase",
              "purchase",
              "trade_definition",
              "trade_definition_tradeoptions",
            ].some((e) => o[e])
              ? e.filter((e) => {
                  var t;
                  return (
                    e.disabled ||
                    (null === (t = e.childBlocks_) || void 0 === t
                      ? void 0
                      : t.some((e) => e.disabled))
                  );
                })
              : [];
          },
          U = (e, t) =>
            e.forEach((e) => {
              var i, o, s, r, a, n;
              if ("misplaced" === t && e)
                u.P.emit(
                  "ui.log.error",
                  null === c.T || void 0 === c.T
                    ? void 0
                    : null === (o = (0, c.T)()) || void 0 === o
                    ? void 0
                    : null === (i = o[null == e ? void 0 : e.type]) ||
                      void 0 === i
                    ? void 0
                    : i[t]
                );
              else if ("missing" === t && e)
                u.P.emit(
                  "ui.log.error",
                  null === c.T || void 0 === c.T
                    ? void 0
                    : null === (r = (0, c.T)()) || void 0 === r
                    ? void 0
                    : null === (s = r[e]) || void 0 === s
                    ? void 0
                    : s[t]
                );
              else if ("disabled" === t && e) {
                let i = !1,
                  o =
                    null === c.T || void 0 === c.T
                      ? void 0
                      : null === (n = (0, c.T)()) || void 0 === n
                      ? void 0
                      : null === (a = n[e.type]) || void 0 === a
                      ? void 0
                      : a[t];
                e.disabled && o
                  ? (u.P.emit("ui.log.error", o), (i = !0))
                  : !i &&
                    e.childBlocks_ &&
                    e.childBlocks_.forEach((e) => {
                      var i, o;
                      let s =
                        null === c.T || void 0 === c.T
                          ? void 0
                          : null === (o = (0, c.T)()) || void 0 === o
                          ? void 0
                          : null === (i = o[e.type]) || void 0 === i
                          ? void 0
                          : i[t];
                      s && u.P.emit("ui.log.error", s);
                    });
              }
            }),
          M = (e) => {
            if (!e) return !1;
            let t = b(e),
              { mandatoryMainBlocks: i } = (0, n.v)(),
              o = [t, ...i],
              s = B(e, o),
              r = P(e, o),
              a = j(s);
            return (
              r && U(r, "missing"),
              a && U(a, "disabled"),
              0 == [...r, ...a].length
            );
          },
          F = (e, t, i, o) => {
            var s, r, a, n, l, c, d, u, h;
            let p = e.getMetrics(),
              _ = p.viewLeft - p.scrollLeft,
              m = p.viewTop - p.scrollTop,
              y = m;
            if (
              (i
                ? ((_ += o ? t : -t), g.Z.instance.is_mobile || (y += -20))
                : ((_ += -20), (y += o ? t : -t)),
              e.RTL)
            ) {
              _ = t;
              let i =
                null === (a = document.getElementById("gtm-toolbox")) ||
                void 0 === a
                  ? void 0
                  : null === (r = a.getBoundingClientRect()) || void 0 === r
                  ? void 0
                  : r.top;
              if (
                ((null === (l = e.svgBlockCanvas_) || void 0 === l
                  ? void 0
                  : null === (n = l.getBoundingClientRect()) || void 0 === n
                  ? void 0
                  : n.top) > i && (y = m),
                window.innerWidth < 768)
              ) {
                null == e ||
                  null === (c = e.scrollbar) ||
                  void 0 === c ||
                  c.set(0, y);
                let t =
                  (null === (d = e.svgBlockCanvas_) || void 0 === d
                    ? void 0
                    : d.getBoundingClientRect().width) -
                  (null === (u = e.svgBlockCanvas_) || void 0 === u
                    ? void 0
                    : u.getBoundingClientRect().left) +
                  60;
                null == e ||
                  null === (h = e.scrollbar) ||
                  void 0 === h ||
                  h.set(t, y);
                return;
              }
            }
            null == e ||
              null === (s = e.scrollbar) ||
              void 0 === s ||
              s.set(_, y);
          },
          G = (e, t, i) => {
            let o = (e && window.Blockly.Events.getGroup()) || i || !0;
            window.Blockly.Events.setGroup(o),
              t(),
              e || window.Blockly.Events.setGroup(!1);
          },
          H = (e) => {
            let { recordUndo: t } = window.Blockly.Events;
            window.Blockly.Events.setRecordUndo(!1),
              e(),
              window.Blockly.Events.setRecordUndo(t ?? !0);
          },
          V = (e) => {
            window.Blockly.Events.disable(),
              e(),
              window.Blockly.Events.enable();
          },
          W = (e, t) => {
            t.type !== window.Blockly.Events.BLOCK_DRAG ||
              t.isStart ||
              e.getAllBlocks().forEach((e) => {
                if (!e.getParent() || e.is_user_disabled_state) return;
                let i = e.restricted_parents || [];
                if (0 === i.length) return;
                let o = !i.some((t) => e.isDescendantOf(t));
                G(
                  !0,
                  () => {
                    e.setDisabled(o);
                  },
                  t.group
                ),
                  window.Blockly.Events.setGroup(!1);
              });
          },
          Y = (e) => !e || "''" === e,
          $ = () => {
            var e, t;
            let i =
                null === (t = window.Blockly) || void 0 === t
                  ? void 0
                  : null === (e = t.getSelected()) || void 0 === e
                  ? void 0
                  : e.svgGroup_,
              o = window.Blockly.Xml.domToPrettyText(i);
            (0, y.p)({
              data: o,
              type: "text/xml;charset=utf-8",
              filename: "block.xml",
            });
          },
          q = () => ({
            text: (0, a.NC)("Download Block"),
            enabled: !0,
            callback: $,
          }),
          z = (e, t) => {
            for (let i = 0; i <= e.length - 1; i++) {
              let o = (0, a.NC)(e[i].text);
              t.includes(o) ? e.splice(i, 1) : (e[i].text = o);
            }
          },
          K = () => [
            (0, a.NC)("Duplicate"),
            (0, a.NC)("Add Comment"),
            (0, a.NC)("Remove Comment"),
            (0, a.NC)("Collapse Block"),
            (0, a.NC)("Expand Block"),
            (0, a.NC)("Disable Block"),
            (0, a.NC)("Enable Block"),
            (0, a.NC)("Download Block"),
          ],
          X = () => (0, a.NC)("Delete Block"),
          Z = () => (0, a.NC)("Delete All Blocks"),
          J = function (e) {
            let t =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : [];
            [q(), ...t].forEach((t) => {
              e.push({
                text: t.text,
                enabled: t.enabled,
                callback: t.callback,
              });
            });
            for (let t = 0; t < e.length; t++) {
              var i, o;
              let s =
                null === (o = e[t]) || void 0 === o
                  ? void 0
                  : null === (i = o.text) || void 0 === i
                  ? void 0
                  : i.toLowerCase();
              if (null == s ? void 0 : s.includes("delete"))
                s.includes("block") && !s.includes("blocks")
                  ? (e[t].text = X())
                  : (e[t].text = Z());
              else {
                let i = (0, a.NC)(e[t].text);
                K().includes(i) && (e[t].text = i);
              }
            }
          },
          Q = (e) => {
            if (!e) return "invalid_input";
            try {
              let t = Function(`return ${e.trim()}`)();
              return isNaN(t) ? "invalid_input" : t;
            } catch (e) {
              return "invalid_input";
            }
          },
          ee = (e) => {
            try {
              var t, i;
              if (
                !(null == e ? void 0 : e.collapsed_) ||
                (null == e ? void 0 : e.getField(e.type))
              )
                return;
              let [o, s] =
                  (null == e
                    ? void 0
                    : null === (i = e.inputList) || void 0 === i
                    ? void 0
                    : null === (t = i[0]) || void 0 === t
                    ? void 0
                    : t.fieldRow.map((e) => e.value_)) || [],
                r =
                  null == e
                    ? void 0
                    : e.getField(Blockly.constants.COLLAPSED_FIELD_NAME),
                n =
                  null == e
                    ? void 0
                    : e.getInput(Blockly.constants.COLLAPSED_INPUT_NAME);
              if (n && r) {
                n.appendField(new Blockly.FieldImage(o, 25, 25, "", "")),
                  n.appendField(
                    new Blockly.FieldLabel(
                      s,
                      "blocklyTextRootBlockHeaderCollapsed"
                    )
                  );
                let t = `${
                    null == e ? void 0 : e.workspace.options.pathToMedia
                  }dropdown-arrow.svg`,
                  i = new Blockly.FieldImage(
                    t,
                    16,
                    16,
                    (0, a.NC)("Collapsed"),
                    () => (null == e ? void 0 : e.setCollapsed(!1))
                  );
                n.appendField(i, e.type),
                  (n.sourceBlock.width = 300),
                  r.setVisible(!1);
              }
            } catch (e) {
              u.P.emit("ui.log.error", e);
            }
          },
          et = (e) => {
            let t = e.getInput("_TEMP_COLLAPSED_INPUT");
            if (t && e.collapsed_ && !t.icon_added) {
              var i;
              t.icon_added = !0;
              let o = `${e.workspace.options.pathToMedia}dropdown-arrow.svg`,
                s = new Blockly.FieldImage(
                  o,
                  16,
                  16,
                  (0, a.NC)("Collapsed"),
                  () => e.setCollapsed(!1)
                ),
                r = e.getFieldValue("NAME"),
                n = ` (${
                  null == e
                    ? void 0
                    : null === (i = e.arguments) || void 0 === i
                    ? void 0
                    : i.join(", ")
                })`;
              t
                .appendField(new Blockly.FieldLabel((0, a.NC)("function"), ""))
                .appendField(new Blockly.FieldLabel(r + n, "header__title"))
                .appendField(s),
                ((e) => {
                  var t, i;
                  let o = e.fieldRow;
                  null === (t = o[0]) || void 0 === t || t.setVisible(!1),
                    null === (i = o[0]) || void 0 === i || i.forceRerender();
                })(t);
            }
          },
          ei = (e) => {
            let t = e.getField("CURRENCY_LIST"),
              { currency: i } = g.Z.instance.client;
            null == t || t.setValue((0, r.O$T)(i));
          };
      },
      87911: function (e, t, i) {
        "use strict";
        i.d(t, { Z: () => l });
        var o = i(27412),
          s = i(48059),
          r = i(47962),
          a = i(29265),
          n = i(83241);
        class l {
          async retrieveActiveSymbols() {
            let e =
              arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
            return (
              (await this.trading_times.initialise(), !e && this.is_initialised)
                ? await this.init_promise
                : ((this.is_initialised = !0),
                  n.D.has_active_symbols || (await n.D.active_symbols_promise),
                  (this.active_symbols =
                    (null === n.D || void 0 === n.D
                      ? void 0
                      : n.D.active_symbols) ?? []),
                  (this.processed_symbols = this.processActiveSymbols()),
                  (this.trading_times.onMarketOpenCloseChanged = (e) => {
                    Object.keys(e).forEach((t) => {
                      let i = this.active_symbols[t];
                      i && (i.exchange_is_open = e[t]);
                    }),
                      (this.changes = e),
                      this.processActiveSymbols();
                  }),
                  this.init_promise.resolve()),
              this.active_symbols
            );
          }
          processActiveSymbols() {
            return this.active_symbols.reduce((e, t) => {
              if (
                (0, r.v)().DISABLED_SYMBOLS.includes(t.symbol) ||
                (0, r.v)().DISABLED_SUBMARKETS.includes(t.submarket)
              )
                return e;
              let i = (e, i) =>
                -1 !== Object.keys(e).findIndex((e) => e === t[i]);
              i(e, "market") ||
                (e[t.market] = {
                  display_name: t.market_display_name,
                  submarkets: {},
                });
              let { submarkets: o } = e[t.market];
              i(o, "submarket") ||
                (o[t.submarket] = {
                  display_name: t.submarket_display_name,
                  symbols: {},
                });
              let { symbols: s } = o[t.submarket];
              return (
                i(s, "symbol") ||
                  (s[t.symbol] = {
                    display_name: t.display_name,
                    pip_size: `${t.pip}`.length - 2,
                    is_active: !t.is_trading_suspended && t.exchange_is_open,
                  }),
                e
              );
            }, {});
          }
          getAllSymbols() {
            let e =
                arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
              t = [];
            return (
              Object.keys(this.processed_symbols).forEach((i) => {
                if (e && this.isMarketClosed(i)) return;
                let o = this.processed_symbols[i],
                  { submarkets: s } = o;
                Object.keys(s).forEach((e) => {
                  let r = s[e],
                    { symbols: a } = r;
                  Object.keys(a).forEach((s) => {
                    let n = a[s];
                    t.push({
                      market: i,
                      market_display: o.display_name,
                      submarket: e,
                      submarket_display: r.display_name,
                      symbol: s,
                      symbol_display: n.display_name,
                    });
                  });
                });
              }),
              this.getSymbolsForBot(),
              t
            );
          }
          getSymbolsForBot() {
            let { DISABLED: e } = (0, r.v)().QUICK_STRATEGY,
              t = [];
            return (
              Object.keys(this.processed_symbols).forEach((i) => {
                if (this.isMarketClosed(i)) return;
                let { submarkets: o } = this.processed_symbols[i];
                Object.keys(o).forEach((i) => {
                  if (e.SUBMARKETS.includes(i)) return;
                  let s = o[i],
                    { symbols: r } = s;
                  Object.keys(r).forEach((i) => {
                    if (e.SYMBOLS.includes(i)) return;
                    let o = r[i];
                    t.push({
                      group: s.display_name,
                      text: o.display_name,
                      value: i,
                    });
                  });
                });
              }),
              t
            );
          }
          getMarketDropdownOptions() {
            let e = [];
            if (
              (Object.keys(this.processed_symbols).forEach((t) => {
                let { display_name: i } = this.processed_symbols[t],
                  o =
                    i +
                    (this.isMarketClosed(t) ? ` ${(0, s.NC)("(Closed)")}` : "");
                e.push([o, t]);
              }),
              0 === e.length)
            )
              return (0, r.v)().NOT_AVAILABLE_DROPDOWN_OPTIONS;
            if (
              (e.sort((e) => ("synthetic_index" === e[1] ? -1 : 1)),
              e.some((e) => this.isMarketClosed(e[1])))
            ) {
              let t = this.sortDropdownOptions(e, this.isMarketClosed);
              return this.isMarketClosed("forex")
                ? t.sort((e) => ("synthetic_index" === e[1] ? -1 : 1))
                : t;
            }
            return e;
          }
          getSubmarketDropdownOptions(e) {
            let t = [],
              i = this.processed_symbols[e];
            if (i) {
              let { submarkets: e } = i;
              Object.keys(e).forEach((i) => {
                let { display_name: o } = e[i],
                  r =
                    o +
                    (this.isSubmarketClosed(i)
                      ? ` ${(0, s.NC)("(Closed)")}`
                      : "");
                t.push([r, i]);
              });
            }
            return 0 === t.length
              ? (0, r.v)().NOT_AVAILABLE_DROPDOWN_OPTIONS
              : ("synthetic_index" === e &&
                  t.sort((e) => ("random_index" === e[1] ? -1 : 1)),
                this.sortDropdownOptions(t, this.isSubmarketClosed));
          }
          getSymbolDropdownOptions(e) {
            let t = Object.keys(this.processed_symbols).reduce((t, i) => {
              let { submarkets: o } = this.processed_symbols[i];
              return (
                Object.keys(o).forEach((i) => {
                  if (i === e) {
                    let { symbols: e } = o[i];
                    Object.keys(e).forEach((i) => {
                      let { display_name: o } = e[i],
                        r =
                          o +
                          (this.isSymbolClosed(i)
                            ? ` ${(0, s.NC)("(Closed)")}`
                            : "");
                      t.push([r, i]);
                    });
                  }
                }),
                t
              );
            }, []);
            return 0 === t.length
              ? (0, r.v)().NOT_AVAILABLE_DROPDOWN_OPTIONS
              : this.sortDropdownOptions(t, this.isSymbolClosed);
          }
          isMarketClosed(e) {
            let t = this.processed_symbols[e];
            return (
              !t ||
              Object.keys(t.submarkets).every((e) => this.isSubmarketClosed(e))
            );
          }
          isSubmarketClosed(e) {
            let t = Object.keys(this.processed_symbols).find((t) =>
              Object.keys(this.processed_symbols[t].submarkets).includes(e)
            );
            if (!t) return !0;
            let i = this.processed_symbols[t].submarkets[e];
            if (!i) return !0;
            let { symbols: o } = i;
            return Object.keys(o).every((e) => this.isSymbolClosed(e));
          }
          isSymbolClosed(e) {
            return this.active_symbols.some(
              (t) =>
                t.symbol === e &&
                (!t.exchange_is_open || t.is_trading_suspended)
            );
          }
          constructor(e) {
            (0, o._)(this, "sortDropdownOptions", (e, t) => {
              let i = [...e];
              return (
                i.sort((e, i) => {
                  let o = t.call(this, e[1]),
                    s = t.call(this, i[1]);
                  return o && !s ? 1 : o === s ? 0 : -1;
                }),
                i
              );
            }),
              (this.active_symbols = []),
              (this.disabled_symbols = (0, r.v)().DISABLED_SYMBOLS),
              (this.disabled_submarkets = (0, r.v)().DISABLED_SUBMARKETS),
              (this.init_promise = new a.Z()),
              (this.is_initialised = !1),
              (this.processed_symbols = {}),
              (this.trading_times = e);
          }
        }
      },
      83241: function (e, t, i) {
        "use strict";
        i.d(t, { D: () => d });
        var o = i(27412),
          s = i(65464),
          r = i(39338),
          a = i(89064),
          n = i(13604),
          l = i(87383);
        let c = new (class {
            onsocketclose() {
              this.reconnectIfNotConnected();
            }
            getTime() {
              this.time_interval ||
                (this.time_interval = setInterval(() => {
                  this.api.send({ time: 1 });
                }, 3e4));
            }
            constructor() {
              var e = this;
              (0, o._)(this, "api", void 0),
                (0, o._)(this, "init", async function () {
                  let t =
                    arguments.length > 0 &&
                    void 0 !== arguments[0] &&
                    arguments[0];
                  if (!e.api || t) {
                    var i, o;
                    (null === (i = e.api) || void 0 === i
                      ? void 0
                      : i.connection) &&
                      (e.api.disconnect(),
                      e.api.connection.removeEventListener(
                        "close",
                        e.onsocketclose.bind(e)
                      )),
                      (e.api = await (0, l.wL)()),
                      null === (o = e.api) ||
                        void 0 === o ||
                        o.connection.addEventListener(
                          "close",
                          e.onsocketclose.bind(e)
                        );
                  }
                  (0, l.Ke)() && (await e.api.authorize((0, l.LP)().token)),
                    e.getTime();
                }),
                (0, o._)(this, "reconnectIfNotConnected", () => {
                  var e, t, i, o, s, r;
                  console.log(
                    "chart connection state: ",
                    null === (t = this.api) || void 0 === t
                      ? void 0
                      : null === (e = t.connection) || void 0 === e
                      ? void 0
                      : e.readyState
                  ),
                    (null === (o = this.api) || void 0 === o
                      ? void 0
                      : null === (i = o.connection) || void 0 === i
                      ? void 0
                      : i.readyState) &&
                      (null === (r = this.api) || void 0 === r
                        ? void 0
                        : null === (s = r.connection) || void 0 === s
                        ? void 0
                        : s.readyState) > 1 &&
                      (console.log(
                        "Info: Chart connection to the server was closed, trying to reconnect."
                      ),
                      this.init(!0));
                });
            }
          })(),
          d = new (class {
            onsocketopen() {
              (0, a.bl)(a.cR.OPENED);
            }
            onsocketclose() {
              (0, a.bl)(a.cR.CLOSED), this.reconnectIfNotConnected();
            }
            async init() {
              var e, t, i, o;
              let s =
                arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
              this.toggleRunButton(!0),
                this.api && this.unsubscribeAllSubscriptions(),
                (!this.api ||
                  (null === (e = this.api) || void 0 === e
                    ? void 0
                    : e.connection.readyState) !== 1 ||
                  s) &&
                  ((null === (t = this.api) || void 0 === t
                    ? void 0
                    : t.connection) &&
                    (n.Z.disposeInstance(),
                    (0, a.bl)(a.cR.CLOSED),
                    this.api.disconnect(),
                    this.api.connection.removeEventListener(
                      "open",
                      this.onsocketopen.bind(this)
                    ),
                    this.api.connection.removeEventListener(
                      "close",
                      this.onsocketclose.bind(this)
                    )),
                  (this.api = (0, l.wL)()),
                  null === (i = this.api) ||
                    void 0 === i ||
                    i.connection.addEventListener(
                      "open",
                      this.onsocketopen.bind(this)
                    ),
                  null === (o = this.api) ||
                    void 0 === o ||
                    o.connection.addEventListener(
                      "close",
                      this.onsocketclose.bind(this)
                    )),
                this.has_active_symbols ||
                  (0, l.PO)() ||
                  (this.active_symbols_promise = this.getActiveSymbols()),
                this.initEventListeners(),
                this.time_interval && clearInterval(this.time_interval),
                (this.time_interval = null),
                (0, l.PO)() &&
                  ((0, a.UM)(!0), await this.authorizeAndSubscribe()),
                c.init(s);
            }
            getConnectionStatus() {
              var e;
              if (
                null === (e = this.api) || void 0 === e ? void 0 : e.connection
              ) {
                let e = this.api.connection.readyState;
                return r.Px[e] || "Unknown";
              }
              return "Socket not initialized";
            }
            terminate() {
              this.api && this.api.disconnect();
            }
            initEventListeners() {
              window &&
                (window.addEventListener(
                  "online",
                  this.reconnectIfNotConnected
                ),
                window.addEventListener("focus", this.reconnectIfNotConnected));
            }
            async createNewInstance(e) {
              this.account_id !== e && (await this.init());
            }
            async authorizeAndSubscribe() {
              let e = (0, l.PO)();
              if (e) {
                if (
                  ((this.token = e),
                  (this.account_id = (0, l.Bc)() ?? ""),
                  !this.api)
                )
                  return;
                try {
                  let { authorize: e, error: t } = await this.api.authorize(
                    this.token
                  );
                  if (t) return t;
                  this.has_active_symbols
                    ? this.toggleRunButton(!1)
                    : (this.active_symbols_promise = this.getActiveSymbols()),
                    (this.account_info = e),
                    (0, a.Ii)(e.account_list),
                    (0, a.A3)(e),
                    (0, a.Zc)(!0),
                    (this.is_authorized = !0),
                    this.subscribe(),
                    this.getSelfExclusion();
                } catch (e) {
                  (this.is_authorized = !1),
                    (0, a.Zc)(!1),
                    s.P.emit("Error", e);
                } finally {
                  (0, a.UM)(!1);
                }
              }
            }
            async getSelfExclusion() {
              this.api &&
                this.is_authorized &&
                (await this.api.getSelfExclusion());
            }
            async subscribe() {
              await Promise.all(
                ["balance", "transaction", "proposal_open_contract"].map((e) =>
                  (0, r.l6)(
                    () => {
                      var t;
                      let i =
                        null === (t = this.api) || void 0 === t
                          ? void 0
                          : t.send({
                              [e]: 1,
                              subscribe: 1,
                              ...("balance" === e ? { account: "all" } : {}),
                            });
                      return i && this.current_auth_subscriptions.push(i), i;
                    },
                    [],
                    this
                  )
                )
              );
            }
            setIsRunning() {
              let e =
                arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
              this.is_running = e;
            }
            pushSubscription(e) {
              this.subscriptions.push(e);
            }
            clearSubscriptions() {
              this.subscriptions.forEach((e) => e.unsubscribe()),
                (this.subscriptions = []),
                (s.P.getState("global_timeouts") ?? []).forEach((e, t) => {
                  clearTimeout(t);
                });
            }
            constructor() {
              (0, o._)(this, "api", null),
                (0, o._)(this, "token", ""),
                (0, o._)(this, "account_id", ""),
                (0, o._)(this, "pip_sizes", {}),
                (0, o._)(this, "account_info", {}),
                (0, o._)(this, "is_running", !1),
                (0, o._)(this, "subscriptions", []),
                (0, o._)(this, "time_interval", null),
                (0, o._)(this, "has_active_symbols", !1),
                (0, o._)(this, "is_stopping", !1),
                (0, o._)(this, "active_symbols", []),
                (0, o._)(this, "current_auth_subscriptions", []),
                (0, o._)(this, "is_authorized", !1),
                (0, o._)(this, "active_symbols_promise", null),
                (0, o._)(this, "common_store", void 0),
                (0, o._)(this, "landing_company", null),
                (0, o._)(this, "unsubscribeAllSubscriptions", () => {
                  var e;
                  null === (e = this.current_auth_subscriptions) ||
                    void 0 === e ||
                    e.forEach((e) => {
                      e.then((e) => {
                        let { subscription: t } = e;
                        if (null == t ? void 0 : t.id) {
                          var i;
                          null === (i = this.api) ||
                            void 0 === i ||
                            i.send({ forget: t.id });
                        }
                      });
                    }),
                    (this.current_auth_subscriptions = []);
                }),
                (0, o._)(this, "reconnectIfNotConnected", () => {
                  var e, t, i, o, s, r;
                  console.log(
                    "connection state: ",
                    null === (t = this.api) || void 0 === t
                      ? void 0
                      : null === (e = t.connection) || void 0 === e
                      ? void 0
                      : e.readyState
                  ),
                    (null === (o = this.api) || void 0 === o
                      ? void 0
                      : null === (i = o.connection) || void 0 === i
                      ? void 0
                      : i.readyState) &&
                      (null === (r = this.api) || void 0 === r
                        ? void 0
                        : null === (s = r.connection) || void 0 === s
                        ? void 0
                        : s.readyState) > 1 &&
                      (console.log(
                        "Info: Connection to the server was closed, trying to reconnect."
                      ),
                      this.init(!0));
                }),
                (0, o._)(this, "getActiveSymbols", async () => {
                  await (0, r.l6)(
                    () => {
                      var e;
                      return null === (e = this.api) || void 0 === e
                        ? void 0
                        : e.send({ active_symbols: "brief" });
                    },
                    [],
                    this
                  ).then((e) => {
                    let { active_symbols: t = [], error: i = {} } = e,
                      o = {};
                    return (
                      t.length && (this.has_active_symbols = !0),
                      t.forEach((e) => {
                        let { symbol: t, pip: i } = e;
                        o[t] = +(+i).toExponential().substring(3);
                      }),
                      (this.pip_sizes = o),
                      this.toggleRunButton(!1),
                      (this.active_symbols = t),
                      t || i
                    );
                  });
                }),
                (0, o._)(this, "toggleRunButton", (e) => {
                  let t = document.querySelector("#db-animation__run-button");
                  t && (t.disabled = e);
                });
            }
          })();
      },
      13604: function (e, t, i) {
        "use strict";
        i.d(t, { Z: () => c });
        var o = i(27412);
        class s {
          getStakePayoutLimits() {
            let e =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : "AUD",
              t =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : "svg",
              i = arguments.length > 2 ? arguments[2] : void 0;
            return this.ws.send({ landing_company_details: t }).then((t) => {
              var o;
              let s =
                null == t
                  ? void 0
                  : null === (o = t.landing_company_details) || void 0 === o
                  ? void 0
                  : o.currency_config[i];
              return s ? s[e] : {};
            });
          }
          constructor(e) {
            this.ws = e.ws;
          }
        }
        var r = i(87911),
          a = i(48867),
          n = i(30231);
        class l {
          static disposeInstance() {
            this.singleton = null;
          }
          static setInstance(e) {
            return this.singleton || (this.singleton = new l(e)), this.instance;
          }
          static get instance() {
            return this.singleton;
          }
          constructor(e) {
            (this.trading_times = new n.Z(e)),
              (this.contracts_for = new a.Z(e)),
              (this.active_symbols = new r.Z(this.trading_times)),
              (this.account_limits = new s(e));
          }
        }
        (0, o._)(l, "singleton", null);
        let c = l;
      },
      87383: function (e, t, i) {
        "use strict";
        i.d(t, {
          Bc: () => _,
          Ke: () => h,
          PO: () => p,
          LP: () => m,
          wL: () => u,
        });
        var o = i(66175),
          s = i(33304),
          r = i(66e3),
          a = i.n(r),
          n = i(48059),
          l = i(27412);
        let c = [
            "active_symbols",
            "authorize",
            "balance",
            "buy",
            "proposal",
            "proposal_open_contract",
            "transaction",
            "ticks_history",
            "history",
          ],
          d = class {
            constructor(e) {
              (0, l._)(this, "getRequestType", (e) => {
                let t;
                return (
                  c.forEach((i) => {
                    i in e && !t && (t = i);
                  }),
                  t
                );
              }),
                (0, l._)(this, "defineMeasure", (e) => {
                  if (e) {
                    let t;
                    return (
                      "history" === e
                        ? (performance.mark("ticks_history_end"),
                          (t = performance.measure(
                            "ticks_history",
                            "ticks_history_start",
                            "ticks_history_end"
                          )))
                        : (performance.mark(`${e}_end`),
                          (t = performance.measure(
                            `${e}`,
                            `${e}_start`,
                            `${e}_end`
                          ))),
                      (t.startTimeDate = new Date(Date.now() - t.startTime))
                    );
                  }
                  return !1;
                }),
                (0, l._)(this, "sendIsCalled", (e) => {
                  let {
                      response_promise: t,
                      args: [i],
                    } = e,
                    o = this.getRequestType(i);
                  return (
                    o && performance.mark(`${o}_start`),
                    t
                      .then((e) => {
                        let t = this.getRequestType(e);
                        t && this.defineMeasure(t);
                      })
                      .catch(() => {}),
                    t
                  );
                }),
                (this.config = e),
                (this.debounced_calls = {});
            }
          },
          u = () => {
            var e, t;
            let i = (0, o.wmM)().replace(/[^a-zA-Z0-9.]/g, ""),
              r =
                (null === (t = (0, o.rhL)()) || void 0 === t
                  ? void 0
                  : null === (e = t.replace) || void 0 === e
                  ? void 0
                  : e.call(t, /[^a-zA-Z0-9]/g, "")) ?? (0, o.rhL)(),
              l = new WebSocket(
                `wss://${i}/websockets/v3?app_id=${r}&l=${(0,
                n.Jb)()}&brand=${s.F0.toLowerCase()}`
              );
            return new (a())({ connection: l, middleware: new d({}) });
          },
          h = () => {
            let e = localStorage.getItem("active_loginid");
            return e && "null" !== e ? e : null;
          },
          p = () => {
            let e = localStorage.getItem("authToken");
            return e && "null" !== e ? e : null;
          },
          _ = () => {
            let e = p();
            if (!e) return null;
            let t = JSON.parse(localStorage.getItem("accountsList"));
            return t && "null" !== t
              ? Object.keys(t).find((i) => t[i] === e)
              : null;
          },
          m = () => {
            let e = h(),
              t = JSON.parse(localStorage.getItem("accountsList")) ?? void 0;
            return {
              token: ((t && t[e]) || {}) ?? void 0,
              account_id: e ?? void 0,
            };
          };
      },
      48867: function (e, t, i) {
        "use strict";
        i.d(t, { Z: () => n });
        var o = i(27412),
          s = i(47962),
          r = i(29265),
          a = i(83241);
        class n {
          async getBarriers(e, t, i, o) {
            let r = { values: [] };
            if (!(0, s.v)().BARRIER_TRADE_TYPES.includes(t)) return r;
            let a = ["high_barrier", "low_barrier"],
              n = await this.getContractsByTradeType(e, t),
              l = await this.getDurations(e, t, !1),
              c = /^[-|+]([0-9]+.[0-9]+)$/,
              d = (e) => e && c.test(e.toString()),
              u = !0;
            return (
              n.length > 0 &&
                (o.forEach((e, h) => {
                  let p = ["+", "-"].includes(e),
                    _ = this.getContractCategoryByTradeType(t),
                    m = n.find((e) => {
                      let { BARRIER_CATEGORIES: o } = (0, s.v)(),
                        r = Object.keys(o).find((e) => o[e].includes(t)),
                        n = e.contract_category === _,
                        c = -1 !== l.findIndex((e) => e.unit === i),
                        u = e.barrier_category === r,
                        m =
                          (p && d(e.barrier || e[a[h]])) ||
                          (!p && !d(e.barrier || e[a[h]]));
                      return n && c && u && m;
                    });
                  if (
                    (!m &&
                      (m = n
                        .filter((e) => e.barrier || e.high_barrier)
                        .sort((e, t) => {
                          let i = e.barrier || e.high_barrier,
                            o = t.barrier || t.high_barrier;
                          return parseFloat(i) - parseFloat(o);
                        })
                        .shift()) &&
                      !p &&
                      (u = !1),
                    m)
                  ) {
                    let t = 1 === m.barriers ? "barrier" : a[h];
                    if (m[t]) {
                      let e = `${m[t]}`.match(c);
                      r.values[h] = e ? e[1] : m[t];
                    }
                    Object.assign(r, {
                      allow_both_types:
                        ["intraday", "tick"].includes(m.expiry_type) && d(m[t]),
                      allow_absolute_type: "absolute" === e && !d(m[t]),
                    }),
                      1 === m.barriers && o.splice(h + 1, 1);
                  }
                }),
                u
                  ? 2 === r.values.length &&
                    o.every((e) => e === o[0]) &&
                    r.values.every((e) => e === r.values[0]) &&
                    (r.values[1] = (0.95 * r.values[0]).toFixed(1))
                  : (r.values = r.values.map(() => !1))),
              r
            );
          }
          getContractCategoryByTradeType(e) {
            let { TRADE_TYPE_TO_CONTRACT_CATEGORY_MAPPING: t } = (0, s.v)();
            return Object.keys(t).find((i) => t[i].includes(e)) || e;
          }
          getTradeTypeCategoryByTradeType(e) {
            let { TRADE_TYPE_CATEGORIES: t } = (0, s.v)();
            return Object.keys(t).find((i) => t[i].includes(e)) || e;
          }
          getTradeTypeCategoryNameByTradeType(e) {
            let { TRADE_TYPE_CATEGORY_NAMES: t } = (0, s.v)();
            return t[this.getTradeTypeCategoryByTradeType(e)];
          }
          getBarrierCategoryByTradeType(e) {
            let { BARRIER_CATEGORIES: t } = (0, s.v)();
            return Object.keys(t).find((i) => t[i].includes(e));
          }
          async getContractsByTradeType(e, t) {
            let i = await this.getContractsFor(e),
              o = this.getContractCategoryByTradeType(t),
              s = this.getBarrierCategoryByTradeType(t);
            return i.filter((e) => {
              let t = e.contract_category === o,
                i = e.barrier_category === s;
              return t && i;
            });
          }
          async getContractsFor(e) {
            if (!e || "na" === e) return [];
            let t = async () => {
              if (this.retrieving_contracts_for[e])
                return (
                  await this.retrieving_contracts_for[e],
                  this.contracts_for[e].contracts
                );
              this.retrieving_contracts_for[e] = new r.Z();
              let t = await a.D.api.send({ contracts_for: e });
              if (t.error) return [];
              let {
                  contracts_for: { available: i },
                } = t,
                o = i.filter((e) => "forward" !== e.start_type);
              return (
                (this.contracts_for[e] = {
                  contracts: o,
                  timestamp: this.server_time.unix(),
                }),
                this.retrieving_contracts_for[e].resolve(),
                delete this.retrieving_contracts_for[e],
                o
              );
            };
            if (this.contracts_for[e]) {
              let { contracts: i, timestamp: o } = this.contracts_for[e];
              return (
                this.server_time.unix() - o > 60 * this.cache_age_in_min && t(),
                i
              );
            }
            return t();
          }
          async getDurations(e, t) {
            let i =
              !(arguments.length > 2) ||
              void 0 === arguments[2] ||
              arguments[2];
            if ("multiplier" === t || "accumulator" === t) return [];
            let o = await this.getContractsFor(e),
              {
                NOT_AVAILABLE_DURATIONS: r,
                DEFAULT_DURATION_DROPDOWN_OPTIONS: a,
              } = (0, s.v)();
            if (0 === o.length) return r;
            let n = await this.getContractsByTradeType(e, t),
              l = [],
              c = (e) => a.findIndex((t) => t[1] === e.replace(/\d+/g, "")),
              d = (e, t) => {
                let i = e.replace(/\D/g, ""),
                  o = c(e),
                  s = a.findIndex((e) => e[1] === t),
                  r = parseInt(i);
                return (
                  a
                    .slice(s + 1, o + 1)
                    .reverse()
                    .forEach((e) => {
                      switch (e[1]) {
                        case "m":
                        case "h":
                          r *= 60;
                          break;
                        case "d":
                          r *= 24;
                      }
                    }),
                  r
                );
              };
            if (
              (n.forEach((e) => {
                if (!e.min_contract_duration || !e.max_contract_duration)
                  return;
                let t = c(e.min_contract_duration),
                  o = c(
                    "1d" === e.max_contract_duration && i
                      ? "24h"
                      : e.max_contract_duration
                  );
                a.slice(t, o + 1).forEach((t, i) => {
                  -1 === l.findIndex((e) => e.unit === t[1]) &&
                    l.push({
                      display: t[0],
                      unit: t[1],
                      min:
                        0 === i
                          ? parseInt(e.min_contract_duration.replace(/\D/g, ""))
                          : 1,
                      max: d(e.max_contract_duration, t[1]),
                    });
                });
              }),
              n.every((e) => "intraday" === e.expiry_type))
            ) {
              let e = l.findIndex((e) => "d" === e[1]);
              -1 !== e && l.splice(e, 1);
            }
            return 0 === l.length ? r : l.sort((e, t) => c(e.unit) - c(t.unit));
          }
          async getPredictionRange(e, t) {
            let i = await this.getContractsByTradeType(e, t),
              o = this.getContractCategoryByTradeType(t),
              r = [],
              { DIGIT_CATEGORIES: a, opposites: n } = (0, s.v)();
            if (a.includes(o) && "evenodd" !== t) {
              let e = i.find((e) =>
                Object.keys(n).some((t) =>
                  n[t].map((e) => Object.keys(e)[0]).includes(e.contract_type)
                )
              );
              e && e.last_digit_range
                ? r.push(...e.last_digit_range)
                : r.push(1, 2, 3, 4, 5, 6, 7, 8);
            }
            return r;
          }
          async getMultiplierRange(e, t) {
            let i = await this.getContractsByTradeType(e, t),
              o = [],
              { opposites: r } = (0, s.v)(),
              a = i.find((e) =>
                Object.keys(r).some((t) =>
                  r[t].map((e) => Object.keys(e)[0]).includes(e.contract_type)
                )
              );
            return (
              (null == a ? void 0 : a.multiplier_range) &&
                o.push(...a.multiplier_range),
              o
            );
          }
          async getMarketBySymbol(e) {
            let t = await this.getContractsFor(e);
            return t.length ? t[0].market : "na";
          }
          async getSubmarketBySymbol(e) {
            let t = await this.getContractsFor(e);
            return t.length ? t[0].submarket : "na";
          }
          async getGroupedTradeTypes(e) {
            let t = await this.getContractsFor(e),
              i = {};
            for (let o = 0; o < t.length; o++) {
              let s = t[o].market,
                r = t[o].submarket,
                a = this.getTradeTypeCategoryByTradeType(
                  t[o].contract_category
                ),
                n = this.getTradeTypeCategoryNameByTradeType(
                  t[o].contract_category
                ),
                l = await this.getTradeTypeByTradeCategory(s, r, e, a);
              n &&
                !this.isDisabledOption({
                  market: s,
                  submarket: r,
                  symbol: e,
                  trade_type_category: a,
                }) &&
                (i[n] = l);
            }
            return i;
          }
          async getTradeTypeByTradeCategory(e, t, i, o) {
            let {
                NOT_AVAILABLE_DURATIONS: r,
                TRADE_TYPE_CATEGORIES: a,
                opposites: n,
              } = (0, s.v)(),
              l = a[o],
              c = [];
            if (l && l.length)
              for (let s = 0; s < l.length; s++) {
                let a = l[s],
                  d =
                    JSON.stringify(await this.getDurations(i, a)) !==
                    JSON.stringify(r);
                if (
                  !this.isDisabledOption({
                    market: e,
                    submarket: t,
                    symbol: i,
                    trade_type_category: o,
                    trade_type: a,
                  }) &&
                  d
                ) {
                  let e = n[a.toUpperCase()],
                    t = [],
                    i = [];
                  e.forEach((e) => {
                    t.push(Object.keys(e)[0]), i.push(Object.values(e)[0]);
                  }),
                    c.push({ name: i.join("/"), value: a, icon: t });
                }
              }
            return c;
          }
          async getTradeTypesForQuickStrategy(e) {
            let t =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : "",
              i = [],
              o = [];
            if ("ACCU" === t) return i.push({ text: "Buy", value: "ACCU" }), i;
            let s = await this.getMarketBySymbol(e),
              r = await this.getSubmarketBySymbol(e),
              a = await this.getTradeTypeCategories(s, r, e);
            for (let t = 0; t < a.length; t++) {
              let i = a[t],
                n = await this.getTradeTypeByTradeCategory(s, r, e, i[1]);
              this.getHiddenCategories(n) < n.length && o.push(i);
            }
            for (let t = 0; t < o.length; t++) {
              let a = o[t],
                n = await this.getTradeTypeByTradeCategory(s, r, e, a[1]);
              i.push(...this.getTradeTypeOptions(n, a));
            }
            return i;
          }
          async getTradeTypeCategories(e, t, i) {
            let {
                TRADE_TYPE_CATEGORY_NAMES: o,
                NOT_AVAILABLE_DROPDOWN_OPTIONS: r,
              } = (0, s.v)(),
              a = await this.getContractsFor(i),
              n = [];
            if (
              (a.forEach((o) => {
                let s = this.getTradeTypeCategoryByTradeType(
                    o.contract_category
                  ),
                  r = this.getTradeTypeCategoryNameByTradeType(
                    o.contract_category
                  );
                r &&
                  !this.isDisabledOption({
                    market: e,
                    submarket: t,
                    symbol: i,
                    trade_type_category: s,
                  }) &&
                  -1 === n.findIndex((e) => e[1] === s) &&
                  n.push([r, s]);
              }),
              n.length > 0)
            ) {
              let e = Object.keys(o);
              return n.sort(
                (t, i) =>
                  e.findIndex((e) => e === t[1]) -
                  e.findIndex((e) => e === i[1])
              );
            }
            return r;
          }
          async getTradeTypes(e, t, i, o) {
            let {
                NOT_AVAILABLE_DURATIONS: r,
                TRADE_TYPE_CATEGORIES: a,
                opposites: n,
              } = (0, s.v)(),
              l = [],
              c = a[o];
            if (c)
              for (let s = 0; s < c.length; s++) {
                let a = c[s],
                  d =
                    JSON.stringify(await this.getDurations(i, a)) !==
                    JSON.stringify(r);
                if (
                  !this.isDisabledOption({
                    market: e,
                    submarket: t,
                    symbol: i,
                    trade_type_category: o,
                    trade_type: a,
                  }) &&
                  d
                ) {
                  let e = n[a.toUpperCase()];
                  l.push([e.map((e) => e[Object.keys(e)[0]]).join("/"), a]);
                }
              }
            return l.length > 0 ? l : (0, s.v)().NOT_AVAILABLE_DROPDOWN_OPTIONS;
          }
          isDisabledOption(e) {
            return this.disabled_options.some((t) =>
              Object.keys(t).every((i) => e[i] === t[i])
            );
          }
          disposeCache() {
            this.contracts_for = {};
          }
          constructor({ ws: e, server_time: t }) {
            (0, o._)(this, "getAccumulationRange", async () => [
              0.01, 0.02, 0.03, 0.04, 0.05,
            ]),
              (0, o._)(this, "getHiddenCategories", (e) => {
                let t = 0;
                for (let i = 0; i < e.length; i++) {
                  let o = e[i],
                    r = (0,
                    s.v)().QUICK_STRATEGY.DISABLED.BARRIER_TRADE_TYPES.includes(
                      o.value
                    ),
                    a = (0,
                    s.v)().QUICK_STRATEGY.DISABLED.PREDICTION_TRADE_TYPES.includes(
                      o.value
                    );
                  (r || a) && t++;
                }
                return t;
              }),
              (0, o._)(this, "getTradeTypeOptions", (e, t) => {
                let i = [];
                return (
                  e.forEach((e) => {
                    let o = (0,
                      s.v)().QUICK_STRATEGY.DISABLED.BARRIER_TRADE_TYPES.includes(
                        e.value
                      ),
                      r = (0,
                      s.v)().QUICK_STRATEGY.DISABLED.PREDICTION_TRADE_TYPES.includes(
                        e.value
                      ),
                      a = ["multiplier"].includes(e.value);
                    o ||
                      r ||
                      a ||
                      i.push({
                        text: e.name,
                        value: e.value,
                        group: t[0],
                        icon: e.icon,
                      });
                  }),
                  i
                );
              }),
              (0, o._)(this, "getContractTypes", (e) => {
                let { opposites: t } = (0, s.v)(),
                  i = e;
                return (
                  "ACCU" === i && (i = "accumulator"),
                  t[i.toUpperCase()].map((e) => ({
                    value: Object.keys(e)[0],
                    text: Object.values(e)[0],
                  }))
                );
              }),
              (this.cache_age_in_min = 10),
              (this.contracts_for = {}),
              (this.ws = e),
              (this.server_time = t),
              (this.disabled_options = [
                { submarket: "forex_basket", trade_type: "higherlower" },
                { submarket: "minor_pairs", trade_type: "higherlower" },
                { submarket: "metals", trade_type: "callputequal" },
                { market: "indices", trade_type: "callputequal" },
                { symbol: "OTC_AS51", trade_type_category: "inout" },
                { trade_type_category: "lookback" },
                { trade_type_category: "callputspread" },
              ]),
              (this.retrieving_contracts_for = {});
          }
        }
      },
      5046: function (e, t, i) {
        "use strict";
        i.d(t, {
          DO: () => s.D,
          tI: () => d.Z,
          HP: () => a.Z,
          E9: () => o.Z,
          YS: () => n,
          Xc: () => c,
          ST: () => r.Z,
        });
        var o = i(87911),
          s = i(83241),
          r = i(13604),
          a = i(48867);
        class n {
          addEvents() {
            "onLine" in navigator
              ? (window.addEventListener("online", () => this.setStatus()),
                window.addEventListener("offline", () => this.setStatus()))
              : ((navigator.onLine = !0),
                setInterval(() => this.setStatus(), 1e4)),
              this.setStatus();
          }
          setStatus() {
            navigator.onLine
              ? (this.parentElement.html("<span class='connecting'></span>"),
                this.api.send({ ping: "1" }).then(() => {
                  this.parentElement.html("<span class='online'></span>");
                }))
              : this.parentElement.html("<span class='offline'></span>");
          }
          constructor(e, t) {
            (this.api = e), (this.parentElement = t), this.addEvents();
          }
        }
        var l = i(29265);
        let c = (() => {
          let e,
            t = !1,
            i = new l.Z();
          return {
            init: (o) => {
              t || ((e = o), i.resolve(e.server_time), (t = !0));
            },
            get: () => (t && e.server_time ? e.server_time.clone() : void 0),
            timePromise: () => (t ? Promise.resolve(e.server_time) : i.promise),
          };
        })();
        var d = i(30231);
      },
      89064: function (e, t, i) {
        "use strict";
        i.d(t, {
          A3: () => m,
          C9: () => n,
          FT: () => d,
          IS: () => a,
          Ii: () => _,
          Nf: () => l,
          UM: () => p,
          Zc: () => h,
          ao: () => c,
          bl: () => u,
          cR: () => r,
        });
        var o,
          s = i(57090),
          r =
            (((o = {}).OPENED = "opened"),
            (o.CLOSED = "closed"),
            (o.UNKNOWN = "unknown"),
            o);
        let a = new s.X("unknown"),
          n = new s.X(!1),
          l = new s.X(!1),
          c = new s.X([]),
          d = new s.X(null),
          u = (e) => {
            a.next(e);
          },
          h = (e) => {
            l.next(e);
          },
          p = (e) => {
            n.next(e);
          },
          _ = (e) => {
            c.next(e);
          },
          m = (e) => {
            (null == e ? void 0 : e.loginid) &&
              localStorage.setItem("active_loginid", e.loginid),
              d.next(e);
          };
      },
      30231: function (e, t, i) {
        "use strict";
        i.d(t, { Z: () => s });
        var o = i(29265);
        class s {
          async initialise() {
            if (this.is_initialised) return this.init_promise;
            if (
              ((this.is_initialised = !0),
              (this.last_update_moment = this.server_time.local()),
              !Object.keys(this.trading_times).length)
            ) {
              await this.updateTradingTimes(), this.init_promise.resolve();
              let e = async () => {
                let t = this.updateMarketOpenClosed();
                Object.keys(t).length > 0 &&
                  this.onMarketOpenCloseChanged &&
                  this.onMarketOpenCloseChanged(t);
                let i = this.nextUpdateDate();
                if (!i) {
                  let e = this.server_time.local(),
                    t = this.last_update_moment.clone().add(1, "days");
                  e.isAfter(t)
                    ? (this.last_update_moment = e.clone())
                    : (this.last_update_moment = t.clone());
                  let o = {};
                  Object.keys(this.trading_times).forEach((e) => {
                    o[e] = this.trading_times[e].is_opened;
                  }),
                    await this.updateTradingTimes(),
                    Object.keys(this.trading_times).forEach((e) => {
                      this.trading_times[e].is_opened = o[e];
                    }),
                    t.set({ hour: 0, minute: 0, second: 0 }),
                    (i = t.toDate());
                }
                let o = i - this.server_time.local().toDate();
                this.update_timer = setTimeout(e, o);
              };
              await e();
            }
            return this.init_promise;
          }
          async updateTradingTimes() {
            var e;
            let t = this.last_update_moment.format("YYYY-MM-DD"),
              i = await (null === (e = this.ws) || void 0 === e
                ? void 0
                : e.send({ trading_times: t }));
            if (i.error) return;
            this.trading_times = {};
            let o = this.server_time
                .local()
                .toDate()
                .toISOString()
                .substring(0, 11),
              s = (e) => new Date(`${o}${e}Z`),
              {
                trading_times: { markets: r },
              } = i;
            r &&
              (null == r ||
                r.forEach((e) => {
                  let { submarkets: t } = e;
                  null == t ||
                    t.forEach((e) => {
                      let { symbols: t } = e;
                      null == t ||
                        t.forEach((e) => {
                          let t;
                          let { times: i, symbol: o } = e,
                            { open: r, close: a } = i,
                            n =
                              1 === r.length &&
                              "00:00:00" === r[0] &&
                              "23:59:59" === a[0],
                            l =
                              1 === r.length && "--" === r[0] && "--" === a[0];
                          n ||
                            l ||
                            (t = r.map((e, t) => ({
                              open: s(e),
                              close: s(a[t]),
                            }))),
                            (this.trading_times[o] = {
                              is_open_all_day: n,
                              is_closed_all_day: l,
                              times: t,
                            });
                        });
                    });
                }));
          }
          updateMarketOpenClosed() {
            let e = {};
            return (
              Object.keys(this.trading_times).forEach((t) => {
                let i = this.calcIsMarketOpened(t),
                  o = this.trading_times[t];
                o.is_opened !== i && ((o.is_opened = i), (e[t] = i));
              }),
              e
            );
          }
          calcIsMarketOpened(e) {
            let t = this.server_time.local().unix(),
              {
                times: i,
                is_open_all_day: o,
                is_closed_all_day: s,
              } = this.trading_times[e];
            return (
              !s &&
              (!!o ||
                i.some((e) => {
                  let { open: i, close: o } = e;
                  return t >= i && t < o;
                }))
            );
          }
          nextUpdateDate() {
            let e;
            let t = this.server_time.local().toDate();
            return (
              Object.keys(this.trading_times).forEach((i) => {
                let {
                  times: o,
                  is_open_all_day: s,
                  is_closed_all_day: r,
                } = this.trading_times[i];
                !s &&
                  !r &&
                  o.forEach((i) => {
                    let { open: o, close: s } = i;
                    o > t && (!e || o < e) && (e = o),
                      s > t && (!e || s < e) && (e = s);
                  });
              }),
              e
            );
          }
          isMarketOpened(e) {
            let t = Object.keys(this.trading_times);
            return (
              !!(t.length && t.includes(e)) && this.trading_times[e].is_opened
            );
          }
          constructor({ ws: e, server_time: t }) {
            (this.init_promise = new o.Z()),
              (this.is_initialised = !1),
              (this.trading_times = {}),
              (this.ws = e),
              (this.server_time = t.clone());
          }
        }
      },
      21796: function (e, t, i) {
        "use strict";
        i.d(t, {
          LJ: () => r,
          cM: () => c,
          h4: () => l,
          um: () => n,
          vU: () => d,
          x_: () => a,
        });
        var o = i(47962),
          s = i(65464);
        let r = (e) => s.P.emit("bot.contract", e),
          a = (e) => s.P.emit("contract.status", e),
          n = (e) => s.P.emit("bot.info", e),
          l = (e, t) =>
            s.P.emit("ui.log.notify", {
              className: e,
              message: t,
              sound: (0, o.v)().lists.NOTIFICATION_SOUND[0][1],
            }),
          c = (e, t) => s.P.emit("ui.log.success", { log_type: e, extra: t }),
          d = (e) => s.P.emit("ui.log.error", e);
      },
      39338: function (e, t, i) {
        "use strict";
        i.d(t, {
          Fs: () => v,
          Kn: () => m,
          Mg: () => d,
          Px: () => w,
          VM: () => u,
          l6: () => g,
          mh: () => y,
          nD: () => c,
          pH: () => l,
          vo: () => b,
        });
        var o = i(66175),
          s = i(87920),
          r = i(48059),
          a = i(65464),
          n = i(21796);
        let l = (e, t) =>
            e.contractTypes.map((i) => {
              let s = {
                amount: e.amount,
                basis: e.basis,
                contract_type: i,
                currency: e.currency,
                duration: e.duration,
                duration_unit: e.duration_unit,
                multiplier: e.multiplier,
                passthrough: { contract_type: i, purchase_reference: t },
                proposal: 1,
                symbol: e.symbol,
              };
              return (
                void 0 !== e.prediction && (s.selected_tick = e.prediction),
                ["TICKLOW", "TICKHIGH"].includes(i) || void 0 === e.prediction
                  ? void 0 !== e.barrierOffset && (s.barrier = e.barrierOffset)
                  : (s.barrier = e.prediction),
                void 0 !== e.secondBarrierOffset &&
                  (s.barrier2 = e.secondBarrierOffset),
                ["MULTUP", "MULTDOWN"].includes(i) &&
                  ((s.duration = void 0), (s.duration_unit = void 0)),
                (0, o.Qr$)(e.limit_order) || (s.limit_order = e.limit_order),
                s
              );
            }),
          c = (e, t) => {
            let i = {
              buy: "1",
              price: t.amount,
              parameters: {
                amount: t.amount,
                basis: t.basis,
                contract_type: e,
                currency: t.currency,
                duration: t.duration,
                duration_unit: t.duration_unit,
                multiplier: t.multiplier,
                symbol: t.symbol,
              },
            };
            return (
              void 0 !== t.prediction &&
                (i.parameters.selected_tick = t.prediction),
              ["TICKLOW", "TICKHIGH"].includes(e) || void 0 === t.prediction
                ? void 0 !== t.barrierOffset &&
                  (i.parameters.barrier = t.barrierOffset)
                : (i.parameters.barrier = t.prediction),
              void 0 !== t.secondBarrierOffset &&
                (i.parameters.barrier2 = t.secondBarrierOffset),
              (0, o.Qr$)(t.app_markup_percentage) ||
                (i.parameters.app_markup_percentage = t.app_markup_percentage),
              (0, o.Qr$)(t.barrier_range) ||
                (i.parameters.barrier_range = t.barrier_range),
              (0, o.Qr$)(t.date_expiry) ||
                (i.parameters.date_expiry = t.date_expiry),
              (0, o.Qr$)(t.date_start) ||
                (i.parameters.date_start = t.date_start),
              (0, o.Qr$)(t.product_type) ||
                (i.parameters.product_type = t.product_type),
              (0, o.Qr$)(t.trading_period_start) ||
                (i.parameters.trading_period_start = t.trading_period_start),
              (0, o.Qr$)(t.limit_order) ||
                (i.parameters.limit_order = t.limit_order),
              ["MULTUP", "MULTDOWN"].includes(e) &&
                ((i.parameters.duration = void 0),
                (i.parameters.duration_unit = void 0),
                (i.parameters.multiplier = t.multiplier)),
              ["ACCU"].includes(e) &&
                ((i.parameters.duration = void 0),
                (i.parameters.duration_unit = void 0),
                (i.parameters.growth_rate = t.growth_rate)),
              i
            );
          },
          d = (e) => {
            let { length: t } = e,
              [i, o] = e.slice(-2),
              s = "";
            return (
              t >= 2 &&
                ((s = i.quote < o.quote ? "rise" : s),
                (s = i.quote > o.quote ? "fall" : s)),
              s
            );
          },
          u = (e) => {
            let t = e;
            return (
              "number" == typeof t && (t = String(t)), Number(t[t.length - 1])
            );
          },
          h = (e, t) => {
            let i = Math.min(2.5 * t, 15),
              { error: o = {}, msg_type: a = "", echo_req: l = {} } = e,
              { code: c = "", message: d = "" } = o,
              u = "",
              h = Blockly.derivWorkspace
                .getAllBlocks(!0)
                .find((e) => "trade_definition_tradetype" === e.type),
              p =
                (null == h ? void 0 : h.getFieldValue("TRADETYPECAT_LIST")) ||
                "",
              { TRADE_TYPE_CATEGORY_NAMES: _ } = (0, s.vc)();
            if (c)
              switch (c) {
                case "RateLimit":
                  u = (0, r.NC)(
                    "You are rate limited for: {{ message_type }}, retrying in {{ delay }}s (ID: {{ request }})",
                    {
                      message_type: o.msg_type,
                      delay: i,
                      request: null == l ? void 0 : l.req_id,
                    }
                  );
                  break;
                case "DisconnectError":
                  u = (0, r.NC)(
                    "You are disconnected, retrying in {{ delay }}s",
                    { delay: i }
                  );
                  break;
                case "MarketIsClosed":
                  u = (0, r.NC)("{{ message }}, retrying in {{ delay }}s", {
                    message: d || (0, r.NC)("The market is closed"),
                    delay: i,
                  });
                  break;
                case "OpenPositionLimitExceeded":
                  u = (0, r.NC)(
                    "You already have an open position for {{ trade_type }} contract type, retrying in {{ delay }}s",
                    { delay: i, trade_type: (null == _ ? void 0 : _[p]) ?? "" }
                  );
                  break;
                default:
                  u = (0, r.NC)(
                    "Request failed for: {{ message_type }}, retrying in {{ delay }}s",
                    { message_type: a || (0, r.NC)("unknown"), delay: i }
                  );
              }
            else
              u = (0, r.NC)(
                "Request failed for: {{ message_type }}, retrying in {{ delay }}s",
                { message_type: a || (0, r.NC)("unknown"), delay: i }
              );
            return (0, n.vU)(u), 1e3 * i;
          },
          p = (e) => {
            var t, i, o;
            (null === (t = e.error) || void 0 === t ? void 0 : t.code) ===
              "InputValidationFailed" &&
              ((null === (i = e.error.details) || void 0 === i
                ? void 0
                : i.duration) &&
                (e.error.message = (0, r.NC)(
                  "Duration must be a positive integer"
                )),
              (null === (o = e.error.details) || void 0 === o
                ? void 0
                : o.amount) &&
                (e.error.message = (0, r.NC)(
                  "Amount must be a positive number."
                )));
          },
          _ = function (e) {
            var t, i;
            let o =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : [];
            if (!e.error) return !1;
            p(e);
            let s = o
              .concat([
                "CallError",
                "WrongResponse",
                "GetProposalFailure",
                "RateLimit",
                "DisconnectError",
                "MarketIsClosed",
                "OpenPositionLimitExceeded",
              ])
              .includes(
                (null == e
                  ? void 0
                  : null === (t = e.error) || void 0 === t
                  ? void 0
                  : t.code) ?? (null == e ? void 0 : e.name)
              );
            return (
              (null === (i = e.error) || void 0 === i ? void 0 : i.code) ===
                "OpenPositionLimitExceeded" &&
                a.P.emit("bot.recoverOpenPositionLimitExceeded"),
              !s
            );
          },
          m = (e, t, i, s, r) =>
            new Promise((n, l) => {
              let c = e();
              c
                ? c.then(n).catch((e) => {
                    var n;
                    if (_(e, i) || (r && !r.is_running)) {
                      l(e);
                      return;
                    }
                    t(
                      (null == e
                        ? void 0
                        : null === (n = e.error) || void 0 === n
                        ? void 0
                        : n.code) ?? (null == e ? void 0 : e.name),
                      () =>
                        new Promise((t) => {
                          let i = () => a.P.getState("global_timeouts") ?? [],
                            r = setTimeout(() => {
                              let e = i();
                              delete e[r], a.P.setState(e), t();
                            }, h(e, s)),
                            n = i(),
                            l = (0, o.LI1)(e, "msg_type");
                          (n[r] = {
                            is_cancellable: ["buy"].includes(l),
                            msg_type: l,
                          }),
                            a.P.setState({ global_timeouts: n });
                        })
                    );
                  })
                : n();
            }),
          g = (e, t, i) => {
            let o = 1;
            return new Promise((s, r) => {
              let a = (e, t) => {
                  o++, t().then(n);
                },
                n = () => {
                  m(e, a, t, o, i).then(s).catch(r);
                };
              n();
            });
          },
          y = (e) => {
            let { sell_price: t, buy_price: i, currency: s } = e,
              r = (0, o.bfN)(t - i, s);
            return [
              e.transaction_ids.buy,
              +e.buy_price,
              +e.sell_price,
              r,
              e.contract_type,
              (0, o.mrB)(parseInt(`${e.entry_tick_time}000`), "HH:mm:ss"),
              +e.entry_tick,
              (0, o.mrB)(parseInt(`${e.exit_tick_time}000`), "HH:mm:ss"),
              +e.exit_tick,
              +(e.barrier ? e.barrier : 0),
              r < 0 ? "loss" : "win",
            ];
          },
          v = () => `${new Date().getTime() * Math.random()}`,
          f = (e, t) =>
            t.getAllBlocks().some((t) => t.type === e && !!t.parentBlock_),
          b = () => ({
            has_payout_block: f("payout", window.Blockly.derivWorkspace),
            is_basis_payout: !1,
          }),
          w = {
            [WebSocket.CONNECTING]: "Connecting",
            [WebSocket.OPEN]: "Connected",
            [WebSocket.CLOSING]: "Closing",
            [WebSocket.CLOSED]: "Closed",
          };
      },
      55967: function (e, t, i) {
        "use strict";
        i.d(t, { T: () => r });
        var o = i(48059);
        let s = function (e) {
            let t =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : "workspace";
            return {
              missing: (0, o.NC)(
                "The {{block_type}} block is mandatory and cannot be deleted/disabled.",
                { block_type: e }
              ),
              misplaced: (0, o.NC)(
                "The {{block_type}} block is misplaced from {{missing_space}}.",
                { block_type: e, missing_space: t }
              ),
              disabled: (0, o.NC)(
                "The {{block_type}} block is mandatory and cannot be deleted/disabled.",
                { block_type: e }
              ),
              default: (0, o.NC)(
                "The {{block_type}} block is mandatory and cannot be deleted/disabled.",
                { block_type: e }
              ),
            };
          },
          r = () => ({
            trade_definition: s("Trade parameters"),
            trade_parameters: s("Trade parameters"),
            before_purchase: s("Purchase conditions"),
            purchase_conditions: s("Purchase conditions"),
            purchase: s("Purchase", "purchase conditions"),
            trade_definition_tradeoptions: s(
              "Trade options",
              "trade parameters"
            ),
            trade_definition_multiplier: s(
              "Trade options multipliers",
              "trade parameters"
            ),
            trade_definition_accumulator: s(
              "Trade options accumulators",
              "trade parameters"
            ),
          });
      },
      50043: function (e, t, i) {
        "use strict";
        i.d(t, { N: () => r, T: () => s });
        var o = i(65464);
        let s = (e, t) => {
            let i = Error(t);
            return (i.name = e), (i.code = e), i;
          },
          r = function (e) {
            let t =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : {};
            o.P.emit("ui.log.error", e),
              window.trackJs &&
                trackJs.track(`${e} - Error: ${JSON.stringify(t)}`);
          };
      },
      94576: function (e, t, i) {
        "use strict";
        i.d(t, {
          S3: () => _,
          GZ: () => h,
          Xt: () => g.Xt,
          ZT: () => a,
          Tr: () => l.T,
          dY: () => w,
          WN: () => g.WN,
          Ow: () => o.O,
          VG: () => n,
          N0: () => k.N0,
          Pi: () => d.P,
          X6: () => f,
          l5: () => g.l5,
          tZ: () => p,
          zG: () => y,
          N_: () => l.N,
          Vc: () => m,
          mT: () => v,
          lY: () => g.lY,
        });
        var o = i(8813),
          s = i(48059),
          r = i(47962);
        let a = (e) => {
            let { opposites: t } = (0, r.v)(),
              i = (0, s.NC)("Unknown");
            return (
              Object.keys(t).forEach((o) => {
                t[o].forEach((t) => {
                  let s = Object.entries(t)[0];
                  if (s[0] === e.contract_type) {
                    if (["CALL", "PUT"].includes(s[0])) {
                      let t = e.shortcode.split("_").slice(-2)[0];
                      if (o !== (/^S0P$/.test(t) ? "CALLPUT" : "HIGHERLOWER"))
                        return;
                    }
                    i = s[1];
                  }
                });
              }),
              i
            );
          },
          n = (e) => {
            let t = new Date(),
              i = (t.getTime() - e) / 1e3;
            if (i < 60)
              return (0, s.NC)("{{secondPast}}s ago", {
                secondPast: parseInt(i),
              });
            if (i < 3600)
              return (0, s.NC)("{{minutePast}}m ago", {
                minutePast: parseInt(i / 60),
              });
            if (i <= 86400)
              return (0, s.NC)("{{hourPast}}h ago", {
                hourPast: parseInt(i / 3600),
              });
            let o = new Date(e),
              r = o.getDate(),
              a = o
                .toDateString()
                .match(/ [a-zA-Z]*/)[0]
                .replace(" ", ""),
              n = `${
                o.getFullYear() === t.getFullYear() ? "" : " "
              }${o.getFullYear()}`;
            return `${r} ${a}${n}`;
          };
        var l = i(50043),
          c = i(55967),
          d = i(65464);
        let u = (e) => {
            null !== window.Blockly.getSelected() &&
              null === window.Blockly.getSelected().parentBlock_ &&
              ("Delete" === e.key || "Backspace" === e.key) &&
              _("BLOCK_DELETION", d.P);
          },
          h = function () {
            let e =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : "keydown";
            window.removeEventListener(e, u);
          },
          p = function () {
            let e =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : "keydown";
            window.addEventListener(e, u);
          },
          _ = (e, t) => {
            if ("BLOCK_DELETION" === e) {
              var i, o, s;
              (null === c.T || void 0 === c.T
                ? void 0
                : null === (i = (0, c.T)()) || void 0 === i
                ? void 0
                : i[window.Blockly.getSelected().type]) &&
                t.emit(
                  "ui.log.error",
                  null === c.T || void 0 === c.T
                    ? void 0
                    : null === (s = (0, c.T)()) || void 0 === s
                    ? void 0
                    : null === (o = s[window.Blockly.getSelected().type]) ||
                      void 0 === o
                    ? void 0
                    : o.default
                );
            }
          },
          m = (e) =>
            new Promise((t, i) => {
              let o = document.createElement("script");
              (o.src = e),
                (o.async = !0),
                (o.onload = () => t(window.external_global_component)),
                (o.onerror = i),
                document.body.appendChild(o);
            });
        var g = i(66345);
        let y = function () {
            for (var e = arguments.length, t = Array(e), i = 0; i < e; i++)
              t[i] = arguments[i];
            return (e) => t.reduce((e, t) => t(e), e);
          },
          v = (e) =>
            Array.from(
              new DOMParser()
                .parseFromString(e, "text/xml")
                .getElementsByTagName("block")
            ).map((e) => ({
              type: e.getAttribute("type"),
              fields: Array.from(e.getElementsByTagName("field")).map((e) => ({
                name: e.getAttribute("name"),
                value: e.textContent.trim(),
              })),
            })),
          f = (e) =>
            e.sort((e, t) =>
              e.type < t.type
                ? -1
                : e.type > t.type
                ? 1
                : JSON.stringify(e.fields) < JSON.stringify(t.fields)
                ? -1
                : 1
            ),
          b = (e, t) => {
            if (
              (null == e ? void 0 : e.length) !==
              (null == t ? void 0 : t.length)
            )
              return !1;
            for (let a = 0; a < e.length; a++) {
              var i, o, s, r;
              if (
                (null === (i = e[a]) || void 0 === i ? void 0 : i.name) !==
                  (null === (o = t[a]) || void 0 === o ? void 0 : o.name) ||
                (null === (s = e[a]) || void 0 === s ? void 0 : s.value) !==
                  (null === (r = t[a]) || void 0 === r ? void 0 : r.value)
              )
                return !1;
            }
            return !0;
          },
          w = (e, t) => {
            let i = y(v, f),
              o = y(v, f),
              s = i(e),
              r = o(t);
            if (
              (null == s ? void 0 : s.length) !==
              (null == r ? void 0 : r.length)
            )
              return !1;
            for (let e = 0; e < s.length; e++) {
              var a, n, l, c;
              if (
                (null === (a = s[e]) || void 0 === a ? void 0 : a.type) !==
                  (null === (n = r[e]) || void 0 === n ? void 0 : n.type) ||
                !b(
                  null === (l = s[e]) || void 0 === l ? void 0 : l.fields,
                  null === (c = r[e]) || void 0 === c ? void 0 : c.fields
                )
              )
                return !1;
            }
            return !0;
          };
        var k = i(26855);
      },
      66345: function (e, t, i) {
        "use strict";
        i.d(t, { WN: () => u, Xt: () => p, l5: () => d, lY: () => h });
        var o = i(69483),
          s = i.n(o),
          r = i(26961),
          a = i.n(r),
          n = i(87920),
          l = i(30810),
          c = i(85872);
        let d = async function (e) {
            let t =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : l.R.UNSAVED,
              i = p(e);
            e.setAttribute("is_dbot", !0);
            let {
                load_modal: { updateListStrategies: o },
                save_modal: r,
              } = c.Z.instance,
              d =
                window.Blockly.derivWorkspace.current_strategy_id ||
                window.Blockly.utils.idGenerator.genUid(),
              h = await u(),
              _ = Blockly.Xml.domToText(i),
              m = Date.now(),
              g = h.findIndex((e) => e.id === d);
            if (g >= 0) {
              let e = h[g];
              (e.xml = _),
                (e.name = r.bot_name),
                (e.timestamp = m),
                (e.save_type = t);
            } else
              h.push({
                id: d,
                timestamp: m,
                name: r.bot_name || (0, n.vc)().default_file_name,
                xml: _,
                save_type: t,
              });
            h
              .sort((e, t) => new Date(e.timestamp) - new Date(t.timestamp))
              .reverse(),
              h.length > 10 && h.pop(),
              o(h),
              s().setItem("saved_workspaces", a().compress(JSON.stringify(h)));
          },
          u = async () => {
            try {
              return (
                JSON.parse(
                  a().decompress(await s().getItem("saved_workspaces"))
                ) || []
              );
            } catch (e) {
              return [];
            }
          },
          h = async (e) => {
            let t = await u(),
              i = t.findIndex((t) => t.id === e);
            i >= 0 && t.splice(i, 1),
              await s().setItem(
                "saved_workspaces",
                a().compress(JSON.stringify(t))
              );
          },
          p = (e) => {
            if (e)
              return (
                e.hasAttribute("collection") &&
                  "true" === e.getAttribute("collection") &&
                  e.setAttribute("collection", "true"),
                e.setAttribute("is_dbot", "true"),
                e
              );
          };
      },
      65464: function (e, t, i) {
        "use strict";
        i.d(t, { P: () => r, Z: () => s });
        var o = i(35369);
        class s {
          register(e, t, i, s, r) {
            var a = this;
            r && this.unregisterAll(e);
            let n = (e) => {
              e.type === s.type &&
                (this.unregister("api.error", n),
                s.unregister.forEach((e) => {
                  e instanceof Array
                    ? this.unregister(...e)
                    : this.unregisterAll(e);
                }));
            };
            s && this.register("api.error", n);
            let l = function () {
                for (var o = arguments.length, r = Array(o), l = 0; l < o; l++)
                  r[l] = arguments[l];
                i && a.unregister(e, t),
                  s && a.unregister("api.error", n),
                  t(...r);
              },
              c = this.eam.get(e);
            this.eam = c
              ? this.eam.set(e, c.push({ action: l, searchBy: t }))
              : this.eam.set(e, new o.aV().push({ action: l, searchBy: t }));
          }
          unregister(e, t) {
            this.eam = this.eam.set(
              e,
              this.eam.get(e).filter((e) => e.searchBy !== t)
            );
          }
          isRegistered(e) {
            return this.eam.has(e);
          }
          unregisterAll(e) {
            this.eam = this.eam.delete(e);
          }
          emit(e, t) {
            this.eam.has(e) && this.eam.get(e).forEach((e) => e.action(t));
          }
          setState() {
            let e =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : {};
            this.state = { ...this.state, ...e };
          }
          getState(e) {
            var t;
            return null === (t = this.state) || void 0 === t ? void 0 : t[e];
          }
          constructor() {
            this.eam = new o.D5();
          }
        }
        let r = new s();
      },
      29265: function (e, t, i) {
        "use strict";
        function o() {
          let e, t;
          let i = new Promise((i, o) => {
            (e = i), (t = o);
          });
          return (
            (i.isPending = !0),
            (i.resolve = (t) => {
              (i.isPending = !1), e(t);
            }),
            (i.reject = (e) => {
              (i.isPending = !1), t(e);
            }),
            i
          );
        }
        i.d(t, { Z: () => o });
      },
      26855: function (e, t, i) {
        "use strict";
        i.d(t, { N0: () => s, kH: () => r, rK: () => a });
        var o = i(47962);
        let s = () => {
            let e = window.Blockly.derivWorkspace;
            e &&
              document.getElementById("scratch_div") &&
              window.Blockly.svgResize(e);
          },
          r = (e, t) => {
            (Array.isArray(t) ? t : [t]).forEach((t) => {
              (0, o.v)().single_instance_blocks.includes(t) &&
                e.getAllBlocks().forEach((e) => {
                  e.type === t && e.dispose();
                });
            });
          },
          a = () => "rtl" === document.documentElement.getAttribute("dir");
      },
      30453: function (e, t, i) {
        "use strict";
        i.d(t, { q: () => r });
        var o = i(37979),
          s = i(46543);
        let r = function () {
          let { handleLogout: e, client: t } =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : {},
            { featureFlagValue: i, isGBLoaded: r } = (0, s.Z)({
              featureFlag: "hydra_be",
            }),
            a = (0, o.sX)(i, r),
            { OAuth2Logout: n } = (0, o.il)(
              { OAuth2EnabledApps: i, OAuth2EnabledAppsInitialised: r },
              e ?? (() => Promise.resolve())
            );
          return {
            isOAuth2Enabled: a,
            oAuthLogout: async () => {
              null == t || t.setIsLoggingOut(!0), await n();
            },
          };
        };
      },
      46543: function (e, t, i) {
        "use strict";
        i.d(t, { Z: () => l });
        var o = i(67294),
          s = i(89471),
          r = i(83571),
          a = i(22273);
        let n = () => {
            let [e, t] = (0, o.useState)(!1),
              { data: i } = (0, a.Z)(!0),
              [s, n] = (0, o.useState)(!0);
            return (
              (0, o.useEffect)(() => {
                let e;
                if (null == i ? void 0 : i.marketing_growthbook) {
                  let i = 0;
                  e = setInterval(() => {
                    var o;
                    if (i > 20) {
                      clearInterval(e), n(!1);
                      return;
                    }
                    (i += 1),
                      (null === r.Analytics || void 0 === r.Analytics
                        ? void 0
                        : null === (o = r.Analytics.getInstances()) ||
                          void 0 === o
                        ? void 0
                        : o.ab) && (t(!0), clearInterval(e));
                  }, 500);
                } else n(!1);
                return () => {
                  clearInterval(e);
                };
              }, [i.marketing_growthbook]),
              { isGBLoaded: e, isGBAvailable: s }
            );
          },
          l = (e) => {
            let { featureFlag: t, defaultValue: i } = e,
              a = void 0 !== i && i,
              [l, c] = (0, o.useState)(
                (null === r.Analytics || void 0 === r.Analytics
                  ? void 0
                  : r.Analytics.getFeatureValue(t, a)) ?? a
              ),
              { isGBLoaded: d } = n(),
              u = (0, s.tm)();
            return (
              "undefined" != typeof window && (window.Analytics = r.Analytics),
              (0, o.useEffect)(() => {
                if (d) {
                  var e, i, o, s;
                  if (
                    null === r.Analytics || void 0 === r.Analytics
                      ? void 0
                      : null === (e = r.Analytics.getInstances()) ||
                        void 0 === e
                      ? void 0
                      : e.ab
                  ) {
                    let e = () => {
                      let e =
                        null === r.Analytics || void 0 === r.Analytics
                          ? void 0
                          : r.Analytics.getFeatureValue(t, a);
                      u() && c(e);
                    };
                    e(),
                      null === r.Analytics ||
                        void 0 === r.Analytics ||
                        null === (s = r.Analytics.getInstances()) ||
                        void 0 === s ||
                        null === (o = s.ab) ||
                        void 0 === o ||
                        null === (i = o.GrowthBook) ||
                        void 0 === i ||
                        i.setRenderer(() => {
                          e();
                        });
                  }
                }
              }, [d, a, t, u]),
              { featureFlagValue: l, isGBLoaded: d }
            );
          };
      },
      22273: function (e, t, i) {
        "use strict";
        i.d(t, { Z: () => n });
        var o = i(67294),
          s = i(12838),
          r = JSON.parse(
            '{"cs_chat_livechat":true,"cs_chat_whatsapp":true,"marketing_growthbook":true,"passkeys":true,"tracking_GTM":true,"tracking_datadog":true,"tracking_hotjar":true,"tracking_rudderstack":true}'
          );
        let a = async function () {
            let e = await fetch(
              "https://app-config-prod.firebaseio.com/remote_config/deriv-app.json"
            );
            if (!e.ok) throw Error("Remote Config Server is out of reach!");
            return e.json();
          },
          n = function () {
            let e =
                arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
              [t, i] = (0, o.useState)(r);
            return (
              (0, o.useEffect)(() => {
                e &&
                  a()
                    .then(async (e) => {
                      (await s.gb.hashObject(e)) !==
                        (await s.gb.hashObject(t)) && i(e);
                    })
                    .catch((e) => {
                      console.error("Remote Config error: ", e);
                    });
              }, [e]),
              { data: t }
            );
          };
      },
      79649: function (e, t, i) {
        "use strict";
        i.d(t, { T: () => r });
        var o = i(67294),
          s = i(89064);
        let r = () => {
          let [e, t] = (0, o.useState)(s.cR.UNKNOWN),
            [i, r] = (0, o.useState)(!1),
            [a, n] = (0, o.useState)(!1),
            [l, c] = (0, o.useState)([]),
            [d, u] = (0, o.useState)(null),
            [h, p] = (0, o.useState)("");
          return (
            (0, o.useEffect)(() => {
              let e = s.IS.subscribe((e) => {
                  t(e);
                }),
                i = s.Nf.subscribe((e) => {
                  r(e);
                }),
                o = s.C9.subscribe((e) => {
                  n(e);
                }),
                a = s.ao.subscribe((e) => {
                  c(e);
                }),
                l = s.FT.subscribe((e) => {
                  u(e), p((null == e ? void 0 : e.loginid) ?? "");
                });
              return () => {
                e.unsubscribe(),
                  i.unsubscribe(),
                  o.unsubscribe(),
                  a.unsubscribe(),
                  l.unsubscribe();
              };
            }, []),
            {
              connectionStatus: e,
              isAuthorized: i,
              isAuthorizing: a,
              accountList: l,
              authData: d,
              activeLoginid: h,
            }
          );
        };
      },
      1051: function (e, t, i) {
        "use strict";
        i.d(t, { t: () => a });
        var o = i(67294);
        let s = "undefined" != typeof window ? o.useLayoutEffect : o.useEffect,
          r = function (e, t, i, r) {
            let a = (0, o.useRef)(t);
            s(() => {
              a.current = t;
            }, [t]),
              (0, o.useEffect)(() => {
                let t, o;
                return (
                  (t = (null == i ? void 0 : i.current) ?? window),
                  (o = (e) => a.current(e)),
                  (null == t ? void 0 : t.addEventListener) &&
                    t.addEventListener(e, o, r),
                  () => {
                    null == t || t.removeEventListener(e, o, r);
                  }
                );
              }, [e, i, r]);
          };
        function a(e, t, i) {
          let o =
            arguments.length > 3 && void 0 !== arguments[3]
              ? arguments[3]
              : "mousedown";
          r(o, (o) => {
            let s = null == e ? void 0 : e.current;
            !(!s || s.contains(o.target)) && (!i || i(o)) && t(o);
          });
        }
      },
      83274: function (e, t, i) {
        "use strict";
        i.d(t, { g3: () => tw, oR: () => tk });
        var o = {};
        i.r(o),
          i.d(o, {
            after_purchase: () => M,
            balance: () => F,
            before_purchase: () => G,
            check_direction: () => H,
            console: () => V,
            contract_check_result: () => W,
            controls_flow_statements: () => Y,
            controls_for: () => $,
            controls_forEach: () => q,
            controls_if: () => z,
            controls_whileUntil: () => K,
            during_purchase: () => X,
            epoch: () => Z,
            get_ohlc: () => J,
            is_candle_black: () => Q,
            last_digit: () => ee,
            logic_operation: () => et,
            math_arithmetic: () => ei,
            math_constrain: () => eo,
            math_single: () => es,
            notify_telegram: () => er,
            ohlc: () => ea,
            ohlc_values: () => en,
            ohlc_values_in_list: () => el,
            procedures_ifreturn: () => ec,
            read_details: () => ed,
            read_ohlc: () => eu,
            read_ohlc_obj: () => eh,
            sell_at_market: () => ep,
            sell_price: () => e_,
            sma_statement: () => em,
            text_print: () => eg,
            text_prompt_ext: () => ey,
            tick_analysis: () => ev,
            todatetime: () => ef,
            totimestamp: () => eb,
            trade_again: () => ew,
            trade_definition: () => ek,
            trade_definition_multiplier: () => eT,
            trade_definition_tradeoptions: () => eN,
            variables_set: () => eS,
          });
        var s = i(85893),
          r = i(67294),
          a = i(27412),
          n = i(68949),
          l = i(17481),
          c = i(66175),
          d = i(88199),
          u = i(2776),
          h = i(48059);
        class p {
          constructor(e, t) {
            (0, a._)(this, "root_store", void 0),
              (0, a._)(this, "core", void 0),
              (0, a._)(this, "dbot_store", void 0),
              (0, a._)(this, "api_helpers_store", void 0),
              (0, a._)(this, "timer", void 0),
              (0, a._)(this, "disposeReloadOnLanguageChangeReaction", void 0),
              (0, a._)(this, "disposeCurrencyReaction", void 0),
              (0, a._)(this, "disposeSwitchAccountListener", void 0),
              (0, a._)(this, "disposeLandingCompanyChangeReaction", void 0),
              (0, a._)(this, "disposeResidenceChangeReaction", void 0),
              (0, a._)(this, "getErrorForNonEuClients", () => ({
                text: (0, h.NC)(
                  "Unfortunately, this trading platform is not available for EU Deriv account. Please switch to a non-EU account to continue trading."
                ),
                title: (0, h.NC)("Deriv Bot is unavailable for this account"),
                link: (0, h.NC)("Switch to another account"),
              })),
              (0, a._)(this, "getErrorForEuClients", function () {
                let e =
                    arguments.length > 0 &&
                    void 0 !== arguments[0] &&
                    arguments[0],
                  t =
                    arguments.length > 1 && void 0 !== arguments[1]
                      ? arguments[1]
                      : void 0;
                return {
                  text: " ",
                  title: e
                    ? (0, h.NC)(
                        `Deriv Bot is not available for ${t || "EU"} clients`
                      )
                    : (0, h.NC)(`Deriv Bot is unavailable in ${t || "the EU"}`),
                  link: e
                    ? (0, h.NC)("Back to Trader's Hub")
                    : (0, h.NC)("Refresh"),
                  route: c.xOw.traders_hub,
                };
              }),
              (0, a._)(this, "throwErrorForExceptionCountries", (e) => {
                let { client: t, common: i } = this.core,
                  o = { ...(0, l.Lq)() }[e];
                if (o)
                  return (0, c.xVn)(
                    i.showError,
                    this.getErrorForEuClients(t.is_logged_in, o)
                  );
              }),
              (0, a._)(this, "handleErrorForEu", () => {
                var e;
                let { client: t, common: i } = this.core;
                return !(null == t ? void 0 : t.is_logged_in) &&
                  (null == t ? void 0 : t.is_eu_country)
                  ? (this.throwErrorForExceptionCountries(
                      null == t ? void 0 : t.clients_country
                    ),
                    (0, c.xVn)(i.showError, this.getErrorForEuClients()))
                  : t.is_landing_company_loaded
                  ? (this.throwErrorForExceptionCountries(
                      null == t
                        ? void 0
                        : null === (e = t.account_settings) || void 0 === e
                        ? void 0
                        : e.clients_country
                    ),
                    t.should_show_eu_error)
                    ? (0, c.xVn)(
                        i.showError,
                        this.getErrorForEuClients(t.is_logged_in)
                      )
                    : t.content_flag === c.DQA.HIGH_RISK_CR
                    ? (i.setError(!1, {}), !1)
                    : t.content_flag === c.DQA.LOW_RISK_CR_EU ||
                      (!t.is_bot_allowed &&
                        t.is_eu &&
                        t.should_show_eu_error) ||
                      (0, c.hWv)(t.active_accounts) ||
                      t.is_options_blocked
                    ? (0, c.xVn)(
                        i.showError,
                        this.getErrorForNonEuClients(),
                        () => {
                          var e;
                          null ===
                            (e = document.querySelector(
                              ".deriv-account-switcher__button"
                            )) ||
                            void 0 === e ||
                            e.click();
                        },
                        !1,
                        !1
                      )
                    : (i.setError(!1, {}), !1)
                  : (i.setError(!1, {}), !1);
              }),
              (0, a._)(this, "onMount", async () => {
                let { blockly_store: e, run_panel: t } = this.root_store,
                  { client: i, ui: o } = this.core;
                this.showDigitalOptionsMaltainvestError();
                let s = 1;
                (this.timer = setInterval(() => {
                  window.sendRequestsStatistic &&
                    (window.sendRequestsStatistic(!1),
                    performance.clearMeasures(),
                    6 === s || (null == t ? void 0 : t.is_running)
                      ? this.timer && clearInterval(this.timer)
                      : s++);
                }, 1e4)),
                  this.dbot_store &&
                    (e.setLoading(!0),
                    await d.DBot.initWorkspace(
                      "/",
                      this.dbot_store,
                      this.api_helpers_store,
                      o.is_mobile,
                      !1
                    ),
                    e.setContainerSize(),
                    e.setLoading(!1),
                    this.registerCurrencyReaction.call(this),
                    this.registerOnAccountSwitch.call(this),
                    this.registerLandingCompanyChangeReaction.call(this),
                    this.registerResidenceChangeReaction.call(this),
                    window.addEventListener(
                      "click",
                      this.onClickOutsideBlockly
                    ),
                    e.getCachedActiveTab(),
                    (0, n.gx)(
                      () =>
                        (null == i ? void 0 : i.should_show_eu_error) ||
                        (null == i ? void 0 : i.is_landing_company_loaded),
                      () => this.showDigitalOptionsMaltainvestError()
                    ),
                    (0, n.U5)(
                      () => (null == i ? void 0 : i.content_flag),
                      () => this.showDigitalOptionsMaltainvestError()
                    ));
              }),
              (0, a._)(this, "onUnmount", () => {
                var e, t, i;
                d.DBot.terminateBot(),
                  d.DBot.terminateConnection(),
                  (null === (e = window.Blockly) || void 0 === e
                    ? void 0
                    : e.derivWorkspace) &&
                    (clearInterval(
                      null === (t = window.Blockly) || void 0 === t
                        ? void 0
                        : t.derivWorkspace.save_workspace_interval
                    ),
                    null === (i = window.Blockly.derivWorkspace) ||
                      void 0 === i ||
                      i.dispose()),
                  "function" ==
                    typeof this.disposeReloadOnLanguageChangeReaction &&
                    this.disposeReloadOnLanguageChangeReaction(),
                  "function" == typeof this.disposeCurrencyReaction &&
                    this.disposeCurrencyReaction(),
                  "function" == typeof this.disposeSwitchAccountListener &&
                    this.disposeSwitchAccountListener(),
                  "function" ==
                    typeof this.disposeLandingCompanyChangeReaction &&
                    this.disposeLandingCompanyChangeReaction(),
                  "function" == typeof this.disposeResidenceChangeReaction &&
                    this.disposeResidenceChangeReaction(),
                  window.removeEventListener(
                    "click",
                    this.onClickOutsideBlockly
                  );
                let { ui: o } = this.core;
                o.setAccountSwitcherDisabledMessage(),
                  o.setPromptHandler(!1),
                  this.timer && clearInterval(this.timer),
                  performance.clearMeasures();
              }),
              (0, a._)(this, "registerCurrencyReaction", () => {
                this.disposeCurrencyReaction = (0, n.U5)(
                  () => this.core.client.currency,
                  () => {
                    var e, t;
                    (null === (e = window.Blockly) || void 0 === e
                      ? void 0
                      : e.derivWorkspace) &&
                      (null === (t = window.Blockly) || void 0 === t
                        ? void 0
                        : t.derivWorkspace
                            .getAllBlocks()
                            .filter(
                              (e) =>
                                "trade_definition_tradeoptions" === e.type ||
                                "trade_definition_multiplier" === e.type ||
                                "trade_definition_accumulator" === e.type ||
                                (e.isDescendantOf(
                                  "trade_definition_multiplier"
                                ) &&
                                  "trade_parameters" === e.category_)
                            )
                      ).forEach((e) => (0, u.NW)(e));
                  }
                );
              }),
              (0, a._)(this, "registerOnAccountSwitch", () => {
                this.disposeSwitchAccountListener = (0, n.U5)(
                  () => {
                    var e;
                    return null === (e = this.root_store.common) || void 0 === e
                      ? void 0
                      : e.is_socket_opened;
                  },
                  (e) => {
                    var t, i, o;
                    if (!e) return;
                    (this.api_helpers_store = {
                      server_time: this.root_store.common.server_time,
                      ws: d.api_base.api,
                    }),
                      (null === d.ApiHelpers || void 0 === d.ApiHelpers
                        ? void 0
                        : d.ApiHelpers.instance) ||
                        d.ApiHelpers.setInstance(this.api_helpers_store),
                      this.showDigitalOptionsMaltainvestError();
                    let s =
                        null === d.ApiHelpers || void 0 === d.ApiHelpers
                          ? void 0
                          : null === (t = d.ApiHelpers.instance) || void 0 === t
                          ? void 0
                          : t.active_symbols,
                      r =
                        null === d.ApiHelpers || void 0 === d.ApiHelpers
                          ? void 0
                          : null === (i = d.ApiHelpers.instance) || void 0 === i
                          ? void 0
                          : i.contracts_for;
                    (null === d.ApiHelpers || void 0 === d.ApiHelpers
                      ? void 0
                      : d.ApiHelpers.instance) &&
                      s &&
                      r &&
                      ((null === (o = window.Blockly) || void 0 === o
                        ? void 0
                        : o.derivWorkspace) &&
                        (null == s ||
                          s.retrieveActiveSymbols(!0).then(() => {
                            var e;
                            r.disposeCache(),
                              null === (e = window.Blockly) ||
                                void 0 === e ||
                                e.derivWorkspace
                                  .getAllBlocks()
                                  .filter(
                                    (e) => "trade_definition_market" === e.type
                                  )
                                  .forEach((e) => {
                                    (0, d.runIrreversibleEvents)(() => {
                                      let t =
                                        new window.Blockly.Events.BlockCreate(
                                          e
                                        );
                                      window.Blockly.Events.fire(t);
                                    });
                                  });
                          })),
                      d.DBot.initializeInterpreter());
                  }
                );
              }),
              (0, a._)(this, "registerLandingCompanyChangeReaction", () => {
                let { client: e } = this.core;
                this.disposeLandingCompanyChangeReaction = (0, n.U5)(
                  () => e.landing_company_shortcode,
                  () => this.handleErrorForEu()
                );
              }),
              (0, a._)(this, "registerResidenceChangeReaction", () => {
                let { client: e } = this.core;
                this.disposeResidenceChangeReaction = (0, n.U5)(
                  () => {
                    var t;
                    return null === (t = e.account_settings) || void 0 === t
                      ? void 0
                      : t.country_code;
                  },
                  () => this.handleErrorForEu()
                );
              }),
              (0, a._)(this, "setDBotEngineStores", () => {
                let {
                    flyout: e,
                    toolbar: t,
                    save_modal: i,
                    dashboard: o,
                    load_modal: s,
                    run_panel: r,
                    blockly_store: a,
                    summary_card: n,
                  } = this.root_store,
                  { client: l, common: c } = this.core,
                  { handleFileChange: u } = s,
                  { setLoading: h } = a,
                  { setContractUpdateConfig: p } = n,
                  {
                    ui: { is_mobile: _ },
                  } = this.core;
                (this.dbot_store = {
                  client: l,
                  flyout: e,
                  toolbar: t,
                  save_modal: i,
                  dashboard: o,
                  load_modal: s,
                  run_panel: r,
                  setLoading: h,
                  setContractUpdateConfig: p,
                  handleFileChange: u,
                  is_mobile: _,
                  common: c,
                }),
                  (this.api_helpers_store = {
                    server_time: this.core.common.server_time,
                    ws: d.api_base.api,
                  });
              }),
              (0, a._)(this, "onClickOutsideBlockly", (e) => {
                if (
                  document.querySelector(".injectionDiv") &&
                  !(e.path || (e.composedPath && e.composedPath())).some(
                    (e) => e.classList && e.classList.contains("injectionDiv")
                  )
                ) {
                  var t;
                  null === (t = window.Blockly) ||
                    void 0 === t ||
                    t.hideChaff(!1);
                }
              }),
              (0, a._)(this, "showDigitalOptionsMaltainvestError", () => {
                this.handleErrorForEu(!0);
              }),
              (0, n.rC)(this, {
                onMount: n.aD,
                onUnmount: n.aD,
                registerCurrencyReaction: n.aD,
                registerOnAccountSwitch: n.aD,
                registerLandingCompanyChangeReaction: n.aD,
                registerResidenceChangeReaction: n.aD,
                setDBotEngineStores: n.aD,
                onClickOutsideBlockly: n.aD,
                showDigitalOptionsMaltainvestError: n.aD,
              }),
              (this.root_store = e),
              (this.core = t),
              (this.dbot_store = null),
              (this.api_helpers_store = null),
              (this.timer = null);
          }
        }
        var _ = i(24335),
          m = i(58902);
        class g {
          constructor(e) {
            (0, a._)(this, "root_store", void 0),
              (0, a._)(this, "is_loading", !1),
              (0, a._)(this, "active_tab", _.yj.WORKSPACE),
              (0, a._)(this, "setActiveTab", (e) => {
                (this.active_tab = e), (0, m.Jp)("active_tab", this.active_tab);
              }),
              (0, a._)(this, "setContainerSize", () => {
                this.active_tab === _.yj.WORKSPACE &&
                  (0, d.onWorkspaceResize)();
              }),
              (0, a._)(this, "onMount", () => {
                window.addEventListener("resize", this.setContainerSize);
              }),
              (0, a._)(this, "getCachedActiveTab", () => {
                (0, m.$8)("active_tab") &&
                  (this.active_tab = (0, m.$8)("active_tab"));
              }),
              (0, a._)(this, "onUnmount", () => {
                window.removeEventListener("resize", this.setContainerSize);
              }),
              (0, a._)(this, "setLoading", (e) => {
                this.is_loading = e;
              }),
              (0, n.rC)(this, {
                is_loading: n.LO,
                active_tab: n.LO,
                setLoading: n.aD,
                setActiveTab: n.aD,
              }),
              (this.root_store = e);
          }
        }
        class y {
          get is_contract_ended() {
            let { transactions: e } = this.root_store;
            return e.contracts.length > 0 && e.contracts[0].is_ended;
          }
          constructor(e) {
            (0, a._)(this, "root_store", void 0),
              (0, a._)(this, "subscription", { id: null, subscriber: null }),
              (0, a._)(this, "chart_subscription_id", ""),
              (0, a._)(this, "symbol", void 0),
              (0, a._)(this, "is_chart_loading", void 0),
              (0, a._)(this, "chart_type", void 0),
              (0, a._)(this, "granularity", void 0),
              (0, a._)(this, "onStartBot", () => {
                this.updateSymbol();
              }),
              (0, a._)(this, "onStopBot", () => {}),
              (0, a._)(this, "updateSymbol", () => {
                var e;
                let t = window.Blockly.derivWorkspace,
                  i =
                    null == t
                      ? void 0
                      : t
                          .getAllBlocks()
                          .find((e) => "trade_definition_market" === e.type),
                  o =
                    (null == i ? void 0 : i.getFieldValue("SYMBOL_LIST")) ??
                    (null === d.api_base || void 0 === d.api_base
                      ? void 0
                      : null === (e = d.api_base.active_symbols["0"]) ||
                        void 0 === e
                      ? void 0
                      : e.symbol);
                this.symbol = o;
              }),
              (0, a._)(this, "onSymbolChange", (e) => {
                (this.symbol = e), this.saveToLocalStorage();
              }),
              (0, a._)(this, "updateGranularity", (e) => {
                (this.granularity = e), this.saveToLocalStorage();
              }),
              (0, a._)(this, "updateChartType", (e) => {
                (this.chart_type = e), this.saveToLocalStorage();
              }),
              (0, a._)(this, "setChartStatus", (e) => {
                this.is_chart_loading = e;
              }),
              (0, a._)(this, "saveToLocalStorage", () => {
                c.j73.set(
                  "bot.chart_props",
                  JSON.stringify({
                    symbol: this.symbol,
                    granularity: this.granularity,
                    chart_type: this.chart_type,
                  })
                );
              }),
              (0, a._)(this, "restoreFromStorage", () => {
                try {
                  let e = c.j73.get("bot.chart_props");
                  if (e) {
                    let {
                      symbol: t,
                      granularity: i,
                      chart_type: o,
                    } = JSON.parse(e);
                    (this.symbol = t),
                      (this.granularity = i),
                      (this.chart_type = o);
                  } else (this.granularity = 0), (this.chart_type = "line");
                } catch {
                  c.j73.remove("bot.chart_props");
                }
              }),
              (0, a._)(this, "getMarketsOrder", (e) => {
                let t = "synthetic_index",
                  i = !!e.find((e) => e.market === t);
                return e
                  .slice()
                  .sort((e, t) => (e.display_name < t.display_name ? -1 : 1))
                  .map((e) => e.market)
                  .reduce(
                    (e, t) => (-1 === e.indexOf(t) && e.push(t), e),
                    i ? [t] : []
                  );
              }),
              (0, a._)(this, "setChartSubscriptionId", (e) => {
                this.chart_subscription_id = e;
              }),
              (0, n.rC)(this, {
                symbol: n.LO,
                is_chart_loading: n.LO,
                chart_type: n.LO,
                granularity: n.LO,
                is_contract_ended: n.Fl,
                updateSymbol: n.aD,
                onSymbolChange: n.aD,
                updateGranularity: n.aD,
                updateChartType: n.aD,
                setChartStatus: n.aD,
                restoreFromStorage: n.aD,
                chart_subscription_id: n.LO,
                setChartSubscriptionId: n.aD,
              }),
              (this.root_store = e);
            let { run_panel: t } = e;
            (0, n.U5)(
              () => t.is_running,
              () => (t.is_running ? this.onStartBot() : this.onStopBot())
            ),
              this.restoreFromStorage();
          }
        }
        var v = i(29656),
          f = i(89064);
        let b = /^maltainvest$/,
          w = /^mt$/;
        class k {
          get active_accounts() {
            return this.accounts instanceof Object
              ? Object.values(this.accounts).filter((e) => !e.is_disabled)
              : [];
          }
          get clients_country() {
            var e;
            return null === (e = this.website_status) || void 0 === e
              ? void 0
              : e.clients_country;
          }
          get is_bot_allowed() {
            return this.isBotAllowed();
          }
          get is_trading_experience_incomplete() {
            var e, t;
            return null === (t = this.account_status) || void 0 === t
              ? void 0
              : null === (e = t.status) || void 0 === e
              ? void 0
              : e.some((e) => "trading_experience_not_complete" === e);
          }
          get is_eu() {
            if (!this.landing_companies) return !1;
            let {
                gaming_company: e,
                financial_company: t,
                mt_gaming_company: i,
              } = this.landing_companies,
              o = null == t ? void 0 : t.shortcode,
              s = null == e ? void 0 : e.shortcode,
              r =
                (null == i ? void 0 : i.financial.shortcode) ||
                (null == i ? void 0 : i.swap_free.shortcode);
            return (
              "maltainvest" === this.landing_company_shortcode ||
              (o || s || r
                ? (b.test(o) && "svg" !== s) || b.test(s)
                : w.test(this.residence))
            );
          }
          get is_eu_country() {
            var e;
            let t =
              null === (e = this.website_status) || void 0 === e
                ? void 0
                : e.clients_country;
            return !!t && (0, v.x3)(t);
          }
          get is_low_risk() {
            let { gaming_company: e, financial_company: t } =
              this.landing_companies ?? {};
            return (
              (null == t ? void 0 : t.shortcode) === "maltainvest" &&
              (null == e ? void 0 : e.shortcode) === "svg"
            );
          }
          get should_show_eu_error() {
            return (
              !!this.is_landing_company_loaded &&
              this.is_eu &&
              !this.is_low_risk
            );
          }
          get landing_company_shortcode() {
            if (this.accounts[this.loginid])
              return this.accounts[this.loginid].landing_company_name;
          }
          get residence() {
            if (this.is_logged_in) {
              var e;
              return (
                (null === (e = this.account_settings) || void 0 === e
                  ? void 0
                  : e.country_code) ?? ""
              );
            }
            return "";
          }
          get is_options_blocked() {
            return (0, v.Yb)(this.residence);
          }
          get is_multipliers_only() {
            return (0, v.uw)(this.residence);
          }
          get is_eu_or_multipliers_only() {
            return this.is_multipliers_only
              ? !this.is_multipliers_only
              : !(0, v.x3)(this.residence);
          }
          get is_virtual() {
            return (
              !(0, c.Qr$)(this.accounts) &&
              this.accounts[this.loginid] &&
              !!this.accounts[this.loginid].is_virtual
            );
          }
          get all_loginids() {
            return (0, c.Qr$)(this.accounts) ? [] : Object.keys(this.accounts);
          }
          get virtual_account_loginid() {
            return this.all_loginids.find((e) => !!this.accounts[e].is_virtual);
          }
          get content_flag() {
            let {
              is_logged_in: e,
              landing_companies: t,
              residence: i,
              is_landing_company_loaded: o,
            } = this;
            if (o) {
              let { financial_company: o, gaming_company: s } = t ?? {},
                r =
                  (null == o ? void 0 : o.shortcode) === "svg" ||
                  (null == s ? void 0 : s.shortcode) === "svg";
              if (!e) return "";
              if (
                (null == s || !s.shortcode) &&
                (null == o ? void 0 : o.shortcode) === "maltainvest"
              )
                return this.is_virtual ? c.DQA.EU_DEMO : c.DQA.EU_REAL;
              if (
                (null == o ? void 0 : o.shortcode) === "maltainvest" &&
                (null == s ? void 0 : s.shortcode) === "svg" &&
                !this.is_virtual
              )
                return this.is_eu
                  ? c.DQA.LOW_RISK_CR_EU
                  : c.DQA.LOW_RISK_CR_NON_EU;
              if (
                (((null == o ? void 0 : o.shortcode) === "svg" &&
                  (null == s ? void 0 : s.shortcode) === "svg") ||
                  r) &&
                !this.is_virtual
              )
                return c.DQA.HIGH_RISK_CR;
              if ((0, v.x3)(i))
                return this.is_virtual ? c.DQA.EU_DEMO : c.DQA.EU_REAL;
              if (this.is_virtual) return c.DQA.CR_DEMO;
            }
            return c.DQA.LOW_RISK_CR_NON_EU;
          }
          get is_cr_account() {
            var e;
            return null === (e = this.loginid) || void 0 === e
              ? void 0
              : e.startsWith("CR");
          }
          get account_open_date() {
            if (!(0, c.Qr$)(this.accounts) && this.accounts[this.loginid])
              return Object.keys(this.accounts[this.loginid]).includes(
                "created_at"
              )
                ? this.accounts[this.loginid].created_at
                : void 0;
          }
          setAccountStatus(e) {
            this.account_status = e;
          }
          setAccountSettings(e) {
            try {
              JSON.stringify(e) !== JSON.stringify(this.account_settings) &&
                (this.account_settings = e);
            } catch (e) {
              console.error("setAccountSettings error", e);
            }
          }
          setWebsiteStatus(e) {
            this.website_status = e;
          }
          setLandingCompany(e) {
            (this.landing_companies = e), (this.is_landing_company_loaded = !0);
          }
          constructor() {
            (0, a._)(this, "loginid", ""),
              (0, a._)(this, "account_list", []),
              (0, a._)(this, "balance", "0"),
              (0, a._)(this, "currency", "AUD"),
              (0, a._)(this, "is_logged_in", !1),
              (0, a._)(this, "account_status", void 0),
              (0, a._)(this, "account_settings", void 0),
              (0, a._)(this, "website_status", void 0),
              (0, a._)(this, "landing_companies", void 0),
              (0, a._)(this, "upgradeable_landing_companies", []),
              (0, a._)(this, "accounts", {}),
              (0, a._)(this, "is_landing_company_loaded", !1),
              (0, a._)(this, "all_accounts_balance", null),
              (0, a._)(this, "is_logging_out", !1),
              (0, a._)(this, "updateSelfExclusion", () => {}),
              (0, a._)(this, "isBotAllowed", () => {
                if (!this.is_logged_in && this.is_eu_country) return !1;
                let e = "maltainvest" === this.landing_company_shortcode;
                return this.is_virtual
                  ? this.is_eu_or_multipliers_only
                  : !e && !this.is_options_blocked;
              }),
              (0, a._)(this, "setLoginId", (e) => {
                this.loginid = e;
              }),
              (0, a._)(this, "setAccountList", (e) => {
                (this.accounts = {}),
                  null == e ||
                    e.forEach((e) => {
                      this.accounts[e.loginid] = e;
                    }),
                  e && (this.account_list = e);
              }),
              (0, a._)(this, "setBalance", (e) => {
                this.balance = e;
              }),
              (0, a._)(this, "setCurrency", (e) => {
                this.currency = e;
              }),
              (0, a._)(this, "setIsLoggedIn", (e) => {
                this.is_logged_in = e;
              }),
              (0, a._)(
                this,
                "getToken",
                () =>
                  JSON.parse(localStorage.getItem("accountsList") ?? "{}")[
                    this.loginid
                  ] ?? ""
              ),
              (0, a._)(this, "setUpgradeableLandingCompanies", (e) => {
                this.upgradeable_landing_companies = e;
              }),
              (0, a._)(this, "setAllAccountsBalance", (e) => {
                this.all_accounts_balance = e ?? null;
              }),
              (0, a._)(this, "setIsLoggingOut", (e) => {
                this.is_logging_out = e;
              }),
              (0, a._)(this, "logout", () => {
                var e, t, i;
                (this.account_list = []),
                  (this.account_status = void 0),
                  (this.account_settings = void 0),
                  (this.landing_companies = void 0),
                  (this.accounts = {}),
                  (this.is_logged_in = !1),
                  (this.loginid = ""),
                  (this.balance = "0"),
                  (this.currency = "USD"),
                  (this.is_landing_company_loaded = !1),
                  (this.all_accounts_balance = null),
                  localStorage.removeItem("active_loginid"),
                  localStorage.removeItem("accountsList"),
                  localStorage.removeItem("authToken"),
                  localStorage.removeItem("clientAccounts"),
                  (0, f.Zc)(!1),
                  (0, f.Ii)([]),
                  (0, f.A3)(null),
                  this.setIsLoggingOut(!1),
                  null === (t = window.LC_API) ||
                    void 0 === t ||
                    null === (e = t.close_chat) ||
                    void 0 === e ||
                    e.call(t),
                  null === (i = window.LiveChatWidget) ||
                    void 0 === i ||
                    i.call("hide"),
                  window.Intercom &&
                    (window.Intercom("shutdown"),
                    window.DerivInterCom.initialize({
                      hideLauncher: !0,
                      token: null,
                    }));
              }),
              (0, n.rC)(this, {
                account_list: n.LO,
                account_settings: n.LO,
                account_status: n.LO,
                all_accounts_balance: n.LO,
                balance: n.LO,
                currency: n.LO,
                is_landing_company_loaded: n.LO,
                is_logged_in: n.LO,
                landing_companies: n.LO,
                loginid: n.LO,
                upgradeable_landing_companies: n.LO,
                website_status: n.LO,
                is_logging_out: n.LO,
                active_accounts: n.Fl,
                clients_country: n.Fl,
                is_bot_allowed: n.Fl,
                is_eu: n.Fl,
                is_eu_country: n.Fl,
                is_eu_or_multipliers_only: n.Fl,
                is_low_risk: n.Fl,
                is_multipliers_only: n.Fl,
                is_options_blocked: n.Fl,
                is_virtual: n.Fl,
                landing_company_shortcode: n.Fl,
                residence: n.Fl,
                should_show_eu_error: n.Fl,
                logout: n.aD,
                setAccountList: n.aD,
                setAccountSettings: n.aD,
                setAccountStatus: n.aD,
                setAllAccountsBalance: n.aD,
                setBalance: n.aD,
                setCurrency: n.aD,
                setIsLoggedIn: n.aD,
                setIsLoggingOut: n.aD,
                setLandingCompany: n.aD,
                setLoginId: n.aD,
                setWebsiteStatus: n.aD,
                setUpgradeableLandingCompanies: n.aD,
                is_trading_experience_incomplete: n.Fl,
                is_cr_account: n.Fl,
                account_open_date: n.Fl,
              });
          }
        }
        var C = i(30381),
          T = i.n(C),
          N = i(27179);
        class S {
          constructor() {
            (0, a._)(this, "server_time", (0, N.gb)()),
              (0, a._)(this, "update_time_interval", void 0),
              (0, a._)(this, "current_language", ""),
              (0, a._)(this, "is_socket_opened", !1),
              (0, a._)(this, "error", void 0),
              (0, a._)(this, "has_error", !1),
              (0, a._)(this, "setCurrentLanguage", (e) => {
                this.current_language = e;
              }),
              (0, a._)(this, "setServerTime", (e, t) => {
                t ||
                  ((this.server_time = e),
                  this.update_time_interval &&
                    clearInterval(this.update_time_interval),
                  (this.update_time_interval = setInterval(
                    () => this.updateServerTime(),
                    1e3
                  )));
              }),
              (0, a._)(this, "updateServerTime", () => {
                this.server_time = T()(this.server_time).add(
                  1e3,
                  "milliseconds"
                );
              }),
              (0, a._)(this, "setSocketOpened", (e) => {
                this.is_socket_opened = e;
              }),
              (0, a._)(this, "setError", (e, t) => {
                (this.has_error = e),
                  (this.error = e
                    ? {
                        type: t ? t.type : "info",
                        ...(t && {
                          header: t.header,
                          message: t.message,
                          redirect_label: t.redirect_label,
                          redirectOnClick: t.redirectOnClick,
                          should_show_refresh: t.should_show_refresh,
                          redirect_to: t.redirect_to,
                          should_clear_error_on_click:
                            t.should_clear_error_on_click,
                          should_redirect: t.should_redirect,
                          setError: this.setError,
                        }),
                      }
                    : void 0);
              }),
              (0, a._)(this, "showError", (e) => {
                let {
                  message: t,
                  header: i,
                  redirect_label: o,
                  redirectOnClick: s,
                  should_show_refresh: r,
                  redirect_to: a,
                  should_clear_error_on_click: n,
                  should_redirect: l,
                } = e;
                this.setError(!0, {
                  header: i,
                  message: t,
                  redirect_label: o,
                  redirectOnClick: s,
                  should_show_refresh: r,
                  redirect_to: a,
                  should_clear_error_on_click: n,
                  type: "error",
                  should_redirect: l,
                });
              }),
              (0, n.rC)(this, {
                current_language: n.LO,
                server_time: n.LO,
                is_socket_opened: n.LO,
                error: n.LO,
                has_error: n.LO,
                setServerTime: n.aD,
                updateServerTime: n.aD,
                setCurrentLanguage: n.aD,
                setSocketOpened: n.aD,
                setError: n.aD,
                showError: n.aD,
              });
          }
        }
        var x = i(27856),
          E = i.n(x),
          D = i(64736),
          O = i(59462),
          A = i(68853),
          I = i(64376),
          L = i(84006);
        class R {
          get is_dark_mode() {
            let {
              app: {
                core: {
                  ui: { is_dark_mode_on: e },
                },
              },
            } = this.root_store;
            return e;
          }
          initInfoPanel() {
            localStorage.getItem("dbot_should_show_info") ||
              (this.is_info_panel_visible = !0);
          }
          constructor(e, t) {
            (0, a._)(this, "root_store", void 0),
              (0, a._)(this, "core", void 0),
              (0, a._)(this, "tutorials_combined_content", []),
              (0, a._)(this, "combined_search", []),
              (0, a._)(this, "active_tab", 0),
              (0, a._)(this, "active_tab_tutorials", 0),
              (0, a._)(this, "active_tour_step_number", 0),
              (0, a._)(this, "dialog_options", {}),
              (0, a._)(this, "faq_search_value", ""),
              (0, a._)(this, "getFileArray", []),
              (0, a._)(this, "has_file_loaded", !1),
              (0, a._)(this, "has_mobile_preview_loaded", !1),
              (0, a._)(this, "active_tour", ""),
              (0, a._)(this, "is_dialog_open", !1),
              (0, a._)(this, "is_file_supported", !1),
              (0, a._)(this, "is_info_panel_visible", !1),
              (0, a._)(this, "is_preview_on_popup", !1),
              (0, a._)(this, "is_tour_dialog_visible", !1),
              (0, a._)(this, "show_toast", !1),
              (0, a._)(this, "show_mobile_tour_dialog", !1),
              (0, a._)(this, "strategy_save_type", "unsaved"),
              (0, a._)(this, "toast_message", ""),
              (0, a._)(this, "is_web_socket_intialised", !0),
              (0, a._)(this, "search_param", ""),
              (0, a._)(this, "guide_tab_content", I.xH),
              (0, a._)(this, "video_tab_content", I.zw),
              (0, a._)(this, "faq_tab_content", I.Mq),
              (0, a._)(this, "quick_strategy_tab_content", I.Yk),
              (0, a._)(this, "filtered_tab_list", []),
              (0, a._)(this, "is_chart_modal_visible", !1),
              (0, a._)(this, "is_trading_view_modal_visible", !1),
              (0, a._)(this, "faq_title", ""),
              (0, a._)(this, "setFaqTitle", (e) => {
                this.faq_title = e;
              }),
              (0, a._)(this, "resetTutorialTabContent", () => {
                (this.guide_tab_content = I.xH),
                  (this.video_tab_content = I.zw),
                  (this.faq_tab_content = I.Mq),
                  (this.quick_strategy_tab_content = I.Yk);
              }),
              (0, a._)(this, "filterTuotrialTab", (e) => {
                this.search_param = e;
                let t = this.combined_search.filter((t) =>
                    t.includes(null == e ? void 0 : e.toLowerCase())
                  ),
                  i = [],
                  o = [],
                  s = [],
                  r = [],
                  a = t.map((e) => {
                    let t = e.split("#")[0],
                      a = t.split("-")[1];
                    return t.includes(I.Qb)
                      ? (i.push((0, I.xH)()[Number(a)]), (0, I.xH)()[Number(a)])
                      : t.includes(I.FM)
                      ? (o.push((0, I.zw)()[Number(a)]), (0, I.zw)()[Number(a)])
                      : t.includes("faq")
                      ? (s.push((0, I.Mq)()[Number(a)]), (0, I.Mq)()[Number(a)])
                      : (r.push((0, I.Yk)()[Number(a)]),
                        (0, I.Yk)()[Number(a)]);
                  });
                return (
                  (this.guide_tab_content = () => i),
                  (this.video_tab_content = () => o),
                  (this.faq_tab_content = () => s),
                  (this.quick_strategy_tab_content = () => r),
                  a
                );
              }),
              (0, a._)(this, "setShowMobileTourDialog", (e) => {
                this.show_mobile_tour_dialog = e;
              }),
              (0, a._)(this, "setWebSocketState", (e) => {
                this.is_web_socket_intialised = e;
              }),
              (0, a._)(this, "setOpenSettings", (e) => {
                (this.toast_message = e), (0, D.J)((0, O.xG)()[e]);
              }),
              (0, a._)(this, "setChartModalVisibility", () => {
                this.is_chart_modal_visible = !this.is_chart_modal_visible;
              }),
              (0, a._)(this, "setTradingViewModalVisibility", () => {
                this.is_trading_view_modal_visible =
                  !this.is_trading_view_modal_visible;
              }),
              (0, a._)(this, "setIsFileSupported", (e) => {
                this.is_file_supported = e;
              }),
              (0, a._)(this, "setTourActiveStep", (e) => {
                this.active_tour_step_number = e;
              }),
              (0, a._)(this, "setPreviewOnDialog", (e) => {
                this.has_mobile_preview_loaded = e;
                let {
                  load_modal: { onLoadModalClose: t },
                } = this.root_store;
                t();
              }),
              (0, a._)(this, "setStrategySaveType", (e) => {
                this.strategy_save_type = e;
              }),
              (0, a._)(this, "setPreviewOnPopup", (e) => {
                this.is_preview_on_popup = e;
              }),
              (0, a._)(this, "setTourDialogVisibility", (e) => {
                this.is_tour_dialog_visible = e;
              }),
              (0, a._)(this, "setActiveTour", (e) => {
                this.active_tour = e;
              }),
              (0, a._)(this, "setFileLoaded", (e) => {
                (this.has_file_loaded = e),
                  document.getElementById("load-strategy__blockly-container") ||
                    console.warn("Could not find preview workspace element.");
              }),
              (0, a._)(this, "onCloseDialog", () => {
                this.is_dialog_open = !1;
              }),
              (0, a._)(this, "setActiveTab", (e) => {
                (this.active_tab = e),
                  localStorage.setItem("active_tab", e.toString());
              }),
              (0, a._)(this, "setActiveTabTutorial", (e) => {
                this.active_tab_tutorials = e;
              }),
              (0, a._)(this, "setFAQSearchValue", (e) => {
                this.faq_search_value = e;
              }),
              (0, a._)(this, "showVideoDialog", (e) => {
                let { url: t, type: i = "" } = e;
                (this.faq_search_value = ""),
                  this.setActiveTabTutorial(0),
                  this.resetTutorialTabContent(),
                  ["google", "url"].includes(i)
                    ? ("url" === i && (this.dialog_options = { url: t }),
                      (this.is_dialog_open = !0))
                    : (this.is_dialog_open = !1);
              }),
              (0, a._)(this, "setInfoPanelVisibility", (e) => {
                this.is_info_panel_visible = e;
              }),
              (0, a._)(this, "onZoomInOutClick", (e) => {
                let t = window.Blockly.getMainWorkspace(),
                  i = t.getMetrics();
                t.zoom(i.viewWidth / 2, i.viewHeight / 2, e ? 1 : -1);
              }),
              (0, a._)(this, "onCloseTour", () => {
                (0, L.X7)(new Date().getTime(), `${L.pw.key}_token`),
                  this.setActiveTour("");
              }),
              (0, a._)(this, "setTourEnd", (e) => {
                let { key: t } = e;
                this.core.ui.is_mobile && this.setTourDialogVisibility(!0),
                  (0, L.X7)(new Date().getTime(), `${t}_token`);
              }),
              (0, a._)(this, "onTourEnd", (e, t) => {
                8 === e &&
                  (this.onCloseTour(),
                  this.setTourEnd(L.pw),
                  this.setActiveTour("")),
                  t ||
                    3 !== e ||
                    (this.onCloseTour(),
                    this.setTourEnd(L.pw),
                    this.setActiveTour(""));
              }),
              (0, n.rC)(this, {
                active_tab_tutorials: n.LO,
                active_tab: n.LO,
                dialog_options: n.LO,
                faq_search_value: n.LO,
                getFileArray: n.LO,
                has_file_loaded: n.LO,
                has_mobile_preview_loaded: n.LO,
                initInfoPanel: n.aD.bound,
                active_tour: n.LO,
                is_dialog_open: n.LO,
                is_file_supported: n.LO,
                is_info_panel_visible: n.LO,
                is_preview_on_popup: n.LO,
                is_tour_dialog_visible: n.LO,
                is_web_socket_intialised: n.LO,
                tutorials_combined_content: n.LO,
                onCloseDialog: n.aD.bound,
                onCloseTour: n.aD.bound,
                onTourEnd: n.aD.bound,
                setActiveTab: n.aD.bound,
                setActiveTabTutorial: n.aD.bound,
                setWebSocketState: n.aD.bound,
                setFAQSearchValue: n.aD.bound,
                faq_title: n.LO,
                setFaqTitle: n.aD.bound,
                setFileLoaded: n.aD.bound,
                setInfoPanelVisibility: n.aD.bound,
                setIsFileSupported: n.aD.bound,
                setPreviewOnDialog: n.aD.bound,
                setPreviewOnPopup: n.aD.bound,
                setActiveTour: n.aD.bound,
                setTourDialogVisibility: n.aD.bound,
                setOpenSettings: n.aD.bound,
                resetTutorialTabContent: n.aD.bound,
                filterTuotrialTab: n.aD.bound,
                show_toast: n.LO,
                show_mobile_tour_dialog: n.LO,
                showVideoDialog: n.aD.bound,
                strategy_save_type: n.LO,
                toast_message: n.LO,
                guide_tab_content: n.LO,
                faq_tab_content: n.LO,
                quick_strategy_tab_content: n.LO,
                video_tab_content: n.LO,
                setStrategySaveType: n.aD.bound,
                setShowMobileTourDialog: n.aD.bound,
                is_chart_modal_visible: n.LO,
                is_trading_view_modal_visible: n.LO,
              }),
              (this.root_store = e),
              (this.core = t);
            let i = [...(0, I.xH)()].map((e) => {
                var t;
                return `${e.search_id}# ${
                  null === (t = e.content) || void 0 === t
                    ? void 0
                    : t.toLowerCase()
                }`;
              }),
              o = [...(0, I.zw)()].map((e) => {
                var t;
                return `${e.search_id}# ${
                  null === (t = e.content) || void 0 === t
                    ? void 0
                    : t.toLowerCase()
                }`;
              }),
              s = (0, I.Mq)().map((e) => {
                var t;
                return `${e.search_id}# ${
                  null === (t = e.title) || void 0 === t
                    ? void 0
                    : t.toLowerCase()
                } ${e.description
                  .map((e) => {
                    let t = E().sanitize(e.content, { ALLOWED_TAGS: [] });
                    return null == t ? void 0 : t.toLowerCase();
                  })
                  .join(" ")}`;
              }),
              r = (e) => {
                if (!e) return [];
                let t = [];
                return (
                  e().forEach((e) => {
                    if ((null == e ? void 0 : e.type) !== "media") {
                      var i;
                      null === (i = e.content) ||
                        void 0 === i ||
                        i.forEach((e) => t.push(e));
                    }
                  }),
                  t
                );
              },
              l = (0, I.Yk)().map((e) => {
                var t, i, o;
                let s =
                    null === (t = e.content.join(" ")) || void 0 === t
                      ? void 0
                      : t.toLowerCase(),
                  a = r(null == A ? void 0 : A[e.qs_name]);
                return (
                  (a =
                    null === (i = a.join(" ")) || void 0 === i
                      ? void 0
                      : i.toLowerCase()),
                  `${e.search_id}# ${
                    null === (o = e.type) || void 0 === o
                      ? void 0
                      : o.toLowerCase()
                  } ${a + s}`
                );
              });
            (this.combined_search = [...i, ...o, ...s, ...l]),
              (0, n.U5)(
                () => this.is_preview_on_popup,
                async (e) => {
                  e && this.setPreviewOnPopup(!1);
                }
              ),
              this.initInfoPanel();
          }
        }
        var B = i(34606),
          P = i.n(B);
        class j {
          async trackRun() {
            let e = this.cleanXmlDom(
                window.Blockly.Xml.workspaceToDom(d.DBot.workspace, !0)
              ),
              t = (0, d.convertStrategyToIsDbot)(e),
              i = window.Blockly.Xml.domToText(t),
              o = this.getHash(i);
            this.getHash(this.strategy_content) !== o &&
              ((this.should_post_xml = !0), this.setStrategyContent(i)),
              this.setRunId(
                this.getHash(o + this.core.client.loginid + Math.random())
              ),
              this.setRunStart(this.core.common.server_time.unix());
          }
          async trackTransaction(e) {
            let t = await i.e("867").then(i.bind(i, 19028)),
              o = e[0];
            if (!o) return;
            let { buy: s } = o.data.transaction_ids;
            !Object.keys(this.transaction_ids).includes(s.toString()) &&
              ((this.transaction_ids[s] = this.IS_PENDING),
              fetch(
                `${this.endpoint}/${this.run_id}/${s}/${
                  this.run_start
                }/${this.getHash(this.strategy_content)}`,
                {
                  ...(this.should_post_xml
                    ? {
                        body: t.gzip(this.strategy_content),
                        headers: {
                          "Content-Encoding": "gzip",
                          "Content-Type": "application/xml",
                          Referer: window.location.hostname,
                        },
                      }
                    : {}),
                  method: "POST",
                  mode: "no-cors",
                }
              )
                .then(() => {
                  (this.should_post_xml = !1),
                    (this.transaction_ids[s] = this.IS_PROCESSED);
                })
                .catch(() => {
                  delete this.transaction_ids[s];
                }));
          }
          setRunId(e) {
            this.run_id = e;
          }
          setRunStart(e) {
            this.run_start = e;
          }
          setStrategyContent(e) {
            this.strategy_content = e;
          }
          constructor(e, t) {
            (0, a._)(this, "root_store", void 0),
              (0, a._)(this, "core", void 0),
              (0, a._)(this, "IS_PENDING", !1),
              (0, a._)(this, "IS_PROCESSED", !0),
              (0, a._)(
                this,
                "endpoint",
                "https://dbot-conf-dot-deriv-bi-reporting.as.r.appspot.com/dbotconf"
              ),
              (0, a._)(this, "run_id", ""),
              (0, a._)(this, "run_start", 0),
              (0, a._)(this, "should_post_xml", !0),
              (0, a._)(this, "strategy_content", ""),
              (0, a._)(this, "transaction_ids", {}),
              (0, a._)(this, "cleanXmlDom", (e) => {
                let t = ["x", "y", "id"],
                  i = (0, c.kIu)(e),
                  o = (e) => {
                    t.forEach((t) => e.removeAttribute(t)),
                      Array.from(e.children).forEach((e) => o(e));
                  };
                return o(i), i;
              }),
              (0, a._)(this, "getHash", (e) => btoa(String(P().str(e)))),
              (0, n.rC)(this, {
                IS_PENDING: n.LO,
                IS_PROCESSED: n.LO,
                endpoint: n.LO,
                run_id: n.LO,
                run_start: n.LO,
                should_post_xml: n.LO,
                strategy_content: n.LO,
                transaction_ids: n.LO,
                trackRun: n.aD.bound,
                trackTransaction: n.aD.bound,
                setRunId: n.aD.bound,
                setRunStart: n.aD.bound,
                setStrategyContent: n.aD.bound,
                cleanXmlDom: n.aD.bound,
                getHash: n.aD.bound,
              }),
              (this.root_store = e),
              (this.core = t),
              ((0, c.yvY)() ||
                /(.*?)\.binary.sx$/.test(window.location.hostname)) &&
                ((this.root_store = e),
                (0, n.U5)(
                  () => this.root_store.run_panel.is_running,
                  () =>
                    this.root_store.run_panel.is_running
                      ? this.trackRun()
                      : void 0
                ),
                (0, n.U5)(
                  () => this.root_store.transactions.transactions,
                  (e) => {
                    this.run_id && this.trackTransaction(e);
                  }
                ));
          }
        }
        var U = i(69103);
        let M = {
            text: () => [
              (0, h.NC)(
                "This block is mandatory. Here is where you can decide if your bot should continue trading. Only one copy of this block is allowed."
              ),
              (0, h.NC)(
                "This block is commonly used to adjust the parameters of your next trade and to implement stop loss/take profit logic."
              ),
            ],
          },
          F = {
            text: () => [
              (0, h.NC)("This block returns current account balance."),
              (0, h.NC)(
                'The only input parameter determines how block output is going to be formatted. In case if the input parameter is "string" then the account currency will be added.'
              ),
              (0, h.NC)("Example output of the below example will be:"),
              (0, h.NC)('1. for "string": 1325.68 USD'),
              (0, h.NC)('2. for "number": 1325.68'),
            ],
          },
          G = {
            text: () => [
              (0, h.NC)(
                "This block is mandatory. Only one copy of this block is allowed. It is added to the canvas by default when you open Deriv Bot."
              ),
              (0, h.NC)(
                "After defining trade parameters and trade options, you may want to instruct your bot to purchase contracts when specific conditions are met. To do that you can use conditional blocks and indicators blocks to help your bot to make decisions."
              ),
            ],
          },
          H = {
            text: () => [
              (0, h.NC)(
                'This block is used to determine if the market price moves in the selected direction or not. It gives you a value of "True" or "False".'
              ),
              (0, h.NC)("Examples:"),
              (0, h.NC)(
                '1. If the selected direction is "Rise", and the previous tick value is less than the current tick value, the output will be "True". Otherwise, the output will be an empty string.'
              ),
              (0, h.NC)(
                '2. If the selected direction is "Fall", and the previous tick value is more than the current tick value, the output will be "True". Otherwise, the output will be an empty string.'
              ),
            ],
          },
          V = {
            text: () => [
              (0, h.NC)(
                "This block displays messages in the developer’s console with an input that can be either a string of text, a number, boolean, or an array of data."
              ),
              (0, h.NC)("There are 4 message types:"),
              (0, h.NC)("1. 'Log' displays a regular message."),
              (0, h.NC)(
                "2. 'Warn' displays a message in yellow to highlight something that needs attention."
              ),
              (0, h.NC)(
                "3. 'Error' displays a message in red to highlight something that needs to be resolved immediately."
              ),
              (0, h.NC)(
                "4. 'Table' takes an array of data, such as a list of candles, and displays it in a table format."
              ),
            ],
          },
          W = {
            text: () => [
              (0, h.NC)(
                'You can check the result of the last trade with this block. It can only be placed within the "Restart trading conditions" root block.'
              ),
              (0, h.NC)(
                'If "Win" is selected, it will return "True" if your last trade was successful. Otherwise, it will return an empty string.'
              ),
              (0, h.NC)(
                'If "Loss" is selected, it will return "True" if your last trade was unsuccessful. Otherwise, it will return an empty string.'
              ),
              (0, h.NC)("Example:"),
            ],
          },
          Y = {
            text: () => [
              (0, h.NC)(
                "This block is used to either terminate or continue a loop, and can be placed anywhere within a loop block."
              ),
              (0, h.NC)("Examples:"),
              (0, h.NC)(
                '1. In the below example the loop is terminated in case "x" is "False" even though only one iteration is complete'
              ),
              (0, h.NC)(
                '2. In the below example the loop jumps to the next iteration without executing below block in case if "x" is "False"'
              ),
            ],
          },
          $ = {
            text: () => [
              (0, h.NC)(
                'This block uses the variable "i" to control the iterations. With each iteration, the value of "i" is determined by the items in a given list.'
              ),
              (0, h.NC)("Example:"),
              (0, h.NC)(
                '"i" starts with the value of 1, and it will be increased by 2 at every iteration. The loop will repeat until "i" reaches the value of 12, and then the loop is terminated.'
              ),
              (0, h.NC)(
                'You can use "i" inside the loop, for example to access list items'
              ),
            ],
          },
          q = {
            text: () => [
              (0, h.NC)(
                'This block uses the variable "i" to control the iterations. With each iteration, the value of "i" is determined by the items in a given list.'
              ),
              (0, h.NC)("Example:"),
              (0, h.NC)(
                'In this example, the loop will repeat three times, as that is the number of items in the given list. During each iteration, the variable "i" will be assigned a value from the list. '
              ),
              (0, h.NC)(
                'Please note that changing the value of "i" won\'t change the value of the original item in the list'
              ),
            ],
          },
          z = {
            text: () => [
              (0, h.NC)(
                "This block evaluates a statement and will perform an action only when the statement is true."
              ),
              (0, h.NC)(
                "Click the plus icon to extend the functionality of this block."
              ),
              (0, h.NC)(
                'You can also use "Compare" and "Logic operation" blocks to make test variables.'
              ),
            ],
          },
          K = {
            text: () => [
              (0, h.NC)(
                "This block repeats instructions as long as a given condition is true."
              ),
              (0, h.NC)("Examples:"),
              (0, h.NC)(
                "1. In the example below, the instructions are repeated as long as the value of x is less than or equal to 10. Once the value of x exceeds 10, the loop is terminated."
              ),
              (0, h.NC)(
                "2. In this example, the instructions are repeated as long as the value of x is greater than or equal to 10. Once the value of x drops below 10, the loop is terminated."
              ),
            ],
          },
          X = {
            text: () => [
              (0, h.NC)(
                "Here is where you can decide to sell your contract before it expires. Only one copy of this block is allowed."
              ),
              (0, h.NC)("Example:"),
            ],
          },
          Z = {
            text: () => [
              (0, h.NC)(
                '"Seconds Since Epoch" block returns the number of seconds since January 1st, 1970.'
              ),
              (0, h.NC)("Example:"),
              (0, h.NC)(
                "1551661986 seconds since Jan 01 1970 (UTC) translates to 03/04/2019 @ 1:13am (UTC)."
              ),
              (0, h.NC)(
                "You might need it when you want to repeat an actions after certain amount of time."
              ),
              (0, h.NC)(
                "The example below restarts trading after 30 or more seconds after 1 minute candle was started."
              ),
            ],
          },
          J = {
            text: () => [
              (0, h.NC)(
                "This block gives you a specific candle from within the selected time interval."
              ),
              (0, h.NC)(
                'In this example, the open price of a candle is assigned to the variable "candle_open_price".'
              ),
              (0, h.NC)(
                "In the above example it is assumed that variable candle_open_price is processed somewhere within other blocks."
              ),
            ],
          },
          Q = {
            text: () => [
              (0, h.NC)(
                'This block returns "True" if the last candle is black. It can be placed anywhere on the canvas except within the Trade parameters root block.'
              ),
              (0, h.NC)(
                'The term "candle" refers to each bar on the candlestick chart. Each candle represents four market prices for the selected time interval:'
              ),
              (0, h.NC)(
                "Each candlestick on the chart represents 4 market prices for the selected time interval:"
              ),
              (0, h.NC)("- Open price: the opening price"),
              (0, h.NC)("- High price: the highest price"),
              (0, h.NC)("- Low price: the lowest price"),
              (0, h.NC)("- Close price: the closing price"),
              (0, h.NC)(
                "A black (or red) candle indicates that the open price is higher than the close price. This represents a downward movement of the market price."
              ),
              (0, h.NC)(
                "A white (or green) candle indicates that the open price is lower than the close price. This represents an upward movement of the market price."
              ),
              (0, h.NC)(
                "The time interval for each candle can be set from one minute to one day."
              ),
            ],
          },
          ee = {
            text: () => [
              (0, h.NC)(
                "This block gives you the last digit of the latest tick value of the selected market. If the latest tick value is 1410.90, this block will return 0. It’s useful for digit-based contracts such as Even/Odd, Matches/Differs, or Higher/Lower."
              ),
            ],
          },
          et = {
            text: () => [
              (0, h.NC)(
                'This block performs the "AND" or the "OR" logic operation with the given values.'
              ),
              (0, h.NC)(
                'In case if the "AND" operation is selected, the block returns "True" only if both given values are "True"'
              ),
              (0, h.NC)(
                'In case if the "OR" operation is selected, the block returns "True" in case if one or both given values are "True"'
              ),
            ],
          },
          ei = {
            text: () => [
              (0, h.NC)(
                "This block performs arithmetic operations between two numbers."
              ),
              (0, h.NC)("Available operations:"),
              (0, h.NC)("- Addition"),
              (0, h.NC)("- Subtraction"),
              (0, h.NC)("- Multiplication"),
              (0, h.NC)("- Division"),
              (0, h.NC)(
                "- Raise the first number to the power of the second number"
              ),
            ],
          },
          eo = {
            text: () => [
              (0, h.NC)(
                "This block constrains a given number within a set range."
              ),
              (0, h.NC)(
                "In case if the given number is less than the lower boundary of the range, the block returns the lower boundary value. Similarly, if the given number is greater than the higher boundary, the block will return the higher boundary value. In case if the given value is between boundaries, the block will return the given value unchanged."
              ),
              (0, h.NC)(
                "In the below example the block returns the value of 10 as the given value (5) is less than the lower boundary (10)"
              ),
            ],
          },
          es = {
            text: () => [
              (0, h.NC)(
                "This block performs the following operations to a given number"
              ),
              (0, h.NC)("Available operations are:"),
              (0, h.NC)("- Square root"),
              (0, h.NC)("- Absolute"),
              (0, h.NC)("- Negation"),
              (0, h.NC)("- Natural log"),
              (0, h.NC)(
                "- Euler’s number (2.71) to the power of a given number"
              ),
              (0, h.NC)("- 10 to the power of a given number"),
            ],
          },
          er = {
            text: () => [
              (0, h.NC)(
                "This block sends a message to a Telegram channel. You will need to create your own Telegram bot to use this block."
              ),
              (0, h.NC)("Here’s how:"),
              (0, h.NC)(
                "1. Create a Telegram bot and get your Telegram API token. Read more on how to create bots in Telegram here: https://core.telegram.org/bots#6-botfather"
              ),
              (0, h.NC)(
                "2. Start a chat with your newly created Telegram bot and make sure to send it some messages before proceeding to the next step. (e.g. Hello Bot!)"
              ),
              (0, h.NC)(
                "3. Get the chat ID using the Telegram REST API (read more: https://core.telegram.org/bots/api#getupdates)"
              ),
              (0, h.NC)(
                "- Visit the following URL, make sure to replace <access_token> with the Telegram API token you created in Step 1: https://api.telegram.org/bot<access_token>/getUpdates"
              ),
              (0, h.NC)(
                "- Find the chat ID property in the response, and copy the value of the id property"
              ),
              (0, h.NC)(
                "4. Come back to Deriv Bot and add the Notify Telegram block to the workspace. Paste the Telegram API token and chat ID into the block fields accordingly."
              ),
            ],
          },
          ea = {
            text: () => [
              (0, h.NC)(
                "This block gives you a list of candles within a selected time interval."
              ),
              (0, h.NC)(
                'In this example, this block is used with another block to get the open prices from a list of candles. The open prices are then assigned to the variable called "cl".'
              ),
            ],
          },
          en = {
            text: () => [
              (0, h.NC)(
                "This block gives you the selected candle value from a list of candles within the selected time interval. You can choose from open price, close price, high price, low price, and open time."
              ),
              (0, h.NC)(
                'In this example, the open prices from a list of candles are assigned to a variable called "candle_list".'
              ),
            ],
          },
          el = {
            text: () => [
              (0, h.NC)(
                "This block gives you the selected candle value from a list of candles. You can choose from open price, close price, high price, low price, and open time."
              ),
              (0, h.NC)(
                "This block requires a list of candles as an input parameter."
              ),
              (0, h.NC)(
                'In this example, the open prices from a list of candles are assigned to a variable called "cl".'
              ),
            ],
          },
          ec = {
            text: () => [
              (0, h.NC)(
                "Used within a function block, this block returns a value when a specific condition is true."
              ),
              (0, h.NC)("Example:"),
            ],
          },
          ed = {
            text: () => [
              (0, h.NC)(
                "This block gives you information about your last contract."
              ),
              (0, h.NC)("You can choose to see one of the following:"),
              (0, h.NC)(
                "- Deal reference ID: the reference ID of the contract"
              ),
              (0, h.NC)(
                "- Purchase price: the purchase price (stake) of the contract"
              ),
              (0, h.NC)("- Payout: the payout of the contract"),
              (0, h.NC)("- Profit: the profit you’ve earned"),
              (0, h.NC)(
                "- Contract type: the name of the contract type such as Rise, Fall, Touch, No Touch, etс."
              ),
              (0, h.NC)("- Entry time: the starting time of the contract"),
              (0, h.NC)(
                "- Entry value: the value of the first tick of the contract"
              ),
              (0, h.NC)("- Exit time: the contract expiration time"),
              (0, h.NC)(
                "- Exit value: the value of the last tick of the contract"
              ),
              (0, h.NC)(
                "- Barrier: the barrier value of the contract (applicable to barrier-based trade types such as stays in/out, touch/no touch, etc.)"
              ),
              (0, h.NC)(
                '- Result: the result of the last contract: "win" or "loss"'
              ),
            ],
          },
          eu = {
            text: () => [
              (0, h.NC)(
                "This block gives you the specified candle value for a selected time interval. You can choose which value you want:"
              ),
              (0, h.NC)("- Open: the opening price"),
              (0, h.NC)("- High: the highest price"),
              (0, h.NC)("- Low: the lowest price"),
              (0, h.NC)("- Close: the closing price"),
              (0, h.NC)("- Open time: the opening time stamp"),
              (0, h.NC)(
                'In the example below, the opening price is selected, which is then assigned to a variable called "op".'
              ),
            ],
          },
          eh = {
            text: () => [
              (0, h.NC)(
                "This block gives you the selected candle value such as open price, close price, high price, low price, and open time. It requires a candle as an input parameter."
              ),
              (0, h.NC)(
                'In the example below, the open price is assigned to the variable "op".'
              ),
            ],
          },
          ep = {
            text: () => [
              (0, h.NC)(
                "Use this block to sell your contract at the market price. Selling your contract is optional. You may choose to sell if the market trend is unfavourable."
              ),
              (0, h.NC)("Example:"),
            ],
          },
          e_ = {
            text: () => [
              (0, h.NC)(
                'This block gives you the potential profit or loss if you decide to sell your contract. It can only be used within the "Sell conditions" root block.'
              ),
              (0, h.NC)(
                "In the example below, the contract will only be sold if the potential profit or loss is more than the stake."
              ),
            ],
          },
          em = {
            text: () => [
              (0, h.NC)(
                "SMA adds the market price in a list of ticks or candles for a number of time periods, and divides the sum by that number of time periods."
              ),
              (0, h.NC)("The formula for SMA is:"),
              (0, h.NC)("where n is the number of periods."),
              "",
              (0, h.NC)("What SMA tells you"),
              (0, h.NC)(
                "SMA serves as an indicator of the trend. If the SMA points up then the market price is increasing and vice versa. The larger the period number, the smoother SMA line is."
              ),
              (0, h.NC)(
                "In this example, each point of the SMA line is an arithmetic average of close prices for the last 10 days."
              ),
              (0, h.NC)(
                "In this example, each point of the SMA line is an arithmetic average of close prices for the last 50 days."
              ),
              "",
              (0, h.NC)("How to use the SMA block"),
              (0, h.NC)(
                "Input list accepts a list of ticks or candles, while period is the specified time period."
              ),
              (0, h.NC)("Example:"),
              (0, h.NC)(
                "This will display the SMA for the specified period, using a candle list."
              ),
              (0, h.NC)(
                "SMA places equal weight to the entire distribution of values."
              ),
              (0, h.NC)(
                "This is the same as the above example, using a tick list."
              ),
              (0, h.NC)(
                "You may compare SMA values calculated on every bot run to identify the market trend direction. Alternatively, you may also use a variation of the SMA block, the Simple Moving Average Array block. "
              ),
              (0, h.NC)(
                "This block returns the entire SMA line, containing a list of all values for a given period."
              ),
              (0, h.NC)(
                "If a period of 10 is entered, the Simple Moving Average Array block will return a list of SMA values calculated based on period of 10."
              ),
              (0, h.NC)(
                "The below image illustrates how Simple Moving Average Array block works:"
              ),
            ],
          },
          eg = {
            text: () => [
              (0, h.NC)(
                'This block displays a dialog box with a customised message. When the dialog box is displayed, your strategy is paused and will only resume after you click "OK".'
              ),
            ],
          },
          ey = {
            text: () => [
              (0, h.NC)(
                'This block displays a dialog box that uses a customised message to prompt for an input. The input can be either a string of text or a number and can be assigned to a variable. When the dialog box is displayed, your strategy is paused and will only resume after you enter a response and click "OK".'
              ),
            ],
          },
          ev = {
            text: () => [
              (0, h.NC)(
                "Any blocks placed within this block will be executed at every tick. If the default candle interval is set to 1 minute in the Trade Parameters root block, the instructions in this block will be executed once every minute. Place this block outside of any root block."
              ),
            ],
          },
          ef = {
            text: () => [
              (0, h.NC)(
                "This block converts the number of seconds since the Unix Epoch to a date and time format such as 2019-08-01 00:00:00."
              ),
              (0, h.NC)("Example:"),
              (0, h.NC)(
                "In this example, the date and time will be displayed in a green notification box."
              ),
            ],
          },
          eb = {
            text: () => [
              (0, h.NC)(
                "This block converts the date and time to the number of seconds since the Unix Epoch (1970-01-01 00:00:00)."
              ),
              (0, h.NC)("Example:"),
              (0, h.NC)(
                "In this example, a Rise contract will be purchased at midnight on 1 August 2019."
              ),
            ],
          },
          ew = {
            text: () => [
              (0, h.NC)(
                "This block will transfer the control back to the Purchase conditions block, enabling you to purchase another contract without manually stopping and restarting your bot."
              ),
              (0, h.NC)("Example:"),
            ],
          },
          ek = {
            text: () => [
              (0, h.NC)(
                "This block is mandatory. It's added to your strategy by default when you create new strategy. You can not add more than one copy of this block to the canvas."
              ),
              (0, h.NC)("1. Market"),
              (0, h.NC)(
                "Select your desired market and asset type. For example, Forex > Major pairs > AUD/JPY"
              ),
              (0, h.NC)("2. Trade Type"),
              (0, h.NC)(
                "Select your desired trade type. For example, Up/Down > Rise/Fall"
              ),
              (0, h.NC)("3. Contract Type"),
              (0, h.NC)(
                "Choose what type of contract you want to trade. For example, for the Rise/Fall trade type you can choose one of three options: Rise, Fall, or Both. Selected option will determine available options for the Purchase block."
              ),
              (0, h.NC)("4. Default Candle Interval"),
              (0, h.NC)(
                "Sets the default time interval for blocks that read list of candles."
              ),
              (0, h.NC)("5. Restart buy/sell on error"),
              (0, h.NC)("Restarts the bot when an error is encountered."),
              (0, h.NC)("6. Restart last trade on error"),
              (0, h.NC)(
                "Repeats the previous trade when an error is encountered."
              ),
              (0, h.NC)("7. Run Once at Start"),
              (0, h.NC)(
                "Place blocks here to perform tasks once when your bot starts running."
              ),
              (0, h.NC)("8. Trade Options"),
              (0, h.NC)(
                "The desired duration, stake, prediction, and/or barrier(s) for the contract is defined here."
              ),
            ],
          };
        var eC = i(31865);
        let eT = {
            text: () => [
              (0, h.NC)(
                "Use this block when you want to use multipliers as your trade type."
              ),
              (0, h.NC)(
                "Click the multiplier drop-down menu and choose the multiplier value you want to trade with."
              ),
              (0, h.NC)(
                "Your potential profit will be multiplied by the multiplier value you’ve chosen."
              ),
              (0, s.jsx)(
                h.Xx,
                {
                  i18n_default_text:
                    "To learn more about multipliers, please go to the <0>Multipliers</0> page.",
                  components: [
                    (0, s.jsx)(
                      eC.Z,
                      { className: "link", href: "trade-types/multiplier" },
                      0
                    ),
                  ],
                },
                0
              ),
            ],
          },
          eN = {
            text: () => [
              (0, h.NC)(
                "This block is used to define trade options within the Trade parameters root block. Some options are only applicable for certain trade types. Parameters such as duration and stake are common among most trade types. Prediction is used for trade types such as Digits, while barrier offsets are for trade types that involve barriers such as Touch/No Touch, Ends In/Out, etc."
              ),
              (0, h.NC)("Example:"),
            ],
          },
          eS = {
            text: () => [
              (0, h.NC)(
                "This block assigns a given value to a variable, creating the variable if it doesn't already exist."
              ),
              (0, h.NC)(
                "A variable is among the most important and powerful components in creating a bot. It is a way to store information, either as text or numbers. The information stored as a variable can be used and changed according to the given instructions. Variables can be given any name, but usually they are given useful, symbolic names so that it is easier to call them during the execution of instructions."
              ),
              (0, h.NC)("Creating a variable"),
              (0, h.NC)(
                "1. From the block library, enter a name for the new variable and click Create."
              ),
              (0, h.NC)(
                "2. The new variable will appear as a block under Set variable."
              ),
            ],
          };
        class ex {
          setActiveHelper(e) {
            this.active_helper = e;
          }
          onBackClick() {
            let { toolbox: e, flyout: t } = this.root_store;
            if (t.is_search_flyout) {
              let t = document.getElementsByName("search")[0].value;
              e.onSearch({ search: t });
            } else t.refreshCategory();
          }
          async onSequenceClick(e) {
            let t;
            let o = Array.from(this.xml_list).find(
              (e) => e.getAttribute("type") === this.block_type
            );
            Object.keys(this.xml_list_group).forEach((e, i) => {
              o.getAttribute("type") === e && (t = i);
            });
            let s = async (e, t, o) => {
                let r = t + (o ? 1 : -1),
                  a = Object.keys(e).filter((e, t) => (o ? r <= t : r >= t)),
                  n = await this.getFilledBlocksIndex(a),
                  l = a[o ? n[0] : n[n.length - 1]];
                if (!l) return !1;
                try {
                  return await Promise.resolve().then(i.bind(i, 88199)), l;
                } catch (t) {
                  return s(e, r, o);
                }
              },
              r = await s(this.xml_list_group, t, e);
            if (r) {
              let e = this.xml_list_group[r];
              this.setHelpContent(e[0]);
            }
          }
          initFlyoutHelp(e) {
            let { flyout: t, toolbox: i } = this.root_store;
            (this.xml_list = i.getCategoryContents(t.selected_category)),
              (this.xml_list_group = this.groupBy(this.xml_list, !0)),
              this.setHelpContent(e);
          }
          async updateSequenceButtons() {
            let e = Array.from(this.xml_list).find(
                (e) => e.getAttribute("type") === this.block_type
              ),
              t = Object.keys(this.xml_list_group).findIndex(
                (t) => e.getAttribute("type") === t
              ),
              i = await this.getNextHelpContentIndex(!0),
              o = await this.getNextHelpContentIndex(!1);
            (0, n.z)(() => {
              (this.should_previous_disable = 0 === t || t === o),
                (this.should_next_disable =
                  t === Object.keys(this.xml_list_group).length - 1 || t === i);
            });
          }
          groupBy(e) {
            let t =
              arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            return Array.from(e).reduce((e, i) => {
              let o = i.getAttribute("type");
              return (
                (t && null === o) ||
                  (e[o] || (e[o] = []),
                  (!t || (t && null !== o)) && e[o].push(i)),
                e
              );
            }, {});
          }
          setExamples(e) {
            let { toolbox: t } = this.root_store,
              i = [...t.toolbox_examples.childNodes],
              o = (0, U.S)(window.__webpack_public_path__)
                [e].filter((e) => "example" === e.type)
                .map((e) => e.example_id)
                .map((e) => i.find((t) => t.id === e));
            this.examples = o;
          }
          constructor(e) {
            (0, a._)(this, "root_store", void 0),
              (0, a._)(this, "block_node", null),
              (0, a._)(this, "block_type", ""),
              (0, a._)(this, "examples", []),
              (0, a._)(this, "help_string", {}),
              (0, a._)(this, "title", ""),
              (0, a._)(this, "should_next_disable", !1),
              (0, a._)(this, "should_previous_disable", !1),
              (0, a._)(this, "active_helper", ""),
              (0, a._)(this, "setHelpContent", async (e) => {
                let t = e.getAttribute("type"),
                  i = window.Blockly.Blocks[t].meta().display_name;
                "" !== t && (this.active_helper = t);
                let { flyout: s } = this.root_store;
                this.setExamples(t);
                let r = this.examples.map((e) => e.childNodes[0]);
                setTimeout(() => s.setFlyoutWidth([e, ...r]), 50),
                  (0, n.z)(() => {
                    if (
                      ((s.is_help_content = !0),
                      (this.block_node = e),
                      (this.block_type = t),
                      (this.title = i),
                      "" !== t)
                    )
                      for (let [e, i] of Object.entries(o[t]))
                        this.help_string[e] = i();
                  }),
                  s.is_search_flyout || this.updateSequenceButtons();
              }),
              (0, a._)(this, "getHelpContent", async (e) => {
                let t;
                return (
                  e && (t = o[this.xml_list_group[e][0].getAttribute("type")]),
                  t
                );
              }),
              (0, a._)(this, "getFilledBlocksIndex", async (e) =>
                (await Promise.all(e.map((e) => this.getHelpContent(e))))
                  .map((e, t) => (e ? t : null))
                  .filter((e) => null !== e)
              ),
              (0, a._)(this, "getNextHelpContentIndex", async (e) => {
                let t = await this.getFilledBlocksIndex(
                  Object.keys(this.xml_list_group)
                );
                return e ? t[t.length - 1] : t[0];
              }),
              (0, n.rC)(this, {
                block_node: n.LO,
                block_type: n.LO,
                examples: n.LO,
                help_string: n.LO,
                title: n.LO,
                should_next_disable: n.LO,
                should_previous_disable: n.LO,
                active_helper: n.LO,
                setHelpContent: n.aD.bound,
                setActiveHelper: n.aD.bound,
                onBackClick: n.aD.bound,
                onSequenceClick: n.aD.bound,
                initFlyoutHelp: n.aD.bound,
                updateSequenceButtons: n.aD.bound,
                setExamples: n.aD.bound,
                getHelpContent: n.aD.bound,
                getFilledBlocksIndex: n.aD.bound,
                getNextHelpContentIndex: n.aD.bound,
              }),
              (this.root_store = e);
          }
        }
        var eE = i(18908);
        class eD {
          onMount() {
            this.initFlyout(),
              window.addEventListener("click", this.onClickOutsideFlyout);
          }
          onUnmount() {
            window.removeEventListener("click", this.onClickOutsideFlyout);
          }
          initFlyout() {
            var e, t, i;
            let o = window.Blockly.derivWorkspace,
              s = new window.Blockly.Options({
                parentWorkspace: o,
                rtl: o.RTL,
                horizontalLayout: !0,
                theme:
                  null === (i = window) || void 0 === i
                    ? void 0
                    : null === (t = i.Blockly) || void 0 === t
                    ? void 0
                    : null === (e = t.Themes) || void 0 === e
                    ? void 0
                    : e.zelos_renderer,
              });
            o.horizontalLayout
              ? (this.flyout = new window.Blockly.HorizontalFlyout(s))
              : (this.flyout = new window.Blockly.VerticalFlyout(s)),
              (this.flyout.targetWorkspace = o),
              (this.flyout.workspace_.targetWorkspace = o),
              (this.flyout.workspace_.getGesture =
                this.flyout.targetWorkspace.getGesture.bind(
                  this.flyout.targetWorkspace_
                )),
              (o.VariableMap = this.flyout.targetWorkspace.getVariableMap()),
              this.flyout.workspace_.createPotentialVariableMap();
          }
          initBlockWorkspace(e, t) {
            var i, o, s, r, a, n, l, c, d;
            let u = window.Blockly.inject(e, this.options);
            u.targetWorkspace = window.Blockly.derivWorkspace;
            let h = window.Blockly.Xml.domToBlock(t, u),
              p = h.getHeightWidth();
            (h.isInFlyout = !0),
              (e.style.height = `${
                Math.ceil(p.height * this.options.zoom.startScale) + 1
              }px`),
              (e.style.width = `${
                Math.ceil(p.width * this.options.zoom.startScale) + 1
              }px`),
              h.moveBy(1, 1);
            let _ = h.getSvgRoot();
            this.block_listeners.push(
              null === (s = window) || void 0 === s
                ? void 0
                : null === (o = s.Blockly) || void 0 === o
                ? void 0
                : null === (i = o.browserEvents) || void 0 === i
                ? void 0
                : i.conditionalBind(_, "mousedown", null, (e) => {
                    var t;
                    null === eE.default ||
                      void 0 === eE.default ||
                      null === (t = eE.default.pushDataLayer) ||
                      void 0 === t ||
                      t.call(eE.default, {
                        event: "dbot_drag_block",
                        block_type: h.type,
                      }),
                      this.flyout.blockMouseDown(h)(e);
                  }),
              null === (n = window) || void 0 === n
                ? void 0
                : null === (a = n.Blockly) || void 0 === a
                ? void 0
                : null === (r = a.browserEvents) || void 0 === r
                ? void 0
                : r.bind(_, "mouseout", h, h.removeSelect),
              null === (d = window) || void 0 === d
                ? void 0
                : null === (c = d.Blockly) || void 0 === c
                ? void 0
                : null === (l = c.browserEvents) || void 0 === l
                ? void 0
                : l.bind(_, "mouseover", h, h.addSelect)
            ),
              this.block_workspaces.push(u),
              window.Blockly.svgResize(u);
          }
          getFlyout() {
            return this.flyout;
          }
          setContents(e) {
            let t =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : "";
            this.block_listeners.forEach((e) =>
              window.Blockly.browserEvents.unbind(e)
            ),
              this.block_workspaces.forEach((e) => e.dispose()),
              (this.block_listeners = []),
              (this.block_workspaces = []),
              (this.is_help_content = !1),
              (this.search_term =
                t.length > 20 ? `${t.substring(0, 20)}...` : t),
              (this.flyout_content = e),
              this.setFlyoutWidth(e),
              this.setVisibility(!0),
              setTimeout(() => this.setFlyoutWidth(e), 50);
          }
          setFlyoutWidth(e) {
            let t = 0;
            e.forEach((e) => {
              if (e.tagName.toUpperCase() === window.Blockly.Xml.NODE_BLOCK) {
                let i = window.Blockly.Block.getDimensions(e);
                e.setAttribute(
                  "width",
                  String(Math.ceil(i.width * this.options.zoom.startScale))
                ),
                  e.setAttribute(
                    "height",
                    String(Math.ceil(i.height * this.options.zoom.startScale))
                  ),
                  (t = Math.max(
                    t,
                    Math.ceil(i.width * this.options.zoom.startScale)
                  ));
              }
            }),
              (this.flyout_width = Math.max(this.flyout_min_width, t + 65));
          }
          setVisibility(e) {
            (this.is_visible = e),
              e || (this.setSelectedCategory(null), (this.flyout_content = [])),
              (window.Blockly.derivWorkspace.isFlyoutVisible = e);
          }
          setIsSearchFlyout(e) {
            this.is_search_flyout = e;
          }
          setSelectedCategory(e) {
            this.selected_category = e;
          }
          getSelectedCategory() {
            return this.selected_category;
          }
          onClickOutsideFlyout(e) {
            if (!this.is_visible || !window.Blockly.derivWorkspace) return;
            let t = document.getElementById("gtm-toolbox"),
              i = ((null == e ? void 0 : e.composedPath()) || []).some(
                (e) => e.classList && e.classList.contains("flyout")
              ),
              o = this.root_store.toolbox.is_search_focus;
            i ||
              (null == t ? void 0 : t.contains(e.target)) ||
              o ||
              (this.setVisibility(!1), this.setSelectedCategory(null));
          }
          refreshCategory() {
            let e = this.getSelectedCategory(),
              { toolbox: t } = this.root_store,
              i = t.getCategoryContents(e);
            this.setContents(i);
          }
          get variables_blocks_count() {
            return this.flyout_content.filter(
              (e) => "variables_get" === e.getAttribute("type")
            ).length;
          }
          get first_get_variable_block_index() {
            return this.flyout_content.length - this.variables_blocks_count;
          }
          constructor(e) {
            var t, i, o;
            (0, a._)(this, "root_store", void 0),
              (0, a._)(this, "flyout", null),
              (0, a._)(this, "block_listeners", []),
              (0, a._)(this, "block_workspaces", []),
              (0, a._)(this, "flyout_min_width", 440),
              (0, a._)(this, "options", {
                renderer: "zelos",
                media: "assets/media/",
                move: { scrollbars: !1, drag: !0, wheel: !1 },
                zoom: {
                  startScale: (0, d.config)().workspaces
                    .flyoutWorkspacesStartScale,
                },
                sounds: !1,
                theme:
                  null === (o = window) || void 0 === o
                    ? void 0
                    : null === (i = o.Blockly) || void 0 === i
                    ? void 0
                    : null === (t = i.Themes) || void 0 === t
                    ? void 0
                    : t.zelos_renderer,
              }),
              (0, a._)(this, "is_help_content", !1),
              (0, a._)(this, "flyout_content", []),
              (0, a._)(this, "flyout_width", this.flyout_min_width),
              (0, a._)(this, "is_visible", !1),
              (0, a._)(this, "is_search_flyout", !1),
              (0, a._)(this, "is_loading", !1),
              (0, a._)(this, "search_term", ""),
              (0, a._)(this, "selected_category", null),
              (0, n.rC)(this, {
                is_help_content: n.LO,
                flyout_content: n.LO,
                flyout_width: n.LO,
                is_visible: n.LO,
                is_search_flyout: n.LO,
                is_loading: n.LO,
                search_term: n.LO,
                selected_category: n.LO,
                onMount: n.aD.bound,
                onUnmount: n.aD.bound,
                initFlyout: n.aD.bound,
                initBlockWorkspace: n.aD.bound,
                getFlyout: n.aD.bound,
                setContents: n.aD.bound,
                setFlyoutWidth: n.aD.bound,
                setVisibility: n.aD.bound,
                setIsSearchFlyout: n.aD.bound,
                setSelectedCategory: n.aD.bound,
                getSelectedCategory: n.aD.bound,
                onClickOutsideFlyout: n.aD.bound,
                refreshCategory: n.aD.bound,
                variables_blocks_count: n.Fl,
                first_get_variable_block_index: n.Fl,
              }),
              (this.root_store = e);
          }
        }
        let eO = Object.freeze({ NORMAL: 0, LOADING: 1, COMPLETED: 2 });
        var eA = i(89057),
          eI = i(66062);
        class eL {
          setIsAuthorized(e) {
            this.is_authorised = e;
          }
          async signIn() {
            this.is_authorised || (await this.client.requestAccessToken());
          }
          async signOut() {
            if (this.access_token) {
              var e, t, i, o, s, r, a, n;
              await (null === (i = window) || void 0 === i
                ? void 0
                : null === (t = i.gapi) || void 0 === t
                ? void 0
                : null === (e = t.client) || void 0 === e
                ? void 0
                : e.setToken({ access_token: "" })),
                localStorage.getItem("google_access_token") &&
                  (await (null === (a = window) || void 0 === a
                    ? void 0
                    : null === (r = a.google) || void 0 === r
                    ? void 0
                    : null === (s = r.accounts) || void 0 === s
                    ? void 0
                    : null === (o = s.oauth2) || void 0 === o
                    ? void 0
                    : o.revoke(this.access_token)),
                  null === (n = localStorage) ||
                    void 0 === n ||
                    n.removeItem("google_access_token")),
                (this.access_token = "");
            }
            this.setIsAuthorized(!1);
          }
          getPickerLanguage() {
            let e = (0, h.Jb)();
            return "zhTw" === e ? "zh-TW" : "zhCn" === e ? "zh-CN" : e;
          }
          async saveFile(e) {
            try {
              await this.signIn(),
                this.access_token &&
                  gapi.client.setToken({ access_token: this.access_token }),
                await this.checkFolderExists(),
                await this.createSaveFilePicker(
                  "application/vnd.google-apps.folder",
                  (0, h.NC)("Select a folder"),
                  e
                );
            } catch (e) {
              401 === e.status && this.signOut();
            }
          }
          async loadFile() {
            if (this.is_google_drive_token_valid) {
              await this.signIn(),
                this.access_token &&
                  gapi.client.setToken({ access_token: this.access_token });
              try {
                await gapi.client.drive.files.list({
                  pageSize: 10,
                  fields: "files(id, name)",
                });
              } catch (s) {
                var e, t, i, o;
                if ((null == s ? void 0 : s.status) === 401) {
                  await this.signOut();
                  let e = document.getElementsByClassName(
                      "picker-dialog-content"
                    )[0],
                    t = null == e ? void 0 : e.parentNode;
                  e &&
                    t &&
                    (null == t ? void 0 : t.contains(e)) &&
                    (null == t || t.removeChild(e)),
                    null == e ||
                      null === (o = e.parentNode) ||
                      void 0 === o ||
                      o.removeChild(e);
                  let i = document.getElementsByClassName("picker-dialog-bg");
                  if (i.length)
                    for (let e = 0; e < i.length; e++)
                      i[e].style.display = "none";
                }
                (0, eA.mu)({
                  upload_provider: "google_drive",
                  upload_id: this.upload_id,
                  upload_type: "not_found",
                  error_message:
                    null == s
                      ? void 0
                      : null === (t = s.result) || void 0 === t
                      ? void 0
                      : null === (e = t.error) || void 0 === e
                      ? void 0
                      : e.message,
                  error_code:
                    null == s
                      ? void 0
                      : null === (i = s.status) || void 0 === i
                      ? void 0
                      : i.toString(),
                });
              }
              return await this.createLoadFilePicker(
                "text/xml,application/xml",
                (0, h.NC)("Select a Deriv Bot Strategy")
              );
            }
          }
          async checkFolderExists() {
            var e;
            let { files: t } = gapi.client.drive,
              i = await t.list({ q: "trashed=false" }),
              o = "application/vnd.google-apps.folder";
            (null === (e = i.result.files) ||
              void 0 === e ||
              !e.find((e) => e.mimeType === o)) &&
              (await t.create({
                resource: { name: this.bot_folder_name, mimeType: o },
                fields: "id",
              }));
          }
          createSaveFilePicker(e, t, i) {
            let { setButtonStatus: o } = this.root_store.save_modal;
            return new Promise((s) => {
              this.showGoogleDriveFilePicker(!0, e, t, (e) => {
                if (e.action === google.picker.Action.PICKED) {
                  let t = e.docs[0].id,
                    r = new Blob([i.content], { type: i.mimeType }),
                    a = JSON.stringify({
                      name: i.name,
                      mimeType: i.mimeType,
                      parents: [t],
                    }),
                    n = new FormData();
                  n.append(
                    "metadata",
                    new Blob([a], { type: "application/json" })
                  ),
                    n.append("file", r);
                  let l = new XMLHttpRequest();
                  (l.responseType = "json"),
                    l.open(
                      "POST",
                      "https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart"
                    ),
                    l.setRequestHeader(
                      "Authorization",
                      `Bearer ${this.access_token}`
                    ),
                    (l.onload = () => {
                      401 === l.status && this.signOut(), o(eO.NORMAL), s();
                    }),
                    l.send(n);
                } else e.action === google.picker.Action.CANCEL && o(eO.NORMAL);
              });
            });
          }
          createLoadFilePicker(e, t) {
            return new Promise((i) => {
              let o = async (e) => {
                if (e.action === google.picker.Action.PICKED) {
                  let t = e.docs[0];
                  (null == t ? void 0 : t.driveError) === "NETWORK" &&
                    (0, eA.mu)({
                      upload_provider: "google_drive",
                      upload_id: this.upload_id,
                      upload_type: "not_found",
                      error_message: "File not found",
                      error_code: "404",
                    });
                  let o = t.name,
                    s = t.id,
                    { files: r } = gapi.client.drive,
                    { setOpenSettings: a } = this.root_store.dashboard,
                    n = await r.get({ alt: "media", fileId: s });
                  i({ xml_doc: n.body, file_name: o }), a(O.tx.BOT_IMPORT);
                  let l = (0, eI.dC)(n.body);
                  (0, eA.WN)({
                    upload_provider: "google_drive",
                    upload_type: l,
                    upload_id: this.upload_id,
                  });
                }
              };
              this.showGoogleDriveFilePicker(!1, e, t, o);
            });
          }
          showGoogleDriveFilePicker(e, t, i, o) {
            let s = new google.picker.DocsView();
            s.setIncludeFolders(!0),
              s.setMimeTypes(t),
              e && s.setSelectFolderEnabled(!0),
              new google.picker.PickerBuilder()
                .setOrigin(
                  `${window.location.protocol}//${window.location.host}`
                )
                .setTitle((0, h.NC)(i))
                .setLocale(this.getPickerLanguage())
                .setAppId(this.app_id)
                .setOAuthToken(this.access_token)
                .addView(s)
                .setDeveloperKey(this.api_key)
                .setSize(1051, 650)
                .setCallback(o)
                .build()
                .setVisible(!0);
          }
          constructor(e) {
            (0, a._)(this, "root_store", void 0),
              (0, a._)(this, "bot_folder_name", void 0),
              (0, a._)(this, "client_id", void 0),
              (0, a._)(this, "app_id", void 0),
              (0, a._)(this, "api_key", void 0),
              (0, a._)(this, "scope", void 0),
              (0, a._)(this, "discovery_docs", ""),
              (0, a._)(this, "client", void 0),
              (0, a._)(this, "access_token", void 0),
              (0, a._)(this, "upload_id", void 0),
              (0, a._)(this, "is_google_drive_token_valid", !0),
              (0, a._)(
                this,
                "is_authorised",
                !!localStorage.getItem("google_access_token")
              ),
              (0, a._)(this, "setGoogleDriveTokenValid", (e) => {
                this.is_google_drive_token_valid = e;
              }),
              (0, a._)(this, "setKey", () => {
                let { SCOPE: e, DISCOVERY_DOCS: t } = (0, d.config)()
                  .GOOGLE_DRIVE;
                (this.client_id = void 0),
                  (this.app_id = void 0),
                  (this.api_key = void 0),
                  (this.scope = e),
                  (this.discovery_docs = t);
              }),
              (0, a._)(this, "initialise", () => {
                gapi.load("client:picker", () =>
                  gapi.client.load(this.discovery_docs)
                );
              }),
              (0, a._)(this, "setGoogleDriveTokenExpiry", (e) => {
                let t = Math.floor(Date.now() / 1e3);
                localStorage.setItem(
                  "google_access_token_expiry",
                  (t + e).toString()
                );
              }),
              (0, a._)(this, "initialiseClient", () => {
                this.client = google.accounts.oauth2.initTokenClient({
                  client_id: this.client_id,
                  scope: this.scope,
                  callback: (e) => {
                    (null == e ? void 0 : e.access_token) &&
                      !(null == e ? void 0 : e.error) &&
                      ((this.access_token = e.access_token),
                      this.setIsAuthorized(!0),
                      localStorage.setItem(
                        "google_access_token",
                        e.access_token
                      ),
                      this.setGoogleDriveTokenExpiry(
                        null == e ? void 0 : e.expires_in
                      ),
                      this.setGoogleDriveTokenValid(!0));
                  },
                });
              }),
              (0, a._)(this, "verifyGoogleDriveAccessToken", async () => {
                var e;
                let t =
                  null === (e = localStorage) || void 0 === e
                    ? void 0
                    : e.getItem("google_access_token_expiry");
                return t
                  ? Math.floor(Date.now() / 1e3) > Number(t)
                    ? (this.signOut(),
                      this.setGoogleDriveTokenValid(!1),
                      localStorage.removeItem("google_access_token_expiry"),
                      localStorage.removeItem("google_access_token"),
                      (0, D.J)((0, O.xG)().google_drive_error, void 0, {
                        closeButton: !1,
                      }),
                      "not_verified")
                    : "verified"
                  : "not_verified";
              }),
              (0, a._)(this, "onDriveConnect", async () => {
                this.is_authorised ? this.signOut() : this.signIn();
              }),
              (0, n.rC)(this, {
                is_authorised: n.LO,
                upload_id: n.LO,
                is_google_drive_token_valid: n.LO,
                setIsAuthorized: n.aD.bound,
                saveFile: n.aD.bound,
                loadFile: n.aD.bound,
                setKey: n.aD.bound,
                initialise: n.aD.bound,
                signIn: n.aD.bound,
                signOut: n.aD.bound,
                getPickerLanguage: n.aD.bound,
                checkFolderExists: n.aD.bound,
                createSaveFilePicker: n.aD.bound,
                createLoadFilePicker: n.aD.bound,
                showGoogleDriveFilePicker: n.aD.bound,
                setGoogleDriveTokenValid: n.aD.bound,
                verifyGoogleDriveAccessToken: n.aD.bound,
                onDriveConnect: n.aD,
              }),
              (this.root_store = e),
              (this.bot_folder_name = `Binary Bot - ${(0, h.NC)(
                "Strategies"
              )}`),
              this.setKey(),
              (this.client = null),
              (this.access_token =
                localStorage.getItem("google_access_token") ?? ""),
              setTimeout(() => {
                (0, d.importExternal)(
                  "https://accounts.google.com/gsi/client"
                ).then(() => this.initialiseClient()),
                  (0, d.importExternal)(
                    "https://apis.google.com/js/api.js"
                  ).then(() => this.initialise());
              }, 3e3);
          }
        }
        var eR = i(57357),
          eB = i(47962),
          eP = i(89606),
          ej = i(45221),
          eU = i(63387),
          eM = i.n(eU),
          eF = i(33716);
        let eG = (e) => {
            let { array: t, open_ids: i, setOpenIds: o } = e,
              a = (e) => {
                i.includes(e) ? o(i.filter((t) => t !== e)) : o([...i, e]);
              };
            return (0, s.jsx)(r.Fragment, {
              children: t.map((e, t) => {
                var r;
                return Array.isArray(null == e ? void 0 : e.value)
                  ? (0, s.jsxs)(
                      "div",
                      {
                        className: "dc-expansion-panel__content-array",
                        children: [
                          (0, s.jsxs)("div", {
                            className: eM()(
                              "dc-expansion-panel__content-array",
                              {
                                "dc-expansion-panel__content-active":
                                  i.includes(e.id),
                              }
                            ),
                            children: [
                              (0, s.jsx)("span", {
                                className:
                                  "dc-expansion-panel__content-array-item-index",
                                children: `${t + 1}: `,
                              }),
                              "(",
                              `${e.value.length}`,
                              ")",
                              (0, s.jsx)(eP.J, {
                                className:
                                  "dc-expansion-panel__content-chevron-icon",
                                icon: "IcChevronRight",
                                onClick: () => a(e.id),
                              }),
                            ],
                          }),
                          i.includes(e.id)
                            ? (0, s.jsx)(eG, {
                                array: e.value,
                                open_ids: i,
                                setOpenIds: o,
                              })
                            : null,
                        ],
                      },
                      t
                    )
                  : (0, s.jsxs)(
                      "div",
                      {
                        className: "dc-expansion-panel__content-array",
                        children: [
                          (0, s.jsx)("span", {
                            className:
                              "dc-expansion-panel__content-array-item-index",
                            children: `${t + 1}: `,
                          }),
                          null == e
                            ? void 0
                            : null === (r = e.value) || void 0 === r
                            ? void 0
                            : r.toString(),
                        ],
                      },
                      t
                    );
              }),
            });
          },
          eH = (e) => {
            let { message: t, onResize: i } = e,
              [o, a] = r.useState([]),
              [n, l] = r.useState(!1);
            return (
              r.useEffect(() => {
                "function" == typeof i && i();
              }, [n, i]),
              (0, s.jsxs)(r.Fragment, {
                children: [
                  (0, s.jsxs)("div", {
                    className: eM()("dc-expansion-panel__header-container", {
                      "dc-expansion-panel__header-active": n,
                    }),
                    children: [
                      t.header,
                      (0, s.jsx)(eF.Z, {
                        className: "dc-expansion-panel__header-chevron-icon",
                        onClick: () => {
                          l(!n);
                        },
                        height: "24px",
                        width: "24px",
                      }),
                    ],
                  }),
                  n &&
                    (Array.isArray(t.content)
                      ? (0, s.jsx)(eG, {
                          array: t.content,
                          open_ids: o,
                          setOpenIds: a,
                        })
                      : t.content),
                ],
              })
            );
          },
          eV = (e) => {
            switch (e) {
              case "error":
                return "IcAlertDanger";
              case "warn":
              default:
                return "IcAlertWarning";
              case "info":
                return "IcAlertInfo";
            }
          },
          eW = (e) => {
            let {
              unique_id: t,
              type: i,
              message: o,
              btn_text: r,
              onClick: a,
            } = e;
            return (0, s.jsxs)(s.Fragment, {
              children: [
                (0, s.jsxs)(
                  "div",
                  {
                    className: "notify__item-container",
                    children: [
                      (0, s.jsx)(
                        eP.J,
                        { icon: eV(i), size: "22" },
                        `${t}_icon`
                      ),
                      (0, s.jsx)(
                        "div",
                        { className: "notify__item-message", children: o },
                        `${t}_text`
                      ),
                    ],
                  },
                  `${t}_message`
                ),
                (0, s.jsx)(
                  ej.Z,
                  {
                    className: "notify__item-button",
                    text: r,
                    onClick: a,
                    has_effect: !0,
                    secondary: !0,
                  },
                  `${t}_btn`
                ),
              ],
            });
          },
          eY = (e) => (t) => (0, s.jsx)(eH, { message: e, onResize: t }),
          e$ = (e, t, i, o) => {
            i(
              eW({
                unique_id: t,
                type: "error",
                message: e,
                btn_text: (0, h.NC)("Go to block"),
                onClick: () => {
                  o();
                },
              })
            );
          },
          eq = (e, t, i, o) => {
            let { message: s, block_id: r, variable_name: a } = e;
            if (void 0 === s && null != a)
              return (
                e$(
                  (0, h.NC)(
                    "Variable '{{variable_name}}' has no value. Please set a value for variable '{{variable_name}}' to notify.",
                    { variable_name: a }
                  ),
                  r,
                  t,
                  i
                ),
                !0
              );
            if (null === s) return o("NULL"), !0;
            if (Object.is(s, NaN))
              return (
                e$(
                  (0, h.NC)("Tried to perform an invalid operation."),
                  r,
                  t,
                  i
                ),
                !0
              );
            if (Array.isArray(s)) {
              let e = s.length;
              return (
                o(
                  eY({
                    header:
                      "null" !== a
                        ? `${a}: (${e})`
                        : (0, h.NC)("List: ({{message_length}})", {
                            message_length: e,
                          }),
                    content: ez(s),
                  })
                ),
                !0
              );
            }
            return "boolean" == typeof s && (o(s.toString()), !0);
          },
          ez = (e) =>
            e.map((e, t) => ({
              id: `${Date.now()}-${t}`,
              value: e && Array.isArray(e) ? ez(e) : e,
            }));
        var eK = i(26961),
          eX = i.n(eK);
        let eZ = (e, t, i) => (t && eJ(e, i)[t]) || i,
          eJ = (e, t) => {
            try {
              let t = sessionStorage.getItem(e),
                i = eX().decompress(t),
                o = JSON.parse(i);
              if (o) return o;
            } catch (e) {}
            return t;
          },
          eQ = (e, t) => {
            try {
              let i = eX().compress(JSON.stringify(t));
              sessionStorage.setItem(e, i);
            } catch (e) {
              console.warn("Could not write to storage.");
            }
          };
        class e0 {
          restoreStoredJournals() {
            let { loginid: e } = this.core.client;
            (this.journal_filters =
              (0, m.$8)("journal_filter") ?? this.filters.map((e) => e.id)),
              (this.unfiltered_messages = eZ(this.JOURNAL_CACHE, e, []));
          }
          getServerTime() {
            var e;
            return null === (e = this.core) || void 0 === e
              ? void 0
              : e.common.server_time.get();
          }
          toggleFilterDialog() {
            this.is_filter_dialog_visible = !this.is_filter_dialog_visible;
          }
          onLogSuccess(e) {
            let { log_type: t, extra: i } = e;
            this.pushMessage(t, d.MessageTypes.SUCCESS, "", i);
          }
          onError(e) {
            this.pushMessage(e, d.MessageTypes.ERROR);
          }
          onNotify(e) {
            let { run_panel: t, dbot: i } = this.root_store,
              {
                message: o,
                className: s,
                message_type: r,
                sound: a,
                block_id: n,
                variable_name: l,
              } = e;
            if (
              eq(
                { message: o, block_id: n, variable_name: l },
                t.showErrorMessage,
                () => i.centerAndHighlightBlock(n, !0),
                (e) => this.pushMessage(e, r || d.MessageTypes.NOTIFY, s)
              )
            ) {
              this.playAudio(a);
              return;
            }
            this.pushMessage(o, r || d.MessageTypes.NOTIFY, s),
              this.playAudio(a);
          }
          pushMessage(e, t, i) {
            let o =
                arguments.length > 3 && void 0 !== arguments[3]
                  ? arguments[3]
                  : {},
              { client: s } = this.core,
              { loginid: r, account_list: a } = s;
            if (r) {
              let e =
                null == a
                  ? void 0
                  : a.find((e) => (null == e ? void 0 : e.loginid) === r);
              o.current_currency = (null == e ? void 0 : e.is_virtual)
                ? "Demo"
                : null == e
                ? void 0
                : e.currency;
            } else if (e === d.LogTypes.WELCOME) return;
            let n = (0, c.p6d)(this.getServerTime()),
              l = (0, c.p6d)(this.getServerTime(), "HH:mm:ss [GMT]"),
              u = (0, eR.Z)();
            this.unfiltered_messages.unshift({
              date: n,
              time: l,
              message: e,
              message_type: t,
              className: i,
              unique_id: u,
              extra: o,
            }),
              (this.unfiltered_messages = this.unfiltered_messages.slice());
          }
          get filtered_messages() {
            return this.unfiltered_messages.filter(
              (e) =>
                this.journal_filters.length &&
                this.journal_filters.some((t) => e.message_type === t)
            );
          }
          get checked_filters() {
            return this.journal_filters.filter((e) => null != e);
          }
          filterMessage(e, t) {
            e
              ? this.journal_filters.push(t)
              : this.journal_filters.splice(this.journal_filters.indexOf(t), 1),
              (0, m.Jp)("journal_filter", this.journal_filters);
          }
          clear() {
            this.unfiltered_messages = this.unfiltered_messages.slice(0, 0);
          }
          registerReactions() {
            let e = this.core.client,
              t = (0, n.U5)(
                () => this.unfiltered_messages,
                (t) => {
                  let i = eJ(this.JOURNAL_CACHE, {});
                  (i[e.loginid] = null == t ? void 0 : t.slice(0, 5e3)),
                    eQ(this.JOURNAL_CACHE, i);
                }
              ),
              i = (0, n.U5)(
                () => (null == e ? void 0 : e.loginid),
                async (t) => {
                  await (0, n.gx)(() => {
                    var i;
                    return !!(null === (i = e.account_list) || void 0 === i
                      ? void 0
                      : i.find((e) => e.loginid === t));
                  }),
                    (this.unfiltered_messages = eZ(this.JOURNAL_CACHE, t, [])),
                    0 === this.unfiltered_messages.length
                      ? this.pushMessage(
                          d.LogTypes.WELCOME,
                          d.MessageTypes.SUCCESS,
                          "journal__text"
                        )
                      : this.unfiltered_messages.length > 0 &&
                        this.pushMessage(
                          d.LogTypes.WELCOME_BACK,
                          d.MessageTypes.SUCCESS,
                          "journal__text"
                        );
                },
                { fireImmediately: !0 }
              );
            return () => {
              t(), i();
            };
          }
          constructor(e, t) {
            (0, a._)(this, "root_store", void 0),
              (0, a._)(this, "core", void 0),
              (0, a._)(this, "disposeReactionsFn", void 0),
              (0, a._)(this, "JOURNAL_CACHE", "journal_cache"),
              (0, a._)(this, "is_filter_dialog_visible", !1),
              (0, a._)(this, "filters", [
                { id: d.MessageTypes.ERROR, label: (0, h.NC)("Errors") },
                {
                  id: d.MessageTypes.NOTIFY,
                  label: (0, h.NC)("Notifications"),
                },
                { id: d.MessageTypes.SUCCESS, label: (0, h.NC)("System") },
              ]),
              (0, a._)(this, "journal_filters", []),
              (0, a._)(this, "unfiltered_messages", []),
              (0, a._)(this, "playAudio", (e) => {
                e !== (0, eB.v)().lists.NOTIFICATION_SOUND[0][1] &&
                  document.getElementById(e).play();
              }),
              (0, n.rC)(this, {
                is_filter_dialog_visible: n.LO,
                journal_filters: n.LO.shallow,
                filters: n.LO.shallow,
                unfiltered_messages: n.LO.shallow,
                toggleFilterDialog: n.aD.bound,
                onLogSuccess: n.aD.bound,
                onError: n.aD.bound,
                onNotify: n.aD.bound,
                pushMessage: n.aD.bound,
                filtered_messages: n.Fl,
                getServerTime: n.aD.bound,
                playAudio: n.aD.bound,
                checked_filters: n.Fl,
                filterMessage: n.aD.bound,
                clear: n.aD.bound,
                registerReactions: n.aD.bound,
                restoreStoredJournals: n.aD.bound,
              }),
              (this.root_store = e),
              (this.core = t),
              (this.disposeReactionsFn = this.registerReactions()),
              this.restoreStoredJournals();
          }
        }
        var e1 = i(26855),
          e2 = i(49985),
          e5 = i(42457);
        class e3 {
          get preview_workspace() {
            return this.tab_name === e2.y.TAB_LOCAL
              ? this.local_workspace
              : this.tab_name === e2.y.TAB_RECENT
              ? this.recent_workspace
              : null;
          }
          get selected_strategy() {
            return (
              this.dashboard_strategies.find(
                (e) => e.id === this.selected_strategy_id
              ) ?? this.dashboard_strategies[0]
            );
          }
          get tab_name() {
            if (this.core.ui.is_mobile) {
              if (0 === this.active_index) return e2.y.TAB_LOCAL;
              if (1 === this.active_index) return e2.y.TAB_GOOGLE;
            }
            return 0 === this.active_index
              ? e2.y.TAB_RECENT
              : 1 === this.active_index
              ? e2.y.TAB_LOCAL
              : 2 === this.active_index
              ? e2.y.TAB_GOOGLE
              : "";
          }
          constructor(e, t) {
            var i = this;
            (0, a._)(this, "root_store", void 0),
              (0, a._)(this, "core", void 0),
              (0, a._)(this, "imported_strategy_type", "pending"),
              (0, a._)(this, "recent_workspace", null),
              (0, a._)(this, "local_workspace", null),
              (0, a._)(this, "drop_zone", void 0),
              (0, a._)(this, "active_index", 0),
              (0, a._)(this, "is_load_modal_open", !1),
              (0, a._)(this, "is_explanation_expand", !1),
              (0, a._)(this, "is_open_button_loading", !1),
              (0, a._)(this, "is_open_button_disabled", !1),
              (0, a._)(this, "loaded_local_file", null),
              (0, a._)(this, "recent_strategies", []),
              (0, a._)(this, "dashboard_strategies", []),
              (0, a._)(this, "selected_strategy_id", ""),
              (0, a._)(this, "is_strategy_loaded", !1),
              (0, a._)(this, "is_delete_modal_open", !1),
              (0, a._)(this, "is_strategy_removed", !1),
              (0, a._)(this, "current_workspace_id", ""),
              (0, a._)(this, "upload_id", ""),
              (0, a._)(this, "setOpenButtonDisabled", (e) => {
                this.is_open_button_disabled = e;
              }),
              (0, a._)(this, "getSelectedStrategyID", (e) => {
                this.current_workspace_id = e;
              }),
              (0, a._)(this, "setDashboardStrategies", (e) => {
                (this.dashboard_strategies = e),
                  e.length || (this.selected_strategy_id = "");
              }),
              (0, a._)(this, "getDashboardStrategies", async () => {
                let e = await (0, d.getSavedWorkspaces)();
                this.dashboard_strategies = e;
              }),
              (0, a._)(this, "onDriveOpen", async () => {
                let { google_drive: e } = this.root_store,
                  { verifyGoogleDriveAccessToken: t } = e;
                if ("not_verified" === (await t())) return;
                e && (e.upload_id = (0, eR.Z)()),
                  (0, eA.Oi)({
                    upload_provider: "google_drive",
                    upload_id: e.upload_id,
                  });
                let { loadFile: i } = this.root_store.google_drive,
                  o = await i();
                if (!o) return;
                let s = null == o ? void 0 : o.xml_doc,
                  r = null == o ? void 0 : o.file_name;
                await (0, d.load)({
                  block_string: s,
                  file_name: r,
                  workspace: window.Blockly.derivWorkspace,
                  from: d.save_types.GOOGLE_DRIVE,
                  drop_event: null,
                  strategy_id: null,
                  showIncompatibleStrategyDialog: null,
                });
                let { active_tab: a } = this.root_store.dashboard;
                1 === a && this.toggleLoadModal(),
                  (this.root_store.dashboard.is_dialog_open = !1);
              }),
              (0, a._)(this, "onEntered", () => {
                if (
                  0 === this.recent_strategies.length ||
                  this.tab_name !== e2.y.TAB_RECENT
                )
                  return;
                this.setOpenButtonDisabled(!0);
                let { blockly_store: e } = this.root_store,
                  { setLoading: t } = e;
                t(!0),
                  this.loadStrategyOnModalRecentPreview(
                    this.selected_strategy_id
                  ),
                  this.updateXmlValuesOnStrategySelection(),
                  this.setOpenButtonDisabled(!1);
              }),
              (0, a._)(this, "onLoadModalClose", () => {
                this.local_workspace && (this.local_workspace = null),
                  this.setActiveTabIndex(0),
                  this.setLoadedLocalFile(null);
              }),
              (0, a._)(this, "onZoomInOutClick", (e) => {
                this.preview_workspace &&
                  this.preview_workspace.zoomCenter(e ? 1 : -1);
              }),
              (0, a._)(this, "setActiveTabIndex", (e) => {
                this.active_index = e;
              }),
              (0, a._)(this, "setLoadedLocalFile", (e) => {
                this.loaded_local_file = e;
              }),
              (0, a._)(this, "setRecentStrategies", (e) => {
                this.recent_strategies = e;
              }),
              (0, a._)(this, "refreshStrategies", () => {
                this.setRecentStrategies(this.recent_strategies);
              }),
              (0, a._)(this, "setSelectedStrategyId", (e) => {
                this.selected_strategy_id = e;
              }),
              (0, a._)(this, "toggleExplanationExpand", () => {
                this.is_explanation_expand = !this.is_explanation_expand;
              }),
              (0, a._)(this, "toggleLoadModal", () => {
                var e;
                (this.is_load_modal_open = !this.is_load_modal_open),
                  null === (e = this.recent_workspace) ||
                    void 0 === e ||
                    e.dispose(),
                  (this.recent_workspace = null),
                  this.setLoadedLocalFile(null);
              }),
              (0, a._)(this, "toggleTourLoadModal", function () {
                let e =
                  arguments.length > 0 && void 0 !== arguments[0]
                    ? arguments[0]
                    : !i.is_load_modal_open;
                i.is_load_modal_open = e;
              }),
              (0, a._)(this, "updateListStrategies", (e) => {
                e && (this.dashboard_strategies = e);
              }),
              (0, a._)(this, "getSaveType", (e) => {
                switch (e) {
                  case d.save_types.UNSAVED:
                    return (0, h.NC)("Unsaved");
                  case d.save_types.LOCAL:
                    return (0, h.NC)("Local");
                  case d.save_types.GOOGLE_DRIVE:
                    return (0, h.NC)("Google Drive");
                  default:
                    return (0, h.NC)("Unsaved");
                }
              }),
              (0, a._)(this, "onToggleDeleteDialog", (e) => {
                this.is_delete_modal_open = e;
              }),
              (0, a._)(this, "resetBotBuilderStrategy", () => {
                let e = window.Blockly.derivWorkspace;
                e &&
                  (window.Blockly.derivWorkspace.asyncClear(),
                  window.Blockly.Xml.domToWorkspace(
                    window.Blockly.utils.xml.textToDom(e.cached_xml.main),
                    e
                  ),
                  (window.Blockly.derivWorkspace.strategy_to_load =
                    e.cached_xml.main));
              }),
              (0, a._)(this, "loadStrategyToBuilder", async (e) => {
                if (null == e ? void 0 : e.id) {
                  var t;
                  await (0, d.load)({
                    block_string: e.xml,
                    strategy_id: e.id,
                    file_name: e.name,
                    workspace:
                      null === (t = window.Blockly) || void 0 === t
                        ? void 0
                        : t.derivWorkspace,
                    from: e.save_type,
                    drop_event: {},
                    showIncompatibleStrategyDialog: !1,
                  }),
                    (window.Blockly.derivWorkspace.strategy_to_load = e.xml);
                }
              }),
              (0, a._)(this, "refreshStrategiesTheme", async () => {
                var e, t, i, o;
                this.recent_workspace &&
                  (this.recent_workspace.RTL = (0, e1.rK)()),
                  await (0, d.load)({
                    block_string:
                      null === (e = this.selected_strategy) || void 0 === e
                        ? void 0
                        : e.xml,
                    drop_event: {},
                    workspace: this.recent_workspace,
                    file_name:
                      null === (t = this.selected_strategy) || void 0 === t
                        ? void 0
                        : t.name,
                    strategy_id:
                      null === (i = this.selected_strategy) || void 0 === i
                        ? void 0
                        : i.id,
                    from:
                      null === (o = this.selected_strategy) || void 0 === o
                        ? void 0
                        : o.save_type,
                    showIncompatibleStrategyDialog: !1,
                  });
              }),
              (0, a._)(this, "loadFileFromRecent", async () => {
                var e;
                if (
                  ((this.is_open_button_loading = !0), !this.selected_strategy)
                ) {
                  window.Blockly.derivWorkspace.asyncClear(),
                    window.Blockly.Xml.domToWorkspace(
                      window.Blockly.utils.xml.textToDom(
                        window.Blockly.derivWorkspace.strategy_to_load
                      ),
                      window.Blockly.derivWorkspace
                    ),
                    (this.is_open_button_loading = !1);
                  return;
                }
                (0, d.removeExistingWorkspace)(this.selected_strategy.id),
                  await (0, d.load)({
                    block_string:
                      null === (e = this.selected_strategy) || void 0 === e
                        ? void 0
                        : e.xml,
                    strategy_id: this.selected_strategy.id,
                    file_name: this.selected_strategy.name,
                    workspace: window.Blockly.derivWorkspace,
                    from: this.selected_strategy.save_type,
                    drop_event: {},
                    showIncompatibleStrategyDialog: !1,
                  }),
                  (await (0, d.getSavedWorkspaces)()).map((e) => {
                    let { xml: t, id: i } = e;
                    this.selected_strategy.id === i &&
                      (window.Blockly.derivWorkspace.strategy_to_load = t);
                  }),
                  (this.is_open_button_loading = !1);
              }),
              (0, a._)(this, "loadFileFromLocal", () => {
                (this.is_open_button_loading = !0),
                  this.loaded_local_file &&
                    this.readFile(!1, {}, this.loaded_local_file);
              }),
              (0, a._)(this, "onActiveIndexChange", () => {
                this.setOpenButtonDisabled(!0),
                  this.tab_name === e2.y.TAB_RECENT
                    ? (this.loadStrategyOnModalRecentPreview(
                        this.selected_strategy_id
                      ),
                      this.updateXmlValuesOnStrategySelection())
                    : this.recent_workspace &&
                      setTimeout(() => {
                        var e;
                        null === (e = this.recent_workspace) ||
                          void 0 === e ||
                          e.dispose(),
                          (this.recent_workspace = null);
                      }),
                  this.tab_name === e2.y.TAB_LOCAL
                    ? !this.drop_zone &&
                      ((this.drop_zone = document.querySelector(
                        "load-strategy__local-dropzone-area"
                      )),
                      this.drop_zone &&
                        this.drop_zone.addEventListener("drop", (e) =>
                          this.handleFileChange(e, !1)
                        ))
                    : this.local_workspace &&
                      setTimeout(() => {
                        var e;
                        null === (e = this.local_workspace) ||
                          void 0 === e ||
                          e.dispose(),
                          (this.local_workspace = null),
                          this.setLoadedLocalFile(null);
                      }, 0),
                  this.tab_name !== e2.y.TAB_LOCAL &&
                    this.drop_zone &&
                    this.drop_zone.removeEventListener("drop", (e) =>
                      this.handleFileChange(e, !1)
                    ),
                  this.setOpenButtonDisabled(!1);
              }),
              (0, a._)(this, "handleFileChange", function (e) {
                let t,
                  o =
                    !(arguments.length > 1) ||
                    void 0 === arguments[1] ||
                    arguments[1];
                (i.imported_strategy_type = "pending"),
                  (i.upload_id = (0, eR.Z)()),
                  "drop" === e.type
                    ? (e.stopPropagation(),
                      e.preventDefault(),
                      ({ files: t } = e.dataTransfer))
                    : ({ files: t } = e.target);
                let [s] = t;
                if (!o) {
                  if (!s.name.includes("xml")) return !1;
                  i.setLoadedLocalFile(s), i.getDashboardStrategies();
                }
                return i.readFile(!o, e, s), (e.target.value = ""), !0;
              }),
              (0, a._)(this, "readFile", (e, t, i) => {
                let o = new FileReader(),
                  s =
                    (null == i ? void 0 : i.name.replace(/\.[^/.]+$/, "")) ||
                    "";
                (o.onload = (0, n.aD)(async (e) => {
                  var i;
                  let o = {
                    block_string:
                      null == e
                        ? void 0
                        : null === (i = e.target) || void 0 === i
                        ? void 0
                        : i.result,
                    drop_event: t,
                    from: d.save_types.LOCAL,
                    workspace: null,
                    file_name: s,
                    strategy_id: "",
                    showIncompatibleStrategyDialog: !1,
                  };
                  this.local_workspace &&
                    (this.local_workspace.dispose(),
                    (this.local_workspace = null)),
                    this.loadStrategyOnModalLocalPreview(o),
                    this.setOpenButtonDisabled(!1);
                })),
                  o.readAsText(i);
              }),
              (0, a._)(this, "saveStrategyToLocalStorage", async () => {
                var e;
                let { save_modal: t } = this.root_store,
                  { updateBotName: i } = t,
                  {
                    convertedDom: o,
                    from: s,
                    file_name: r,
                  } = window.Blockly.xmlValues;
                i(r), await (0, d.saveWorkspaceToRecent)(o, s);
                let a = await (0, d.getSavedWorkspaces)();
                (null == a ? void 0 : a.length) > 0 &&
                  this.setSelectedStrategyId(
                    null === (e = a[0]) || void 0 === e ? void 0 : e.id
                  );
              }),
              (0, a._)(this, "loadStrategyOnBotBuilder", async () => {
                let {
                    strategy_id: e = window.Blockly.utils.idGenerator.genUid(),
                    convertedDom: t,
                    block_string: i,
                  } = window.Blockly.xmlValues,
                  o = window.Blockly.derivWorkspace;
                window.Blockly.Xml.clearWorkspaceAndLoadFromXml(t, o),
                  o.cleanUp(),
                  o.clearUndo(),
                  (o.current_strategy_id = e);
                let s = (0, eI.dC)(i ?? "");
                (0, eA.WN)({
                  upload_provider: "my_computer",
                  upload_type: s,
                  upload_id: this.upload_id,
                });
              }),
              (0, a._)(this, "updateXmlValuesOnStrategySelection", () => {
                var e, t, i, o, s, r, a;
                0 !== this.recent_strategies.length &&
                  (0, u.ox)({
                    strategy_id: this.selected_strategy_id,
                    convertedDom:
                      null === (s = window) || void 0 === s
                        ? void 0
                        : null === (o = s.Blockly) || void 0 === o
                        ? void 0
                        : null === (i = o.utils) || void 0 === i
                        ? void 0
                        : null === (t = i.xml) || void 0 === t
                        ? void 0
                        : t.textToDom(
                            null === (e = this.selected_strategy) ||
                              void 0 === e
                              ? void 0
                              : e.xml
                          ),
                    file_name:
                      null === (r = this.selected_strategy) || void 0 === r
                        ? void 0
                        : r.name,
                    from:
                      (null === (a = this.selected_strategy) || void 0 === a
                        ? void 0
                        : a.save_type) || d.save_types.UNSAVED,
                  });
              }),
              (0, a._)(this, "loadStrategyOnModalRecentPreview", async (e) => {
                var t, i, o, s, r, a, n, l, c, d;
                if (
                  (this.setOpenButtonDisabled(!0),
                  0 === this.recent_strategies.length ||
                    this.tab_name !== e2.y.TAB_RECENT)
                )
                  return;
                let { blockly_store: h } = this.root_store,
                  { setLoading: p } = h,
                  _ = {
                    ...u.Tj,
                    theme:
                      null === (o = window) || void 0 === o
                        ? void 0
                        : null === (i = o.Blockly) || void 0 === i
                        ? void 0
                        : null === (t = i.Themes) || void 0 === t
                        ? void 0
                        : t.zelos_renderer,
                  };
                this.setLoadedLocalFile(null),
                  this.setSelectedStrategyId(e),
                  await (0, e5._)("#load-strategy__blockly-container");
                let m = document.getElementById(
                  "load-strategy__blockly-container"
                );
                if (m) {
                  this.recent_workspace ||
                    (this.recent_workspace = window.Blockly.inject(m, _)),
                    (this.recent_workspace.RTL = (0, e1.rK)());
                  let e =
                      null === (n = window.Blockly) || void 0 === n
                        ? void 0
                        : null === (a = n.utils) || void 0 === a
                        ? void 0
                        : null === (r = a.xml) || void 0 === r
                        ? void 0
                        : r.textToDom(
                            null === (s = this.selected_strategy) ||
                              void 0 === s
                              ? void 0
                              : s.xml
                          ),
                    t =
                      null === (l = window.Blockly) || void 0 === l
                        ? void 0
                        : l.getMainWorkspace();
                  null === (d = window.Blockly) ||
                    void 0 === d ||
                    null === (c = d.Xml) ||
                    void 0 === c ||
                    c.clearWorkspaceAndLoadFromXml(e, t);
                }
                p(!1), this.setOpenButtonDisabled(!1);
              }),
              (0, a._)(this, "loadStrategyOnModalLocalPreview", async (e) => {
                var t, i, o;
                this.setOpenButtonDisabled(!0);
                let s = {
                  ...u.Tj,
                  theme:
                    null === (o = window) || void 0 === o
                      ? void 0
                      : null === (i = o.Blockly) || void 0 === i
                      ? void 0
                      : null === (t = i.Themes) || void 0 === t
                      ? void 0
                      : t.zelos_renderer,
                };
                await (0, e5._)("#load-strategy__blockly-container");
                let r = document.getElementById(
                  "load-strategy__blockly-container"
                );
                this.local_workspace ||
                  (this.local_workspace = await window.Blockly.inject(r, s)),
                  (e.workspace = this.local_workspace),
                  e.workspace && (e.workspace.RTL = (0, e1.rK)());
                let a = (0, eI.dC)((null == e ? void 0 : e.block_string) ?? ""),
                  n = await (0, d.load)(e);
                (null == n ? void 0 : n.error)
                  ? (null == n ? void 0 : n.error) &&
                    (0, eA.mu)({
                      upload_provider: "my_computer",
                      upload_id: this.upload_id,
                      upload_type: a,
                      error_message: n.error,
                    })
                  : (0, eA.Oi)({
                      upload_provider: "my_computer",
                      upload_id: this.upload_id,
                    });
              }),
              (0, n.rC)(this, {
                active_index: n.LO,
                is_load_modal_open: n.LO,
                is_explanation_expand: n.LO,
                is_strategy_loaded: n.LO,
                is_delete_modal_open: n.LO,
                is_strategy_removed: n.LO,
                loaded_local_file: n.LO,
                recent_strategies: n.LO,
                dashboard_strategies: n.LO,
                selected_strategy_id: n.LO,
                current_workspace_id: n.LO,
                upload_id: n.LO,
                preview_workspace: n.Fl,
                selected_strategy: n.Fl,
                tab_name: n.Fl,
                is_open_button_disabled: n.LO,
                setOpenButtonDisabled: n.aD.bound,
                getSelectedStrategyID: n.aD.bound,
                refreshStrategies: n.aD.bound,
                loadStrategyToBuilder: n.aD.bound,
                refreshStrategiesTheme: n.aD.bound,
                handleFileChange: n.aD.bound,
                loadFileFromRecent: n.aD.bound,
                loadFileFromLocal: n.aD.bound,
                imported_strategy_type: n.LO,
                onActiveIndexChange: n.aD.bound,
                onDriveOpen: n.aD.bound,
                onEntered: n.aD.bound,
                onLoadModalClose: n.aD.bound,
                onZoomInOutClick: n.aD.bound,
                setActiveTabIndex: n.aD.bound,
                setLoadedLocalFile: n.aD.bound,
                setRecentStrategies: n.aD.bound,
                setSelectedStrategyId: n.aD.bound,
                toggleExplanationExpand: n.aD.bound,
                toggleLoadModal: n.aD.bound,
                toggleTourLoadModal: n.aD.bound,
                readFile: n.aD.bound,
                resetBotBuilderStrategy: n.aD.bound,
                setDashboardStrategies: n.aD.bound,
                updateListStrategies: n.aD.bound,
                onToggleDeleteDialog: n.aD,
                loadStrategyOnModalRecentPreview: n.aD,
                loadStrategyOnBotBuilder: n.aD,
                saveStrategyToLocalStorage: n.aD,
                updateXmlValuesOnStrategySelection: n.aD,
              }),
              (this.root_store = e),
              (this.core = t),
              (0, n.U5)(
                () => this.active_index,
                () => this.onActiveIndexChange()
              ),
              (0, n.U5)(
                () => this.is_load_modal_open,
                async (e) => {
                  if (e) {
                    let e = await (0, d.getSavedWorkspaces)();
                    e &&
                      (this.setRecentStrategies(e),
                      e.length > 0 &&
                        !this.selected_strategy_id &&
                        this.setSelectedStrategyId(e[0].id));
                  } else this.onLoadModalClose();
                }
              );
          }
        }
        var e6 = i(30810);
        let e8 = (e, t, i, o) => {
          if ("digits" === i || "highlowticks" === i) {
            let i = document.createElement("value");
            i.setAttribute("name", e), i.setAttribute("strategy_value", t);
            let s = document.createElement("shadow");
            s.setAttribute("type", "math_number_positive"),
              s.setAttribute("id", "p0O]7-M{ZORlORxGuIEb");
            let r = document.createElement("field");
            r.setAttribute("name", "NUM"),
              (r.textContent = "0"),
              s.appendChild(r),
              i.appendChild(s);
            let a = o.querySelector('value[name="AMOUNT"]');
            if (a) {
              let e = a.parentNode;
              e && e.insertBefore(i, a.nextSibling);
            }
          }
          if ("PREDICTION" === e && o) {
            let e = o.querySelector(
              'block[type="trade_definition_tradeoptions"] > mutation'
            );
            e && e.setAttribute("has_prediction", "true");
          }
        };
        var e9 = i(85414);
        class e4 {
          constructor(e) {
            var t = this;
            (0, a._)(this, "root_store", void 0),
              (0, a._)(this, "is_open", !1),
              (0, a._)(this, "selected_strategy", "MARTINGALE"),
              (0, a._)(this, "form_data", {
                symbol: (0, d.config)().QUICK_STRATEGY.DEFAULT.symbol,
                tradetype: (0, d.config)().QUICK_STRATEGY.DEFAULT.tradetype,
                durationtype: (0, d.config)().QUICK_STRATEGY.DEFAULT
                  .durationtype,
                action: "RUN",
              }),
              (0, a._)(this, "is_contract_dialog_open", !1),
              (0, a._)(this, "is_stop_bot_dialog_open", !1),
              (0, a._)(this, "current_duration_min_max", { min: 0, max: 10 }),
              (0, a._)(this, "loss_threshold_warning_data", { show: !1 }),
              (0, a._)(this, "additional_data", {}),
              (0, a._)(this, "setAdditionalData", (e) => {
                this.additional_data = { ...this.additional_data, ...e };
              }),
              (0, a._)(this, "setLossThresholdWarningData", (e) => {
                this.loss_threshold_warning_data = {
                  ...this.loss_threshold_warning_data,
                  ...e,
                };
              }),
              (0, a._)(this, "initializeLossThresholdWarningData", () => {
                this.loss_threshold_warning_data = {
                  show: !1,
                  highlight_field: [],
                  already_shown: !1,
                };
              }),
              (0, a._)(this, "setFormVisibility", (e) => {
                this.is_open = e;
              }),
              (0, a._)(this, "setSelectedStrategy", (e) => {
                this.selected_strategy = e;
              }),
              (0, a._)(this, "setValue", (e, t) => {
                this.form_data[e] = t;
              }),
              (0, a._)(this, "setCurrentDurationMinMax", function () {
                let e =
                    arguments.length > 0 && void 0 !== arguments[0]
                      ? arguments[0]
                      : 0,
                  i =
                    arguments.length > 1 && void 0 !== arguments[1]
                      ? arguments[1]
                      : 10;
                t.current_duration_min_max = { min: e, max: i };
              }),
              (0, a._)(this, "onSubmit", async (e) => {
                let { contracts_for: t } =
                  (null === d.ApiHelpers || void 0 === d.ApiHelpers
                    ? void 0
                    : d.ApiHelpers.instance) ?? {};
                if (!t) return;
                let o = await t.getMarketBySymbol(e.symbol),
                  s = await t.getSubmarketBySymbol(e.symbol),
                  r = await t.getTradeTypeCategoryByTradeType(e.tradetype),
                  a = (0, e9.j)()[this.selected_strategy],
                  n = await i(5765)(`./${a.name}.xml`),
                  l = window.Blockly.utils.xml.textToDom(n.default);
                e8("PREDICTION", "last_digit_prediction", r, l);
                let c = (e, t) => {
                    let i =
                      null == l
                        ? void 0
                        : l.querySelectorAll(`value[strategy_value="${e}"]`);
                    null == i ||
                      i.forEach((i) => {
                        e.includes("boolean")
                          ? t
                            ? (i.innerHTML =
                                '<block type="logic_boolean"><field name="BOOL">TRUE</field></block>')
                            : (i.innerHTML =
                                '<block type="logic_boolean"><field name="BOOL">FALSE</field></block>')
                          : (i.innerHTML = `<shadow type="math_number"><field name="NUM">${t}</field></shadow>`);
                      });
                  },
                  u = (e, t) => {
                    let i = `${e.toUpperCase()}_LIST`,
                      o =
                        null == l
                          ? void 0
                          : l.querySelectorAll(`field[name="${i}"]`);
                    null == o ||
                      o.forEach((e) => {
                        e.innerHTML = t;
                      });
                  },
                  { unit: h, action: p, type: _, growth_rate: m, ...g } = e,
                  y = {
                    market: o,
                    submarket: s,
                    tradetypecat: r,
                    dalembert_unit: h,
                    oscar_unit: h,
                    type: "both",
                    ...g,
                    purchase: _,
                    growthrate: m ? m.toString() : void 0,
                  };
                Object.keys(y).forEach((e) => {
                  let t = y[e];
                  isNaN(t) || "growthrate" === e
                    ? "string" == typeof t && u(e, t)
                    : c(e, t);
                });
                let { derivWorkspace: v } = Blockly;
                "RUN" === p &&
                  (null == v ||
                    v
                      .waitForBlockEvent({
                        block_type: "trade_definition",
                        event_type: window.Blockly.Events.BLOCK_CREATE,
                        timeout: 5e3,
                      })
                      .then(() => {
                        this.root_store.run_panel.onRunButtonClick();
                      })),
                  this.setFormVisibility(!1),
                  (0, D.J)((0, O.xG)()[O.tx.BOT_IMPORT]),
                  await (0, d.load)({
                    block_string: window.Blockly.Xml.domToText(l),
                    file_name: a.label,
                    workspace: v,
                    from: e6.R.UNSAVED,
                    drop_event: null,
                    strategy_id: null,
                    showIncompatibleStrategyDialog: null,
                  });
              }),
              (0, a._)(this, "toggleStopBotDialog", () => {
                (this.is_contract_dialog_open = !this.is_contract_dialog_open),
                  (this.is_stop_bot_dialog_open =
                    !this.is_stop_bot_dialog_open),
                  this.setFormVisibility(!1);
              }),
              (0, n.rC)(this, {
                additional_data: n.LO,
                current_duration_min_max: n.LO,
                form_data: n.LO,
                is_contract_dialog_open: n.LO,
                is_open: n.LO,
                is_stop_bot_dialog_open: n.LO,
                initializeLossThresholdWarningData: n.aD,
                selected_strategy: n.LO,
                loss_threshold_warning_data: n.LO,
                onSubmit: n.aD,
                setAdditionalData: n.aD,
                setCurrentDurationMinMax: n.aD,
                setFormVisibility: n.aD,
                setSelectedStrategy: n.aD,
                setLossThresholdWarningData: n.aD,
                setValue: n.aD,
                toggleStopBotDialog: n.aD,
              }),
              (this.root_store = e),
              (0, n.U5)(
                () => this.is_open,
                () => {
                  this.is_open || (this.selected_strategy = "MARTINGALE");
                }
              );
          }
        }
        var e7 = i(80177);
        let te = Object.freeze({ SUMMARY: 0, TRANSACTIONS: 1, JOURNAL: 2 }),
          tt = {
            keep_current_contract: (0, s.jsx)(h.Xx, {
              i18n_default_text:
                "Would you like to keep your current contract or close it? If you decide to keep it running, you can check and close it later on the <0>Reports</0> page.",
              components: [
                (0, s.jsx)(
                  "a",
                  {
                    className: "link",
                    rel: "noopener noreferrer",
                    target: "_blank",
                    href: "/reports/positions",
                  },
                  0
                ),
              ],
            }),
          };
        class ti {
          get is_stop_button_visible() {
            return this.is_running || this.has_open_contract;
          }
          get is_stop_button_disabled() {
            return (
              !this.is_contracy_buying_in_progress &&
              [e7.K.PURCHASE_SENT, e7.K.IS_STOPPING].includes(
                this.contract_stage
              )
            );
          }
          get is_clear_stat_disabled() {
            var e;
            let { journal: t, transactions: i } = this.root_store;
            return (
              this.is_running ||
              this.has_open_contract ||
              (0 === t.unfiltered_messages.length &&
                (null == i
                  ? void 0
                  : null === (e = i.transactions) || void 0 === e
                  ? void 0
                  : e.length) === 0)
            );
          }
          constructor(e, t) {
            (0, a._)(this, "root_store", void 0),
              (0, a._)(this, "dbot", void 0),
              (0, a._)(this, "core", void 0),
              (0, a._)(this, "disposeReactionsFn", void 0),
              (0, a._)(this, "timer", void 0),
              (0, a._)(this, "active_index", 0),
              (0, a._)(this, "contract_stage", e7.K.NOT_RUNNING),
              (0, a._)(this, "dialog_options", {}),
              (0, a._)(this, "has_open_contract", !1),
              (0, a._)(this, "is_running", !1),
              (0, a._)(this, "is_statistics_info_modal_open", !1),
              (0, a._)(this, "is_drawer_open", !0),
              (0, a._)(this, "is_dialog_open", !1),
              (0, a._)(this, "is_sell_requested", !1),
              (0, a._)(this, "show_bot_stop_message", !1),
              (0, a._)(this, "is_contracy_buying_in_progress", !1),
              (0, a._)(this, "run_id", ""),
              (0, a._)(this, "onOkButtonClick", null),
              (0, a._)(this, "onCancelButtonClick", null),
              (0, a._)(this, "error_type", void 0),
              (0, a._)(this, "setShowBotStopMessage", (e) => {
                (this.show_bot_stop_message = e),
                  e &&
                    (0, D.J)((0, O.xG)().bot_stop, {
                      label: (0, h.NC)("Reports"),
                      onClick: () => {
                        let e = (0, u.dd)(),
                          t = new URL(c.xOw.positions);
                        t.searchParams.set("contract_type_bots", e),
                          window.location.assign(t.toString());
                      },
                    });
              }),
              (0, a._)(this, "performSelfExclusionCheck", async () => {
                let { self_exclusion: e } = this.root_store;
                await e.checkRestriction();
              }),
              (0, a._)(this, "onRunButtonClick", async () => {
                let e = 1;
                window.sendRequestsStatistic &&
                  (performance.clearMeasures(),
                  (this.timer = setInterval(() => {
                    window.sendRequestsStatistic(!0),
                      performance.clearMeasures(),
                      12 === e ? clearInterval(this.timer) : e++;
                  }, 1e4)));
                let { summary_card: t, self_exclusion: i } = this.root_store,
                  { client: o, ui: s } = this.core,
                  r = "iOS" === (0, c._Xx)();
                if (
                  (this.dbot.saveRecentWorkspace(),
                  this.dbot.unHighlightAllBlocks(),
                  !o.is_logged_in)
                ) {
                  this.showLoginDialog();
                  return;
                }
                if (
                  ((r || (0, c.G6W)()) && this.preloadAudio(),
                  !i.should_bot_run)
                ) {
                  i.setIsRestricted(!0);
                  return;
                }
                if (
                  (i.setIsRestricted(!1),
                  this.registerBotListeners(),
                  !this.dbot.shouldRunBot())
                ) {
                  this.unregisterBotListeners();
                  return;
                }
                null == s ||
                  s.setAccountSwitcherDisabledMessage(
                    (0, h.NC)(
                      "Account switching is disabled while your bot is running. Please stop your bot before switching accounts."
                    )
                  ),
                  (0, n.z)(() => {
                    this.setIsRunning(!0),
                      s.setPromptHandler(!0),
                      this.toggleDrawer(!0),
                      (this.run_id = `run-${Date.now()}`),
                      t.clear(),
                      this.setContractStage(e7.K.STARTING),
                      this.dbot.runBot();
                  }),
                  this.setShowBotStopMessage(!1);
              }),
              (0, a._)(this, "onStopButtonClick", () => {
                this.is_contracy_buying_in_progress = !1;
                let { is_multiplier: e } = this.root_store.summary_card;
                e ? this.showStopMultiplierContractDialog() : this.stopBot();
              }),
              (0, a._)(this, "onStopBotClick", () => {
                let { is_multiplier: e } = this.root_store.summary_card,
                  { summary_card: t } = this.root_store;
                e
                  ? this.showStopMultiplierContractDialog()
                  : (this.stopBot(), t.clear(), this.setShowBotStopMessage(!0));
              }),
              (0, a._)(this, "stopBot", () => {
                let { ui: e } = this.core;
                this.dbot.stopBot(),
                  e.setPromptHandler(!1),
                  this.error_type
                    ? (this.setContractStage(e7.K.NOT_RUNNING),
                      e.setAccountSwitcherDisabledMessage(),
                      this.setIsRunning(!1))
                    : this.has_open_contract
                    ? this.setContractStage(e7.K.IS_STOPPING)
                    : (this.setContractStage(e7.K.NOT_RUNNING),
                      this.unregisterBotListeners(),
                      e.setAccountSwitcherDisabledMessage(),
                      this.setIsRunning(!1)),
                  this.error_type && (this.error_type = void 0),
                  this.timer && clearInterval(this.timer),
                  window.sendRequestsStatistic &&
                    (window.sendRequestsStatistic(!0),
                    performance.clearMeasures());
              }),
              (0, a._)(this, "onClearStatClick", () => {
                this.showClearStatDialog();
              }),
              (0, a._)(this, "clearStat", () => {
                let {
                  summary_card: e,
                  journal: t,
                  transactions: i,
                } = this.root_store;
                this.setIsRunning(!1),
                  this.setHasOpenContract(!1),
                  this.clear(),
                  t.clear(),
                  e.clear(),
                  i.clear(),
                  this.setContractStage(e7.K.NOT_RUNNING);
              }),
              (0, a._)(this, "toggleStatisticsInfoModal", () => {
                this.is_statistics_info_modal_open =
                  !this.is_statistics_info_modal_open;
              }),
              (0, a._)(this, "toggleDrawer", (e) => {
                this.is_drawer_open = e;
              }),
              (0, a._)(this, "setActiveTabIndex", (e) => {
                this.active_index = e;
              }),
              (0, a._)(this, "onCloseDialog", () => {
                this.is_dialog_open = !1;
              }),
              (0, a._)(this, "stopMyBot", () => {
                let { summary_card: e, quick_strategy: t } = this.root_store,
                  { ui: i } = this.core,
                  { toggleStopBotDialog: o } = t;
                i.setPromptHandler(!1),
                  this.dbot.terminateBot(),
                  this.onCloseDialog(),
                  e.clear(),
                  o(),
                  this.timer && clearInterval(this.timer),
                  window.sendRequestsStatistic &&
                    (window.sendRequestsStatistic(!0),
                    performance.clearMeasures());
              }),
              (0, a._)(this, "closeMultiplierContract", () => {
                let { quick_strategy: e } = this.root_store,
                  { toggleStopBotDialog: t } = e;
                this.onClickSell(), this.stopBot(), this.onCloseDialog(), t();
              }),
              (0, a._)(this, "showStopMultiplierContractDialog", () => {
                let { summary_card: e } = this.root_store,
                  { ui: t } = this.core;
                (this.onOkButtonClick = () => {
                  t.setPromptHandler(!1),
                    this.dbot.terminateBot(),
                    this.timer && clearInterval(this.timer),
                    window.sendRequestsStatistic &&
                      (window.sendRequestsStatistic(!0),
                      performance.clearMeasures()),
                    this.onCloseDialog(),
                    e.clear();
                }),
                  (this.onCancelButtonClick = () => {
                    this.onClickSell(), this.stopBot(), this.onCloseDialog();
                  }),
                  (this.dialog_options = {
                    title: (0, h.NC)("Keep your current contract?"),
                    message: tt.keep_current_contract,
                    ok_button_text: (0, h.NC)("Keep my contract"),
                    cancel_button_text: (0, h.NC)("Close my contract"),
                  }),
                  (this.is_dialog_open = !0);
              }),
              (0, a._)(this, "showLoginDialog", () => {
                (this.onOkButtonClick = this.onCloseDialog),
                  (this.onCancelButtonClick = null),
                  (this.dialog_options = {
                    title: (0, h.NC)("Please log in"),
                    message: (0, h.NC)("You need to log in to run the bot."),
                  }),
                  (this.is_dialog_open = !0);
              }),
              (0, a._)(this, "showRealAccountDialog", () => {
                (this.onOkButtonClick = this.onCloseDialog),
                  (this.onCancelButtonClick = null),
                  (this.dialog_options = {
                    title: (0, h.NC)(
                      "Deriv Bot isn't quite ready for real accounts"
                    ),
                    message: (0, h.NC)(
                      "Please switch to your demo account to run your Deriv Bot."
                    ),
                  }),
                  (this.is_dialog_open = !0);
              }),
              (0, a._)(this, "showClearStatDialog", () => {
                (this.onOkButtonClick = () => {
                  this.clearStat(), this.onCloseDialog();
                }),
                  (this.onCancelButtonClick = this.onCloseDialog),
                  (this.dialog_options = {
                    title: (0, h.NC)("Are you sure?"),
                    message: (0, h.NC)(
                      "This will clear all data in the summary, transactions, and journal panels. All counters will be reset to zero."
                    ),
                  }),
                  (this.is_dialog_open = !0);
              }),
              (0, a._)(this, "showIncompatibleStrategyDialog", () => {
                (this.onOkButtonClick = this.onCloseDialog),
                  (this.onCancelButtonClick = null),
                  (this.dialog_options = {
                    title: (0, h.NC)("Import error"),
                    message: (0, h.NC)(
                      "This strategy is currently not compatible with Deriv Bot."
                    ),
                  }),
                  (this.is_dialog_open = !0);
              }),
              (0, a._)(this, "showContractUpdateErrorDialog", (e) => {
                (this.onOkButtonClick = this.onCloseDialog),
                  (this.onCancelButtonClick = null),
                  (this.dialog_options = {
                    title: (0, h.NC)("Contract Update Error"),
                    message: e,
                  }),
                  (this.is_dialog_open = !0);
              }),
              (0, a._)(this, "registerBotListeners", () => {
                let { summary_card: e, transactions: t } = this.root_store;
                d.observer.register("bot.running", this.onBotRunningEvent),
                  d.observer.register("bot.sell", this.onBotSellEvent),
                  d.observer.register("bot.stop", this.onBotStopEvent),
                  d.observer.register("bot.bot_ready", this.onBotReadyEvent),
                  d.observer.register("bot.click_stop", this.onStopButtonClick),
                  d.observer.register("bot.trade_again", this.onBotTradeAgain),
                  d.observer.register(
                    "contract.status",
                    this.onContractStatusEvent
                  ),
                  d.observer.register("bot.contract", this.onBotContractEvent),
                  d.observer.register("bot.contract", e.onBotContractEvent),
                  d.observer.register("bot.contract", t.onBotContractEvent),
                  d.observer.register("Error", this.onError),
                  d.observer.register(
                    "bot.recoverOpenPositionLimitExceeded",
                    this.OpenPositionLimitExceededEvent
                  );
              }),
              (0, a._)(
                this,
                "OpenPositionLimitExceededEvent",
                () => (this.is_contracy_buying_in_progress = !0)
              ),
              (0, a._)(this, "registerReactions", () => {
                let e, t;
                let { client: i, common: o } = this.core,
                  s = () => {
                    o.is_socket_opened
                      ? (e = (0, n.U5)(
                          () => i.loginid,
                          (e) => {
                            e && this.is_running,
                              this.dbot.terminateBot(),
                              this.unregisterBotListeners();
                          }
                        ))
                      : "function" == typeof t && t();
                  };
                s(),
                  (t = (0, n.U5)(
                    () => o.is_socket_opened,
                    () => s()
                  ));
                let r = (0, n.U5)(
                  () => !this.is_running,
                  () => {
                    this.is_running || this.setContractStage(e7.K.NOT_RUNNING);
                  }
                );
                return () => {
                  "function" == typeof e && e(),
                    "function" == typeof t && t(),
                    "function" == typeof r && r();
                };
              }),
              (0, a._)(this, "onBotRunningEvent", () => {
                this.setHasOpenContract(!0);
                let e = new Event("IgnorePWAUpdate");
                document.dispatchEvent(e);
                let { self_exclusion: t } = this.root_store;
                t.should_bot_run &&
                  -1 !== t.run_limit &&
                  ((t.run_limit -= 1),
                  t.run_limit < 0 && this.onStopButtonClick());
              }),
              (0, a._)(this, "onBotSellEvent", () => {
                this.is_sell_requested = !0;
              }),
              (0, a._)(this, "onBotStopEvent", () => {
                let { self_exclusion: e, summary_card: t } = this.root_store,
                  { ui: i } = this.core,
                  o = () => {
                    (this.error_type = void 0),
                      this.setContractStage(e7.K.NOT_RUNNING),
                      i.setAccountSwitcherDisabledMessage(),
                      this.unregisterBotListeners(),
                      e.resetSelfExclusion();
                  };
                if (this.error_type === d.ErrorTypes.RECOVERABLE_ERRORS) {
                  var s, r, a, n;
                  let {
                    shouldRestartOnError: e = !1,
                    timeMachineEnabled: t = !1,
                  } =
                    (null === (n = this.dbot) || void 0 === n
                      ? void 0
                      : null === (a = n.interpreter) || void 0 === a
                      ? void 0
                      : null === (r = a.bot) || void 0 === r
                      ? void 0
                      : null === (s = r.tradeEngine) || void 0 === s
                      ? void 0
                      : s.options) ?? {};
                  e || t
                    ? ((this.error_type = void 0),
                      this.setContractStage(e7.K.PURCHASE_SENT))
                    : (this.setIsRunning(!1), o());
                } else
                  this.error_type === d.ErrorTypes.UNRECOVERABLE_ERRORS
                    ? (this.setIsRunning(!1), o())
                    : this.has_open_contract &&
                      ((this.error_type = void 0),
                      (this.is_sell_requested = !1),
                      this.setContractStage(e7.K.CONTRACT_CLOSED),
                      i.setAccountSwitcherDisabledMessage(),
                      this.unregisterBotListeners(),
                      e.resetSelfExclusion());
                this.setHasOpenContract(!1),
                  t.clearContractUpdateConfigValues();
                let l = new Event("ListenPWAUpdate");
                document.dispatchEvent(l);
              }),
              (0, a._)(this, "onBotReadyEvent", () => {
                this.setIsRunning(!1),
                  d.observer.unregisterAll("bot.bot_ready");
              }),
              (0, a._)(this, "onBotTradeAgain", (e) => {
                e || this.stopBot();
              }),
              (0, a._)(this, "onContractStatusEvent", (e) => {
                switch (e.id) {
                  case "contract.purchase_sent":
                    this.setContractStage(e7.K.PURCHASE_SENT);
                    break;
                  case "contract.purchase_received": {
                    (this.is_contracy_buying_in_progress = !1),
                      this.setContractStage(e7.K.PURCHASE_RECEIVED);
                    let { buy: i } = e,
                      { is_virtual: o } = this.core.client;
                    if (!o && i) {
                      var t;
                      null === eE.default ||
                        void 0 === eE.default ||
                        null === (t = eE.default.pushDataLayer) ||
                        void 0 === t ||
                        t.call(eE.default, {
                          event: "dbot_purchase",
                          buy_price: i.buy_price,
                        });
                    }
                    break;
                  }
                  case "contract.sold":
                    (this.is_sell_requested = !1),
                      this.setContractStage(e7.K.CONTRACT_CLOSED),
                      e.contract && eE.default.onTransactionClosed(e.contract);
                }
              }),
              (0, a._)(this, "onClickSell", () => {
                let { is_multiplier: e } = this.root_store.summary_card;
                e && this.setContractStage(e7.K.IS_STOPPING),
                  this.dbot.interpreter.bot.getInterface().sellAtMarket();
              }),
              (0, a._)(this, "clear", () => {
                d.observer.emit("statistics.clear");
              }),
              (0, a._)(this, "onBotContractEvent", (e) => {
                (null == e ? void 0 : e.is_sold) &&
                  ((this.is_sell_requested = !1),
                  this.setContractStage(e7.K.CONTRACT_CLOSED));
              }),
              (0, a._)(this, "onError", (e) => {
                let t = e.error || e;
                d.unrecoverable_errors.includes(t.code)
                  ? (this.root_store.summary_card.clear(),
                    (this.error_type = d.ErrorTypes.UNRECOVERABLE_ERRORS))
                  : (this.error_type = d.ErrorTypes.RECOVERABLE_ERRORS);
                let i = null == t ? void 0 : t.message;
                this.showErrorMessage(i);
              }),
              (0, a._)(this, "showErrorMessage", (e) => {
                let { journal: t } = this.root_store,
                  { ui: i } = this.core;
                t.onError(e),
                  t.journal_filters.some((e) => e === d.MessageTypes.ERROR) &&
                    (this.toggleDrawer(!0),
                    this.setActiveTabIndex(te.JOURNAL),
                    i.setPromptHandler(!1));
              }),
              (0, a._)(this, "switchToJournal", () => {
                let { journal: e } = this.root_store;
                e.journal_filters.push(d.MessageTypes.ERROR),
                  this.setActiveTabIndex(te.JOURNAL),
                  this.toggleDrawer(!0);
              }),
              (0, a._)(this, "unregisterBotListeners", () => {
                d.observer.unregisterAll("bot.running"),
                  d.observer.unregisterAll("bot.stop"),
                  d.observer.unregisterAll("bot.click_stop"),
                  d.observer.unregisterAll("bot.trade_again"),
                  d.observer.unregisterAll("contract.status"),
                  d.observer.unregisterAll("bot.contract"),
                  d.observer.unregisterAll("Error");
              }),
              (0, a._)(this, "setContractStage", (e) => {
                this.contract_stage = e;
              }),
              (0, a._)(this, "setHasOpenContract", (e) => {
                this.has_open_contract = e;
              }),
              (0, a._)(this, "setIsRunning", (e) => {
                this.is_running = e;
              }),
              (0, a._)(this, "onMount", () => {
                let { journal: e } = this.root_store;
                d.observer.register("ui.log.error", this.showErrorMessage),
                  d.observer.register("ui.log.notify", e.onNotify),
                  d.observer.register("ui.log.success", e.onLogSuccess),
                  d.observer.register(
                    "client.invalid_token",
                    this.handleInvalidToken
                  );
              }),
              (0, a._)(this, "onUnmount", () => {
                let {
                  journal: e,
                  summary_card: t,
                  transactions: i,
                } = this.root_store;
                this.is_running ||
                  (this.unregisterBotListeners(),
                  this.disposeReactionsFn(),
                  e.disposeReactionsFn(),
                  t.disposeReactionsFn(),
                  i.disposeReactionsFn()),
                  d.observer.unregisterAll("ui.log.error"),
                  d.observer.unregisterAll("ui.log.notify"),
                  d.observer.unregisterAll("ui.log.success"),
                  d.observer.unregisterAll("client.invalid_token");
              }),
              (0, a._)(this, "handleInvalidToken", async () => {
                this.setActiveTabIndex(te.SUMMARY);
              }),
              (0, a._)(this, "preloadAudio", () => {
                this.dbot.getStrategySounds().forEach((e) => {
                  let t = document.getElementById(e);
                  t &&
                    ((t.muted = !0),
                    t.play().catch(() => {}),
                    t.pause(),
                    (t.muted = !1));
                });
              }),
              (0, n.rC)(this, {
                active_index: n.LO,
                contract_stage: n.LO,
                dialog_options: n.LO,
                has_open_contract: n.LO,
                is_running: n.LO,
                is_statistics_info_modal_open: n.LO,
                is_drawer_open: n.LO,
                is_dialog_open: n.LO,
                is_sell_requested: n.LO,
                run_id: n.LO,
                error_type: n.LO,
                show_bot_stop_message: n.LO,
                is_stop_button_visible: n.Fl,
                is_stop_button_disabled: n.Fl,
                is_clear_stat_disabled: n.Fl,
                toggleDrawer: n.aD,
                onBotSellEvent: n.aD,
                setContractStage: n.aD,
                setHasOpenContract: n.aD,
                setIsRunning: n.aD,
                onRunButtonClick: n.aD,
                is_contracy_buying_in_progress: n.LO,
                OpenPositionLimitExceededEvent: n.aD,
                onStopButtonClick: n.aD,
                onClearStatClick: n.aD,
                clearStat: n.aD,
                toggleStatisticsInfoModal: n.aD,
                setActiveTabIndex: n.aD,
                onCloseDialog: n.aD,
                stopMyBot: n.aD,
                closeMultiplierContract: n.aD,
                showStopMultiplierContractDialog: n.aD,
                showLoginDialog: n.aD,
                showRealAccountDialog: n.aD,
                showClearStatDialog: n.aD,
                showIncompatibleStrategyDialog: n.aD,
                showContractUpdateErrorDialog: n.aD,
                registerBotListeners: n.aD,
                registerReactions: n.aD,
                onBotRunningEvent: n.aD,
                onBotStopEvent: n.aD,
                onBotReadyEvent: n.aD,
                onBotTradeAgain: n.aD,
                onContractStatusEvent: n.aD,
                onClickSell: n.aD,
                clear: n.aD,
                onBotContractEvent: n.aD,
                onError: n.aD,
                showErrorMessage: n.aD,
                switchToJournal: n.aD,
                unregisterBotListeners: n.aD,
                handleInvalidToken: n.aD,
                preloadAudio: n.aD,
                onMount: n.aD,
                onUnmount: n.aD,
              }),
              (this.root_store = e),
              (this.dbot = this.root_store.dbot),
              (this.core = t),
              (this.disposeReactionsFn = this.registerReactions()),
              (this.timer = null);
          }
        }
        var to = i(69483),
          ts = i.n(to);
        let tr = window.Blockly;
        class ta {
          constructor(e) {
            (0, a._)(this, "root_store", void 0),
              (0, a._)(this, "is_save_modal_open", !1),
              (0, a._)(this, "button_status", eO.NORMAL),
              (0, a._)(this, "bot_name", ""),
              (0, a._)(this, "toggleSaveModal", () => {
                this.is_save_modal_open || this.setButtonStatus(eO.NORMAL),
                  (this.is_save_modal_open = !this.is_save_modal_open);
              }),
              (0, a._)(this, "validateBotName", (e) => {
                let t = {};
                return (
                  "" === e.bot_name.trim() &&
                    (t.bot_name = (0, h.NC)("Strategy name cannot be empty")),
                  t
                );
              }),
              (0, a._)(
                this,
                "addStrategyToWorkspace",
                async (e, t, i, o, s) => {
                  try {
                    var r;
                    let a = await (0, d.getSavedWorkspaces)(),
                      n = a.findIndex((t) => t.id === e),
                      {
                        load_modal: { getSaveType: l },
                      } = this.root_store,
                      c = t ? d.save_types.LOCAL : d.save_types.GOOGLE_DRIVE,
                      u = i ? d.save_types.UNSAVED : c,
                      h =
                        null === (r = l(u)) || void 0 === r
                          ? void 0
                          : r.toLowerCase(),
                      p = {
                        id: e,
                        xml: window.Blockly.Xml.domToText(s),
                        name: o,
                        timestamp: Date.now(),
                        save_type: h,
                      };
                    n >= 0 ? (a[n] = p) : a.push(p),
                      a
                        .sort(
                          (e, t) =>
                            new Date(e.timestamp) - new Date(t.timestamp)
                        )
                        .reverse(),
                      a.length > _.xc && a.pop();
                    let { load_modal: m } = this.root_store,
                      { setRecentStrategies: g } = m;
                    ts().setItem(
                      "saved_workspaces",
                      eX().compress(JSON.stringify(a))
                    );
                    let y = await (0, d.getSavedWorkspaces)();
                    g(y);
                    let {
                      dashboard: { setStrategySaveType: v },
                    } = this.root_store;
                    v(h);
                  } catch (e) {
                    d.observer.emit("Error", e);
                  }
                }
              ),
              (0, a._)(this, "onConfirmSave", async (e) => {
                var t, i, o, s, r, a;
                let n,
                  { is_local: l, save_as_collection: c, bot_name: u } = e,
                  {
                    load_modal: h,
                    dashboard: p,
                    google_drive: _,
                  } = this.root_store,
                  { loadStrategyToBuilder: m, selected_strategy: g } = h,
                  { active_tab: y } = p;
                this.setButtonStatus(eO.LOADING);
                let { saveFile: v } = _,
                  f = null;
                if (
                  (1 === y
                    ? (n =
                        null === (o = window.Blockly) || void 0 === o
                          ? void 0
                          : null === (i = o.Xml) || void 0 === i
                          ? void 0
                          : i.workspaceToDom(
                              null === (t = window.Blockly) || void 0 === t
                                ? void 0
                                : t.derivWorkspace
                            ))
                    : (((f =
                        null ===
                          (s = (await (0, d.getSavedWorkspaces)()).filter(
                            (e) => e.id === g.id
                          )) || void 0 === s
                          ? void 0
                          : s[0]).name = u),
                      (f.save_type = l
                        ? d.save_types.LOCAL
                        : d.save_types.GOOGLE_DRIVE),
                      (n = window.Blockly.utils.xml.textToDom(f.xml))),
                  n.setAttribute("is_dbot", "true"),
                  n.setAttribute("collection", c ? "true" : "false"),
                  l
                    ? (0, d.save)(u, c, n)
                    : (await v({
                        name: u,
                        content:
                          null == tr
                            ? void 0
                            : null === (r = tr.Xml) || void 0 === r
                            ? void 0
                            : r.domToPrettyText(n),
                        mimeType: "application/xml",
                      }),
                      this.setButtonStatus(eO.COMPLETED)),
                  this.updateBotName(u),
                  0 === y)
                ) {
                  let e =
                    g.id ??
                    (null == tr
                      ? void 0
                      : null === (a = tr.utils) || void 0 === a
                      ? void 0
                      : a.genUid());
                  await this.addStrategyToWorkspace(e, l, c, u, n),
                    f && (await m(f));
                } else
                  await (0, d.saveWorkspaceToRecent)(
                    n,
                    l ? d.save_types.LOCAL : d.save_types.GOOGLE_DRIVE
                  );
                this.toggleSaveModal();
              }),
              (0, a._)(this, "updateBotName", (e) => {
                this.bot_name = e;
              }),
              (0, a._)(this, "onDriveConnect", async () => {
                let { google_drive: e } = this.root_store;
                e.is_authorised ? e.signOut() : e.signIn();
              }),
              (0, a._)(this, "setButtonStatus", (e) => {
                this.button_status = e;
              }),
              (0, n.rC)(this, {
                is_save_modal_open: n.LO,
                button_status: n.LO,
                bot_name: n.LO,
                toggleSaveModal: n.aD.bound,
                validateBotName: n.aD.bound,
                onConfirmSave: n.aD.bound,
                updateBotName: n.aD.bound,
                onDriveConnect: n.aD.bound,
                setButtonStatus: n.aD.bound,
              }),
              (this.root_store = e);
          }
        }
        var tn = i(87383);
        class tl {
          get initial_values() {
            return {
              form_max_losses: this.api_max_losses || "",
              run_limit: -1 !== this.run_limit ? this.run_limit : "",
            };
          }
          get should_bot_run() {
            let { client: e } = this.core;
            return (
              !e.is_eu ||
              !!e.is_virtual ||
              (0 !== this.api_max_losses && -1 !== this.run_limit)
            );
          }
          setIsRestricted(e) {
            this.is_restricted = e;
          }
          setApiMaxLosses(e) {
            this.api_max_losses = e;
          }
          setRunLimit(e) {
            this.run_limit = e;
          }
          resetSelfExclusion() {
            (this.is_restricted = !1),
              (this.api_max_losses = 0),
              (this.form_max_losses = 0),
              (this.run_limit = -1);
          }
          async checkRestriction() {
            d.api_base.api &&
              d.api_base.is_authorized &&
              (0, tn.Bc)() &&
              d.api_base.api.getSelfExclusion().then((e) => {
                let { get_self_exclusion: t } = e,
                  { max_losses: i } = t;
                i && this.setApiMaxLosses(i);
              });
          }
          constructor(e, t) {
            (0, a._)(this, "root_store", void 0),
              (0, a._)(this, "core", void 0),
              (0, a._)(this, "api_max_losses", 0),
              (0, a._)(this, "run_limit", -1),
              (0, a._)(this, "is_restricted", !1),
              (0, a._)(this, "form_max_losses", void 0),
              (0, n.rC)(this, {
                api_max_losses: n.LO,
                run_limit: n.LO,
                is_restricted: n.LO,
                initial_values: n.Fl,
                should_bot_run: n.Fl,
                setIsRestricted: n.aD.bound,
                setApiMaxLosses: n.aD.bound,
                setRunLimit: n.aD.bound,
                resetSelfExclusion: n.aD.bound,
                checkRestriction: n.aD.bound,
              }),
              (this.root_store = e),
              (this.core = t);
          }
        }
        var tc = i(88817);
        let td = (e) => {
          let { stop_loss: t, take_profit: i } = (0, c.gNN)(e);
          return {
            contract_update_stop_loss: t ? Math.abs(t).toString() : "",
            contract_update_take_profit: i ? i.toString() : "",
            has_contract_update_stop_loss: !!t,
            has_contract_update_take_profit: !!i,
          };
        };
        class tu {
          get is_contract_completed() {
            var e;
            return (
              !!(null === (e = this.contract_info) || void 0 === e
                ? void 0
                : e.is_sold) &&
              this.root_store.run_panel.contract_stage !==
                e7.K.PURCHASE_RECEIVED
            );
          }
          get is_contract_loading() {
            return (
              (this.root_store.run_panel.is_running &&
                null === this.contract_info) ||
              this.root_store.run_panel.contract_stage === e7.K.PURCHASE_SENT ||
              this.root_store.run_panel.contract_stage === e7.K.STARTING
            );
          }
          get is_contract_inactive() {
            return !this.contract_info && !this.is_loading;
          }
          get is_multiplier() {
            var e;
            return (0, c.L8o)(
              null === (e = this.contract_info) || void 0 === e
                ? void 0
                : e.contract_type
            );
          }
          get is_accumulator() {
            var e;
            return (0, c.XtD)(
              null === (e = this.contract_info) || void 0 === e
                ? void 0
                : e.contract_type
            );
          }
          clear() {
            let e =
              !(arguments.length > 0) ||
              void 0 === arguments[0] ||
              arguments[0];
            e && (this.contract_info = null),
              (this.profit = 0),
              (this.profit_loss = 0),
              (this.indicative = 0),
              (this.indicative_movement = ""),
              (this.profit_movement = "");
          }
          clearContractUpdateConfigValues() {
            if (this.contract_info) {
              let {
                contract_update_stop_loss: e,
                contract_update_take_profit: t,
                has_contract_update_stop_loss: i,
                has_contract_update_take_profit: o,
              } = td(this.contract_info.limit_order);
              (this.contract_update_stop_loss = e),
                (this.contract_update_take_profit = t),
                (this.has_contract_update_stop_loss = i),
                (this.has_contract_update_take_profit = o);
            }
          }
          getLimitOrder() {
            let e = {};
            return (
              (e.take_profit = this.has_contract_update_take_profit
                ? +(this.contract_update_take_profit ?? 0)
                : 0),
              (e.stop_loss = this.has_contract_update_stop_loss
                ? +(this.contract_update_stop_loss ?? 0)
                : 0),
              e
            );
          }
          onBotContractEvent(e) {
            let { profit: t } = e,
              i = (0, c.Kq_)(e);
            (this.profit = t),
              this.contract_id !== e.id &&
                (this.clear(!1),
                (this.contract_id = e.id),
                (this.indicative = i));
            let o = { profit: t, indicative: i };
            Object.keys(o).forEach((e) => {
              let t = o[e],
                i = this[e];
              e in this && t && t !== i
                ? (this[`${e}_movement`] =
                    t && t > (this[e] || 0) ? "profit" : "loss")
                : "" !== this[`${e}_movement`] &&
                  (this.indicative_movement = ""),
                "profit" === e && (this.profit_loss = t),
                "indicative" === e && (this.indicative = t);
            }),
              (this.contract_info = e);
          }
          onChange(e) {
            let { name: t, value: i } = e;
            (this[t] = i), this.validateProperty(t, i);
          }
          populateContractUpdateConfig(e) {
            let t = td(null == e ? void 0 : e.contract_update);
            if (!(0, c.uvr)(this.contract_update_config, t)) {
              Object.assign(this, t), (this.contract_update_config = t);
              let { contract_update: o, error: s } = e;
              if (this.contract_info && o && !s) {
                var i;
                this.contract_info.limit_order = Object.assign(
                  (null === (i = this.contract_info) || void 0 === i
                    ? void 0
                    : i.limit_order) || {},
                  o
                );
              }
            }
          }
          setContractUpdateConfig(e, t) {
            e &&
              t &&
              ((this.has_contract_update_take_profit = !!e),
              (this.has_contract_update_stop_loss = !!t),
              (this.contract_update_take_profit = this
                .has_contract_update_take_profit
                ? +e
                : null),
              (this.contract_update_stop_loss = this
                .has_contract_update_stop_loss
                ? +t
                : null));
          }
          setIsBotRunning() {
            if (!this.is_contract_loading) {
              this.is_bot_running = !1;
              return;
            }
            let e = setTimeout(() => {
              this.is_contract_loading &&
                ((this.is_bot_running = !0),
                this.root_store.run_panel.setContractStage(e7.K.RUNNING));
            }, 5e3);
            return () => clearTimeout(e);
          }
          updateLimitOrder() {
            var e, t, i, o;
            let s = this.getLimitOrder();
            (null === (e = this.contract_info) || void 0 === e
              ? void 0
              : e.contract_id) &&
              (null === (t = this.contract_info) || void 0 === t
                ? void 0
                : t.contract_id) &&
              (null === (o = d.api_base.api) ||
                void 0 === o ||
                o
                  .send({
                    contract_update: 1,
                    contract_id:
                      null === (i = this.contract_info) || void 0 === i
                        ? void 0
                        : i.contract_id,
                    limit_order: s,
                  })
                  .then((e) => {
                    this.populateContractUpdateConfig(e);
                  })
                  .catch((e) => {
                    var t;
                    this.root_store.run_panel.showContractUpdateErrorDialog(
                      null == e
                        ? void 0
                        : null === (t = e.error) || void 0 === t
                        ? void 0
                        : t.message
                    );
                  }));
          }
          setValidationErrorMessages(e, t) {
            (!this.validation_errors[e] ||
              this.validation_errors[e]
                .filter((e) => !t.includes(e))
                .concat(t.filter((t) => !this.validation_errors[e].includes(t)))
                .length) &&
              (this.validation_errors[e] = t);
          }
          validateProperty(e, t) {
            let i = this.validation_rules[e].trigger,
              o = { [e]: void 0 !== t ? t : this[e] },
              s = { [e]: this.validation_rules[e].rules || [] };
            i &&
              Object.hasOwnProperty.call(this, i) &&
              ((o[i] = this[i]), (s[i] = this.validation_rules[i].rules || []));
            let r = new c.cX8(o, s, this);
            r.isPassed(),
              Object.keys(o).forEach((e) => {
                this.setValidationErrorMessages(e, r.errors.get(e));
              });
          }
          registerReactions() {
            let { client: e } = this.core;
            return (
              (this.disposeSwitchAcountListener = (0, n.U5)(
                () => e.loginid,
                () => this.clear()
              )),
              () => {
                "function" == typeof this.disposeSwitchAcountListener &&
                  this.disposeSwitchAcountListener();
              }
            );
          }
          constructor(e, t) {
            (0, a._)(this, "root_store", void 0),
              (0, a._)(this, "core", void 0),
              (0, a._)(this, "disposeReactionsFn", void 0),
              (0, a._)(this, "disposeSwitchAcountListener", void 0),
              (0, a._)(this, "contract_info", null),
              (0, a._)(this, "is_loading", !1),
              (0, a._)(this, "indicative_movement", ""),
              (0, a._)(this, "profit_movement", ""),
              (0, a._)(this, "validation_errors", {}),
              (0, a._)(this, "validation_rules", (0, tc.sl)()),
              (0, a._)(this, "contract_update_take_profit", null),
              (0, a._)(this, "contract_update_stop_loss", null),
              (0, a._)(this, "has_contract_update_take_profit", !1),
              (0, a._)(this, "has_contract_update_stop_loss", !1),
              (0, a._)(this, "contract_update_config", {}),
              (0, a._)(this, "profit_loss", 0),
              (0, a._)(this, "contract_id", null),
              (0, a._)(this, "profit", 0),
              (0, a._)(this, "indicative", 0),
              (0, a._)(this, "is_bot_running", !1),
              (0, n.rC)(this, {
                contract_info: n.LO,
                indicative_movement: n.LO,
                profit_movement: n.LO,
                validation_errors: n.LO,
                validation_rules: n.LO,
                contract_update_take_profit: n.LO,
                contract_update_stop_loss: n.LO,
                has_contract_update_take_profit: n.LO,
                has_contract_update_stop_loss: n.LO,
                is_bot_running: n.LO,
                contract_update_config: n.LO,
                contract_id: n.LO,
                profit: n.LO,
                indicative: n.LO,
                is_contract_completed: n.Fl,
                is_contract_loading: n.Fl,
                is_contract_inactive: n.Fl,
                is_multiplier: n.Fl,
                clear: n.aD.bound,
                clearContractUpdateConfigValues: n.aD.bound,
                getLimitOrder: n.aD.bound,
                onBotContractEvent: n.aD.bound,
                onChange: n.aD.bound,
                populateContractUpdateConfig: n.aD.bound,
                setContractUpdateConfig: n.aD.bound,
                setIsBotRunning: n.aD.bound,
                updateLimitOrder: n.aD.bound,
                setValidationErrorMessages: n.aD,
                validateProperty: n.aD,
                registerReactions: n.aD.bound,
              }),
              (this.root_store = e),
              (this.core = t),
              (this.disposeReactionsFn = this.registerReactions());
          }
        }
        class th {
          constructor(e) {
            (0, a._)(this, "root_store", void 0),
              (0, a._)(this, "is_animation_info_modal_open", !1),
              (0, a._)(this, "is_dialog_open", !1),
              (0, a._)(this, "file_name", (0, d.config)().default_file_name),
              (0, a._)(this, "has_undo_stack", !1),
              (0, a._)(this, "has_redo_stack", !1),
              (0, a._)(this, "is_reset_button_clicked", !1),
              (0, a._)(this, "setResetButtonState", (e) => {
                this.is_reset_button_clicked = e;
              }),
              (0, a._)(this, "onResetClick", () => {
                this.is_dialog_open = !0;
              }),
              (0, a._)(this, "closeResetDialog", () => {
                this.is_dialog_open = !1;
              }),
              (0, a._)(this, "onResetOkButtonClick", () => {
                this.setResetButtonState(!0),
                  (0, d.runGroupedEvents)(
                    !1,
                    () => {
                      this.resetDefaultStrategy();
                    },
                    "reset"
                  ),
                  (this.is_dialog_open = !1);
              }),
              (0, a._)(this, "resetDefaultStrategy", async () => {
                var e, t, i, o;
                let s = window.Blockly.derivWorkspace;
                (s.current_strategy_id =
                  null === (o = window) || void 0 === o
                    ? void 0
                    : null === (i = o.Blockly) || void 0 === i
                    ? void 0
                    : null === (t = i.utils) || void 0 === t
                    ? void 0
                    : null === (e = t.idGenerator) || void 0 === e
                    ? void 0
                    : e.genUid()),
                  await (0, d.load)({
                    block_string: s.cached_xml.main,
                    file_name: (0, d.config)().default_file_name,
                    workspace: s,
                    drop_event: null,
                    strategy_id: null,
                    from: null,
                    showIncompatibleStrategyDialog: null,
                  }),
                  (s.strategy_to_load = s.cached_xml.main),
                  this.setResetButtonState(!1);
              }),
              (0, a._)(this, "onSortClick", () => {
                let {
                  workspaces: {
                    indentWorkspace: { x: e, y: t },
                  },
                } = (0, d.config)();
                window.Blockly.derivWorkspace.cleanUp(e, t);
              }),
              (0, a._)(this, "onUndoClick", (e) => {
                window.Blockly.Events.setGroup("undo_clicked"),
                  window.Blockly.derivWorkspace.undo(e),
                  window.Blockly.svgResize(window.Blockly.derivWorkspace),
                  this.setHasRedoStack(),
                  this.setHasUndoStack(),
                  window.Blockly.Events.setGroup(!1);
              }),
              (0, a._)(this, "onZoomInOutClick", (e) => {
                let t = window.Blockly.derivWorkspace,
                  i = t.getMetrics();
                t.zoom(i.viewWidth / 2, i.viewHeight / 2, e ? 1 : -1);
              }),
              (0, a._)(this, "setHasUndoStack", () => {
                var e, t;
                this.has_undo_stack =
                  (null === (t = window.Blockly.derivWorkspace) || void 0 === t
                    ? void 0
                    : null === (e = t.undoStack_) || void 0 === e
                    ? void 0
                    : e.length) > 0;
              }),
              (0, a._)(this, "setHasRedoStack", () => {
                var e, t;
                this.has_redo_stack =
                  (null === (t = window.Blockly.derivWorkspace) || void 0 === t
                    ? void 0
                    : null === (e = t.redoStack_) || void 0 === e
                    ? void 0
                    : e.length) > 0;
              }),
              (0, n.rC)(this, {
                is_animation_info_modal_open: n.LO,
                is_dialog_open: n.LO,
                file_name: n.LO,
                has_undo_stack: n.LO,
                has_redo_stack: n.LO,
                is_reset_button_clicked: n.LO,
                onResetClick: n.aD.bound,
                closeResetDialog: n.aD.bound,
                onResetOkButtonClick: n.aD.bound,
                onUndoClick: n.aD.bound,
                resetDefaultStrategy: n.aD.bound,
                setHasUndoStack: n.aD.bound,
                setHasRedoStack: n.aD.bound,
              }),
              (this.root_store = e);
          }
        }
        class tp {
          onUnmount() {
            "function" == typeof this.disposeToolboxToggleReaction &&
              this.disposeToolboxToggleReaction();
          }
          setWorkspaceOptions() {
            let e, t, i, o, s;
            let r = window.Blockly.derivWorkspace;
            r.options.readOnly
              ? ((e = null), (t = !1), (i = !1), (o = !1), (s = !1))
              : ((i = t =
                  !!(
                    (e = this.toolbox_dom) &&
                    e.getElementsByTagName("category").length
                  )),
                (o = t),
                (s = t)),
              (r.options.collapse = i),
              (r.options.comments = o),
              (r.options.disable = s),
              (r.options.hasCategories = t),
              (r.options.languageTree = e);
          }
          adjustWorkspace() {
            this.is_workspace_scroll_adjusted ||
              this.root_store.load_modal.is_load_modal_open ||
              ((this.is_workspace_scroll_adjusted = !0),
              setTimeout(() => {
                var e, t;
                let i = window.Blockly.derivWorkspace,
                  o =
                    (null === (e = document.getElementById("gtm-toolbox")) ||
                    void 0 === e
                      ? void 0
                      : e.getBoundingClientRect().width) || 0,
                  s =
                    null === (t = i.svgBlockCanvas_) || void 0 === t
                      ? void 0
                      : t.getBoundingClientRect();
                if (i.RTL && s) {
                  let e = this.core.ui.is_mobile,
                    t = e ? s.right : s.left,
                    r = this.core.ui.is_mobile ? o - t + 20 : o - t + 36;
                  (Math.round(t) <= o || e) &&
                    (0, d.scrollWorkspace)(i, r, !0, !1);
                } else if (Math.round(null == s ? void 0 : s.left) <= o) {
                  let e = this.core.ui.is_mobile
                    ? o - s.left + 50
                    : o - s.left + 36;
                  (0, d.scrollWorkspace)(i, e, !0, !1);
                }
                this.is_workspace_scroll_adjusted = !1;
              }, 300));
          }
          toggleDrawer() {
            this.is_toolbox_open = !this.is_toolbox_open;
          }
          onToolboxItemClick(e) {
            var t;
            let { flyout: i } = this.root_store,
              o = e.getAttribute("id"),
              s = this.getCategoryContents(e);
            i.setIsSearchFlyout(!1),
              (null === (t = i.selected_category) || void 0 === t
                ? void 0
                : t.getAttribute("id")) === o
                ? i.setVisibility(!1)
                : (i.setSelectedCategory(e), i.setContents(s));
          }
          onToolboxItemExpand(e) {
            if (this.sub_category_index.includes(e)) {
              let t = this.sub_category_index.filter((t) => t !== e);
              this.sub_category_index = t;
            } else this.sub_category_index = [...this.sub_category_index, e];
          }
          onSearchBlur() {
            this.is_search_focus = !1;
          }
          onSearchClear(e) {
            e("search", ""), this.showSearch("");
          }
          onSearchKeyUp(e) {
            (this.is_search_loading = !0),
              clearTimeout(this.typing_timer),
              (this.typing_timer = setTimeout(
                (0, n.aD)(() => {
                  e(), (this.is_search_loading = !1);
                }),
                1e3
              ));
          }
          constructor(e, t) {
            (0, a._)(this, "root_store", void 0),
              (0, a._)(this, "core", void 0),
              (0, a._)(this, "disposeToolboxToggleReaction", void 0),
              (0, a._)(this, "typing_timer", void 0),
              (0, a._)(this, "is_toolbox_open", !0),
              (0, a._)(this, "is_search_loading", !1),
              (0, a._)(this, "is_search_focus", !1),
              (0, a._)(this, "sub_category_index", []),
              (0, a._)(this, "toolbox_dom", void 0),
              (0, a._)(this, "toolbox_examples", void 0),
              (0, a._)(this, "is_workspace_scroll_adjusted", !1),
              (0, a._)(this, "onMount", (e) => {
                var t;
                this.adjustWorkspace(),
                  (this.toolbox_dom = window.Blockly.utils.xml.textToDom(
                    null == e ? void 0 : e.current
                  ));
                let i = [
                  ...((null === (t = this.toolbox_dom) || void 0 === t
                    ? void 0
                    : t.childNodes) ?? []),
                ].find(
                  (e) => e instanceof HTMLElement && "examples" === e.tagName
                );
                i && (this.toolbox_examples = i),
                  this.setWorkspaceOptions(),
                  (this.disposeToolboxToggleReaction = (0, n.U5)(
                    () => this.is_toolbox_open,
                    (e) => {
                      if (e) {
                        var t;
                        null === eE.default ||
                          void 0 === eE.default ||
                          null === (t = eE.default.pushDataLayer) ||
                          void 0 === t ||
                          t.call(eE.default, {
                            event: "dbot_toolbox_visible",
                            value: !0,
                          });
                      }
                    }
                  ));
              }),
              (0, a._)(this, "getCategoryContents", (e) => {
                let t = window.Blockly.derivWorkspace,
                  i = e.getAttribute("dynamic"),
                  o = Array.from(e.childNodes);
                if ("string" == typeof i) {
                  let e = t.getToolboxCategoryCallback(i);
                  "VARIABLE" === i && (e = window.Blockly.DataCategory),
                    (o = e(t));
                }
                return o;
              }),
              (0, a._)(this, "getAllCategories", () => {
                let e = [];
                return (
                  Array.from(this.toolbox_dom.childNodes).forEach((t) => {
                    e.push(t),
                      this.hasSubCategory(t.children) &&
                        Array.from(t.children).forEach((t) => {
                          e.push(t);
                        });
                  }),
                  e
                );
              }),
              (0, a._)(
                this,
                "hasSubCategory",
                (e) =>
                  !!Object.keys(e).filter((t) => {
                    if ("CATEGORY" === e[Number(t)].tagName.toUpperCase())
                      return e[Number(t)];
                  }).length
              ),
              (0, a._)(this, "onSearch", (e) => {
                let { search: t = "" } = e;
                (this.is_search_focus = !0), this.showSearch(t);
              }),
              (0, a._)(this, "showSearch", (e) => {
                let t = window.Blockly.derivWorkspace,
                  i = [],
                  o = e.replace(/\s+/g, " ").trim().toUpperCase(),
                  s = o.split(" "),
                  r = t.getVariablesOfType(""),
                  a = window.Blockly.Procedures.allProcedures(t),
                  { flyout: n } = this.root_store;
                n.setVisibility(!1);
                let l = [
                  (0, h.NC)("THE"),
                  (0, h.NC)("OF"),
                  (0, h.NC)("YOU"),
                  (0, h.NC)("IS"),
                  (0, h.NC)("THIS"),
                  (0, h.NC)("THEN"),
                  (0, h.NC)("A"),
                  (0, h.NC)("AN"),
                ];
                if (0 === o.length) return;
                if (o.length <= 1 || s.every((e) => l.includes(e))) {
                  n.setIsSearchFlyout(!0), n.setContents(i, e);
                  return;
                }
                let c = this.getAllCategories()
                    .filter((e) => !this.hasSubCategory(e.children))
                    .map((e) =>
                      Array.from(this.getCategoryContents(e)).filter(
                        (e) => "BLOCK" === e.tagName.toUpperCase()
                      )
                    )
                    .flat(),
                  d = function () {
                    let e =
                        arguments.length > 0 && void 0 !== arguments[0]
                          ? arguments[0]
                          : [],
                      t =
                        arguments.length > 1 && void 0 !== arguments[1]
                          ? arguments[1]
                          : {};
                    e.some((e) => e === t) || e.push(t);
                  },
                  u = (e) => {
                    c.forEach((t) => {
                      let r = t.getAttribute("type"),
                        a = window.Blockly.Blocks[r],
                        n = a.meta instanceof Function && a.meta(),
                        l = a.definition instanceof Function && a.definition(),
                        c = n.display_name,
                        u = r.toUpperCase().split("_"),
                        h = c.toUpperCase().split(" "),
                        p = /^((message)|(tooltip)|(category))/;
                      switch (e) {
                        case "exact_block_name":
                          (o === c.toUpperCase() || o === r.toUpperCase()) &&
                            d(i, t);
                          break;
                        case "match_words":
                          (s.every((e) => h.some((t) => t.includes(e))) ||
                            s.every((e) => u.some((t) => t.includes(e)))) &&
                            d(i, t);
                          break;
                        case "block_term":
                          (u.some((e) => s.some((t) => e.includes(t))) ||
                            h.some((e) => s.some((t) => e.includes(t)))) &&
                            d(i, t);
                          break;
                        case "block_definitions":
                          Object.keys(l).forEach((e) => {
                            let r = l[e];
                            p.test(e) &&
                              s.some((e) => r.includes(e)) &&
                              d(i, t),
                              r instanceof Array &&
                                r.forEach((e) => {
                                  let r = JSON.stringify(e).toUpperCase();
                                  "field_dropdown" === e.type &&
                                    o.length > 2 &&
                                    s.some((e) => r.includes(e)) &&
                                    d(i, t);
                                });
                          });
                          break;
                        case "block_meta": {
                          let e = Object.keys(n)
                            .filter((e) => "display_name" !== e)
                            .find((e) => {
                              let t = n[e]
                                .toUpperCase()
                                .replace(/[^\w\s]/gi, "")
                                .split(" ");
                              return s.some((e) =>
                                t.some((t) => t.includes(e))
                              );
                            });
                          e && e.length && d(i, t);
                        }
                      }
                    });
                  };
                [
                  "exact_block_name",
                  "match_words",
                  "block_term",
                  "block_definitions",
                  "block_meta",
                ].forEach((e) => u(e));
                let p = r.filter((e) => e.name.toUpperCase().includes(o)),
                  _ = window.Blockly.DataCategory.search(p).filter(
                    (e) => -1 === i.indexOf(e)
                  );
                _ && _.length && i.unshift(..._);
                let m = { 0: [], 1: [] },
                  g = a[0],
                  y = a[1];
                Object.keys(g).forEach((e) => {
                  let t = g[e];
                  t[0].toUpperCase().includes(o) && m["0"].unshift(t);
                }),
                  Object.keys(y).forEach((e) => {
                    let t = y[e];
                    t[0].toUpperCase().includes(o) && m["1"].unshift(t);
                  });
                let v = window.Blockly.Procedures.populateDynamicProcedures(
                  m
                ).filter((e) => -1 === i.indexOf(e));
                v.length && i.unshift(...v),
                  n.setIsSearchFlyout(!0),
                  n.setContents(i, e);
              }),
              (0, n.rC)(this, {
                is_toolbox_open: n.LO,
                is_search_loading: n.LO,
                is_search_focus: n.LO,
                sub_category_index: n.LO,
                toolbox_dom: n.LO,
                toolbox_examples: n.LO,
                onMount: n.aD.bound,
                onUnmount: n.aD.bound,
                setWorkspaceOptions: n.aD.bound,
                adjustWorkspace: n.aD.bound,
                toggleDrawer: n.aD.bound,
                onToolboxItemClick: n.aD.bound,
                onToolboxItemExpand: n.aD.bound,
                getCategoryContents: n.aD.bound,
                getAllCategories: n.aD.bound,
                hasSubCategory: n.aD.bound,
                onSearch: n.aD.bound,
                onSearchBlur: n.aD.bound,
                onSearchClear: n.aD.bound,
                onSearchKeyUp: n.aD.bound,
                showSearch: n.aD.bound,
              }),
              (this.root_store = e),
              (this.core = t);
          }
        }
        var t_ = i(33690);
        class tm {
          get transactions() {
            var e, t, i, o;
            return (
              null === (t = this.core) || void 0 === t
                ? void 0
                : null === (e = t.client) || void 0 === e
                ? void 0
                : e.loginid
            )
              ? this.elements[
                  null === (o = this.core) || void 0 === o
                    ? void 0
                    : null === (i = o.client) || void 0 === i
                    ? void 0
                    : i.loginid
                ] ?? []
              : [];
          }
          get statistics() {
            let e = 0,
              t = this.transactions
                .filter(
                  (e) => e.type === t_.i.CONTRACT && "object" == typeof e.data
                )
                .reduce(
                  (t, i) => {
                    let { data: o } = i,
                      {
                        profit: s = 0,
                        is_completed: r = !1,
                        buy_price: a = 0,
                        payout: n,
                        bid_price: l,
                      } = o;
                    return (
                      r &&
                        (s > 0
                          ? ((t.won_contracts += 1),
                            (t.total_payout += n ?? l ?? 0))
                          : (t.lost_contracts += 1),
                        (t.total_profit += s),
                        (t.total_stake += a),
                        (e += 1)),
                      t
                    );
                  },
                  {
                    lost_contracts: 0,
                    number_of_runs: 0,
                    total_profit: 0,
                    total_payout: 0,
                    total_stake: 0,
                    won_contracts: 0,
                  }
                );
            return (t.number_of_runs = e), t;
          }
          onBotContractEvent(e) {
            this.pushTransaction(e);
          }
          pushTransaction(e) {
            var t, i, o, s, r, a, n, l, d;
            let u = (0, c.UTW)(e),
              { run_id: h } = this.root_store.run_panel,
              p =
                null === (i = this.core) || void 0 === i
                  ? void 0
                  : null === (t = i.client) || void 0 === t
                  ? void 0
                  : t.loginid,
              _ = {
                ...e,
                is_completed: u,
                run_id: h,
                date_start: (0, c.p6d)(e.date_start, "YYYY-M-D HH:mm:ss [GMT]"),
                entry_tick: e.entry_tick_display_value,
                entry_tick_time:
                  e.entry_tick_time &&
                  (0, c.p6d)(e.entry_tick_time, "YYYY-M-D HH:mm:ss [GMT]"),
                exit_tick: e.exit_tick_display_value,
                exit_tick_time:
                  e.exit_tick_time &&
                  (0, c.p6d)(e.exit_tick_time, "YYYY-M-D HH:mm:ss [GMT]"),
                profit: u ? e.profit : 0,
              };
            this.elements[p] || (this.elements = { ...this.elements, [p]: [] });
            let m =
              null === (o = this.elements[p]) || void 0 === o
                ? void 0
                : o.findIndex((t) => {
                    var i, o;
                    return (
                      "string" != typeof t.data &&
                      t.type === t_.i.CONTRACT &&
                      (null === (i = t.data) || void 0 === i
                        ? void 0
                        : i.transaction_ids) &&
                      t.data.transaction_ids.buy ===
                        (null === (o = e.transaction_ids) || void 0 === o
                          ? void 0
                          : o.buy)
                    );
                  });
            if (-1 === m) {
              if (
                (null === (s = this.elements[p]) || void 0 === s
                  ? void 0
                  : s.length) > 0
              ) {
                let e =
                  null === (a = this.elements[p]) || void 0 === a
                    ? void 0
                    : a[0];
                e.type === t_.i.CONTRACT &&
                  "object" == typeof e.data &&
                  _.run_id !==
                    (null == e
                      ? void 0
                      : null === (n = e.data) || void 0 === n
                      ? void 0
                      : n.run_id) &&
                  (null === (l = this.elements[p]) ||
                    void 0 === l ||
                    l.unshift({ type: t_.i.DIVIDER, data: _.run_id }));
              }
              null === (r = this.elements[p]) ||
                void 0 === r ||
                r.unshift({ type: t_.i.CONTRACT, data: _ });
            } else
              null === (d = this.elements[p]) ||
                void 0 === d ||
                d.splice(m, 1, { type: t_.i.CONTRACT, data: _ });
            this.elements = { ...this.elements };
          }
          clear() {
            var e, t, i, o, s, r, a;
            this.elements &&
              (null ===
                (e =
                  this.elements[
                    null === (i = this.core) || void 0 === i
                      ? void 0
                      : null === (t = i.client) || void 0 === t
                      ? void 0
                      : t.loginid
                  ]) || void 0 === e
                ? void 0
                : e.length) > 0 &&
              (this.elements[
                null === (a = this.core) || void 0 === a
                  ? void 0
                  : null === (r = a.client) || void 0 === r
                  ? void 0
                  : r.loginid
              ] = []),
              (this.recovered_completed_transactions =
                null === (o = this.recovered_completed_transactions) ||
                void 0 === o
                  ? void 0
                  : o.slice(0, 0)),
              (this.recovered_transactions =
                null === (s = this.recovered_transactions) || void 0 === s
                  ? void 0
                  : s.slice(0, 0)),
              (this.is_transaction_details_modal_open = !1);
          }
          registerReactions() {
            let { client: e } = this.core,
              t = (0, n.U5)(
                () => this.elements[null == e ? void 0 : e.loginid],
                (t) => {
                  let i = eJ(this.TRANSACTION_CACHE, {});
                  (i[e.loginid] = (null == t ? void 0 : t.slice(0, 5e3)) ?? []),
                    eQ(this.TRANSACTION_CACHE, i);
                }
              ),
              i = (0, n.U5)(
                () => this.transactions.length,
                () => this.recoverPendingContracts()
              );
            return () => {
              t(), i();
            };
          }
          recoverPendingContracts() {
            let e =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : null;
            this.transactions.forEach((t) => {
              let { data: i } = t;
              "string" == typeof i ||
                (null == i ? void 0 : i.is_completed) ||
                !(null == i ? void 0 : i.contract_id) ||
                this.recovered_transactions.includes(
                  null == i ? void 0 : i.contract_id
                ) ||
                this.recoverPendingContractsById(i.contract_id, e);
            });
          }
          updateResultsCompletedContract(e) {
            let { journal: t, summary_card: i } = this.root_store,
              { contract_info: o } = i,
              { currency: s, profit: r } = e;
            e.contract_id !== (null == o ? void 0 : o.contract_id) &&
              (this.onBotContractEvent(e),
              e.contract_id &&
                !this.recovered_transactions.includes(e.contract_id) &&
                this.recovered_transactions.push(e.contract_id),
              e.contract_id &&
                !this.recovered_completed_transactions.includes(
                  e.contract_id
                ) &&
                (0, c.UTW)(e) &&
                (this.recovered_completed_transactions.push(e.contract_id),
                t.onLogSuccess({
                  log_type: r && r > 0 ? d.LogTypes.PROFIT : d.LogTypes.LOST,
                  extra: { currency: s, profit: r },
                })));
          }
          sortOutPositionsBeforeAction(e, t) {
            null == e ||
              e.forEach((e) => {
                if (!t || (t && e.id === t)) {
                  let t = e.contract_info;
                  this.updateResultsCompletedContract(t);
                }
              });
          }
          async recoverPendingContractsById(e) {
            let t =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : null,
              i = [];
            if (
              (t &&
                ((this.is_called_proposal_open_contract = !0),
                t.contract_id === e && this.updateResultsCompletedContract(t)),
              !this.is_called_proposal_open_contract)
            ) {
              var o, s, r, a, n, l;
              if (
                null === (s = this.core) || void 0 === s
                  ? void 0
                  : null === (o = s.client) || void 0 === o
                  ? void 0
                  : o.loginid
              ) {
                let e =
                  null === (a = this.core) || void 0 === a
                    ? void 0
                    : null === (r = a.client) || void 0 === r
                    ? void 0
                    : r.loginid;
                (null === (n = this.elements[e]) || void 0 === n
                  ? void 0
                  : n.length) || this.sortOutPositionsBeforeAction(i);
                let [t = null] = this.elements[e];
                if (
                  "object" == typeof (null == t ? void 0 : t.data) &&
                  !(null == t
                    ? void 0
                    : null === (l = t.data) || void 0 === l
                    ? void 0
                    : l.profit)
                ) {
                  let e = t.data.contract_id;
                  this.sortOutPositionsBeforeAction(i, e);
                }
              }
            }
          }
          constructor(e, t) {
            var i, o;
            (0, a._)(this, "root_store", void 0),
              (0, a._)(this, "core", void 0),
              (0, a._)(this, "disposeReactionsFn", void 0),
              (0, a._)(this, "TRANSACTION_CACHE", "transaction_cache"),
              (0, a._)(
                this,
                "elements",
                eZ(
                  this.TRANSACTION_CACHE,
                  null === (o = this.core) || void 0 === o
                    ? void 0
                    : null === (i = o.client) || void 0 === i
                    ? void 0
                    : i.loginid,
                  []
                )
              ),
              (0, a._)(this, "active_transaction_id", null),
              (0, a._)(this, "recovered_completed_transactions", []),
              (0, a._)(this, "recovered_transactions", []),
              (0, a._)(this, "is_called_proposal_open_contract", !1),
              (0, a._)(this, "is_transaction_details_modal_open", !1),
              (0, a._)(this, "toggleTransactionDetailsModal", (e) => {
                this.is_transaction_details_modal_open = e;
              }),
              (this.root_store = e),
              (this.core = t),
              (this.is_transaction_details_modal_open = !1),
              (this.disposeReactionsFn = this.registerReactions()),
              (0, n.rC)(this, {
                elements: n.LO,
                active_transaction_id: n.LO,
                recovered_completed_transactions: n.LO,
                recovered_transactions: n.LO,
                is_called_proposal_open_contract: n.LO,
                is_transaction_details_modal_open: n.LO,
                transactions: n.Fl,
                onBotContractEvent: n.aD.bound,
                pushTransaction: n.aD.bound,
                clear: n.aD.bound,
                registerReactions: n.aD.bound,
                recoverPendingContracts: n.aD.bound,
                updateResultsCompletedContract: n.aD.bound,
                sortOutPositionsBeforeAction: n.aD.bound,
                recoverPendingContractsById: n.aD.bound,
              });
          }
        }
        var tg = i(77149);
        class ty {
          setIsTradingAssessmentForNewUserEnabled(e) {
            this.is_trading_assessment_for_new_user_enabled = e;
          }
          toggleAccountsDialog() {
            let e =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : !this.is_accounts_switcher_on;
            this.is_accounts_switcher_on = e;
          }
          toggleOnScreenKeyboard() {
            this.is_onscreen_keyboard_active =
              null !== this.current_focus && this.is_mobile && (0, tg.b1)();
          }
          setCurrentFocus(e) {
            (this.current_focus = e), this.toggleOnScreenKeyboard();
          }
          constructor() {
            (0, a._)(this, "is_mobile", !0),
              (0, a._)(this, "is_desktop", !0),
              (0, a._)(this, "is_tablet", !1),
              (0, a._)(this, "is_chart_layout_default", !0),
              (0, a._)(
                this,
                "is_dark_mode_on",
                "dark" === localStorage.getItem("theme")
              ),
              (0, a._)(this, "account_switcher_disabled_message", ""),
              (0, a._)(this, "current_focus", null),
              (0, a._)(this, "show_prompt", !1),
              (0, a._)(this, "is_trading_assessment_for_new_user_enabled", !1),
              (0, a._)(this, "is_accounts_switcher_on", !1),
              (0, a._)(this, "is_onscreen_keyboard_active", !1),
              (0, a._)(this, "setPromptHandler", (e) => {
                this.show_prompt = e;
              }),
              (0, a._)(this, "setAccountSwitcherDisabledMessage", (e) => {
                e
                  ? (this.account_switcher_disabled_message = e)
                  : (this.account_switcher_disabled_message = "");
              }),
              (0, a._)(this, "setDarkMode", (e) => {
                this.is_dark_mode_on = e;
              }),
              (0, a._)(this, "setDevice", (e) => {
                (this.is_mobile = "mobile" === e),
                  (this.is_desktop = "desktop" === e),
                  (this.is_tablet = "tablet" === e);
              }),
              (0, n.rC)(this, {
                account_switcher_disabled_message: n.LO,
                current_focus: n.LO,
                is_accounts_switcher_on: n.LO,
                is_dark_mode_on: n.LO,
                is_desktop: n.LO,
                is_mobile: n.LO,
                is_tablet: n.LO,
                is_trading_assessment_for_new_user_enabled: n.LO,
                show_prompt: n.LO,
                setAccountSwitcherDisabledMessage: n.aD.bound,
                setCurrentFocus: n.aD.bound,
                setDarkMode: n.aD.bound,
                setDevice: n.aD.bound,
                setPromptHandler: n.aD.bound,
                setIsTradingAssessmentForNewUserEnabled: n.aD.bound,
                toggleAccountsDialog: n.aD.bound,
                toggleOnScreenKeyboard: n.aD.bound,
              });
          }
        }
        class tv {
          constructor(e) {
            (0, a._)(this, "dbot", void 0),
              (0, a._)(this, "app", void 0),
              (0, a._)(this, "summary_card", void 0),
              (0, a._)(this, "flyout", void 0),
              (0, a._)(this, "flyout_help", void 0),
              (0, a._)(this, "google_drive", void 0),
              (0, a._)(this, "journal", void 0),
              (0, a._)(this, "load_modal", void 0),
              (0, a._)(this, "run_panel", void 0),
              (0, a._)(this, "save_modal", void 0),
              (0, a._)(this, "transactions", void 0),
              (0, a._)(this, "toolbar", void 0),
              (0, a._)(this, "toolbox", void 0),
              (0, a._)(this, "quick_strategy", void 0),
              (0, a._)(this, "self_exclusion", void 0),
              (0, a._)(this, "dashboard", void 0),
              (0, a._)(this, "chart_store", void 0),
              (0, a._)(this, "blockly_store", void 0),
              (0, a._)(this, "data_collection_store", void 0),
              (0, a._)(this, "ui", void 0),
              (0, a._)(this, "client", void 0),
              (0, a._)(this, "common", void 0),
              (0, a._)(this, "core", { ui: {}, client: {}, common: {} }),
              (this.dbot = e),
              (this.ui = new ty()),
              (this.client = new k()),
              (this.common = new S()),
              (this.core.ui = this.ui),
              (this.core.client = this.client),
              (this.core.common = this.common),
              (this.app = new p(this, this.core)),
              (this.summary_card = new tu(this, this.core)),
              (this.flyout = new eD(this)),
              (this.flyout_help = new ex(this)),
              (this.google_drive = new eL(this)),
              (this.journal = new e0(this, this.core)),
              (this.load_modal = new e3(this, this.core)),
              (this.run_panel = new ti(this, this.core)),
              (this.save_modal = new ta(this)),
              (this.transactions = new tm(this, this.core)),
              (this.toolbar = new th(this)),
              (this.toolbox = new tp(this, this.core)),
              (this.quick_strategy = new e4(this)),
              (this.self_exclusion = new tl(this, this.core)),
              (this.dashboard = new R(this, this.core)),
              (this.chart_store = new y(this)),
              (this.blockly_store = new g(this)),
              (this.data_collection_store = new j(this, this.core));
          }
        }
        var tf = i(94120);
        let tb = (0, r.createContext)(null),
          tw = (e) => {
            let { children: t, mockStore: i } = e,
              [o, a] = (0, r.useState)(null),
              n = (0, r.useRef)(!1);
            return ((0, r.useEffect)(() => {
              let e = async () => {
                a(new tv(tf.Z));
              };
              o || n.current || ((n.current = !0), i ? a(i) : e());
            }, [o, i]),
            !o && i)
              ? null
              : (0, s.jsx)(tb.Provider, { value: o, children: t });
          },
          tk = () => (0, r.useContext)(tb);
      },
      3937: function (e, t, i) {
        "use strict";
        var o = i(85893),
          s = i(20745),
          r = i(67294),
          a = i(97613),
          n = i(87383),
          l = i(48059),
          c = i(12838),
          d = i(21995),
          u = i(79655),
          h = i(89250),
          p = i(96877),
          _ = i(83274),
          m = i(10434);
        let g = (0, p.Pi)(() => {
          let { ui: e } = (0, _.oR)() ?? { ui: { show_prompt: !1 } },
            { show_prompt: t } = e,
            i = (0, h._Z)((e) => {
              let { currentLocation: i, nextLocation: o } = e;
              return t && i.pathname !== o.pathname;
            });
          return (
            r.useEffect(() => {
              let e = (e) => {
                t ? e.preventDefault() : delete e.returnValue;
              };
              return (
                window.addEventListener("beforeunload", e),
                () => {
                  window.removeEventListener("beforeunload", e);
                }
              );
            }, [t]),
            (0, o.jsx)(m.Z, {
              title: (0, l.NC)("Leaving already?"),
              confirm_button_text: (0, l.NC)("Yes, I'll come back later"),
              cancel_button_text: (0, l.NC)("No, I'll stay"),
              onConfirm: () => {
                var e;
                null == i ||
                  null === (e = i.proceed) ||
                  void 0 === e ||
                  e.call(i);
              },
              onCancel: () => {
                var e;
                null == i ||
                  null === (e = i.reset) ||
                  void 0 === e ||
                  e.call(i);
              },
              is_visible: "blocked" === i.state,
              has_close_icon: !1,
              children: (0, o.jsx)(l.Xx, {
                i18n_default_text:
                  "If you leave, your current contract will be completed, but your bot will stop running immediately.",
              }),
            })
          );
        });
        var y = i(37979),
          v = i(11527),
          f = i(29747),
          b = i(66175),
          w = i(83606),
          k = i(98831),
          C = i(92198),
          T = i(419);
        let N = () => ({
          empty_address: () => (0, l.NC)("This field is required"),
          empty_barrier: () => (0, l.NC)("Barrier is a required field."),
          address: () =>
            (0, l.NC)(
              "Use only the following special characters: {{permitted_characters}}",
              { permitted_characters: T.JL, interpolation: { escapeValue: !1 } }
            ),
          barrier: () =>
            (0, l.NC)(
              "Only numbers and these special characters are allowed: {{permitted_characters}}",
              { permitted_characters: "+ - ." }
            ),
          email: () => (0, l.NC)("Invalid email address."),
          general: () =>
            (0, l.NC)(
              "Only letters, numbers, space, hyphen, period, and apostrophe are allowed."
            ),
          name: () =>
            (0, l.NC)("Letters, spaces, periods, hyphens, apostrophes only."),
          password: () =>
            (0, l.NC)(
              "Password should have lower and uppercase English letters with numbers."
            ),
          po_box: () => (0, l.NC)("P.O. Box is not accepted in address"),
          phone: () =>
            (0, l.NC)("Please enter a valid phone number (e.g. +15417541234)."),
          postcode: () =>
            (0, l.NC)("Only letters, numbers, space and hyphen are allowed."),
          signup_token: () => (0, l.NC)("The length of token should be 8."),
          tax_id: () =>
            (0, l.NC)(
              "Should start with letter or number, and may contain hyphen and underscore."
            ),
          number: () => (0, l.NC)("Should be a valid number."),
          decimalPlaces: (e) =>
            (0, l.NC)("Up to {{decimal_count}} decimal places are allowed.", {
              decimal_count: e,
            }),
          value: (e) => (0, l.NC)("Should be {{value}}", { value: e }),
          betweenMinMax: (e, t) =>
            (0, l.NC)("Should be between {{min_value}} and {{max_value}}", {
              min_value: e,
              max_value: t,
            }),
          minNumber: (e) =>
            (0, l.NC)("Should be more than {{min_value}}", { min_value: e }),
          maxNumber: (e) =>
            (0, l.NC)("Should be less than {{max_value}}", { max_value: e }),
          password_warnings: {
            use_a_few_words: () =>
              (0, l.NC)("Use a few words, avoid common phrases"),
            no_need_for_mixed_chars: () =>
              (0, l.NC)("No need for symbols, digits, or uppercase letters"),
            uncommon_words_are_better: () =>
              (0, l.NC)("Add another word or two. Uncommon words are better."),
            straight_rows_of_keys_are_easy: () =>
              (0, l.NC)("Straight rows of keys are easy to guess"),
            short_keyboard_patterns_are_easy: () =>
              (0, l.NC)("Short keyboard patterns are easy to guess"),
            use_longer_keyboard_patterns: () =>
              (0, l.NC)("Use a longer keyboard pattern with more turns"),
            repeated_chars_are_easy: () =>
              (0, l.NC)('Repeats like "aaa" are easy to guess'),
            repeated_patterns_are_easy: () =>
              (0, l.NC)(
                'Repeats like "abcabcabc" are only slightly harder to guess than "abc"'
              ),
            avoid_repeated_chars: () =>
              (0, l.NC)("Avoid repeated words and characters"),
            sequences_are_easy: () =>
              (0, l.NC)("Sequences like abc or 6543 are easy to guess"),
            avoid_sequences: () => (0, l.NC)("Avoid sequences"),
            recent_years_are_easy: () =>
              (0, l.NC)("Recent years are easy to guess"),
            avoid_recent_years: () => (0, l.NC)("Avoid recent years"),
            avoid_associated_years: () =>
              (0, l.NC)("Avoid years that are associated with you"),
            dates_are_easy: () => (0, l.NC)("Dates are often easy to guess"),
            avoid_associated_dates_and_years: () =>
              (0, l.NC)("Avoid dates and years that are associated with you"),
            top10_common_password: () =>
              (0, l.NC)("This is a top-10 common password"),
            top100_common_password: () =>
              (0, l.NC)("This is a top-100 common password"),
            very_common_password: () =>
              (0, l.NC)("This is a very common password"),
            similar_to_common_password: () =>
              (0, l.NC)("This is similar to a commonly used password"),
            a_word_is_easy: () =>
              (0, l.NC)("A word by itself is easy to guess"),
            names_are_easy: () =>
              (0, l.NC)("Names and surnames by themselves are easy to guess"),
            common_names_are_easy: () =>
              (0, l.NC)("Common names and surnames are easy to guess"),
            capitalization_doesnt_help: () =>
              (0, l.NC)("Capitalization doesn't help very much"),
            all_uppercase_doesnt_help: () =>
              (0, l.NC)(
                "All-uppercase is almost as easy to guess as all-lowercase"
              ),
            reverse_doesnt_help: () =>
              (0, l.NC)("Reversed words aren't much harder to guess"),
            substitution_doesnt_help: () =>
              (0, l.NC)(
                "Predictable substitutions like '@' instead of 'a' don't help very much"
              ),
            user_dictionary: () =>
              (0, l.NC)("This password is on the blacklist"),
          },
        });
        var S = i(40968),
          x = i(88199),
          E = i(30453),
          D = i(79649);
        let O = (0, p.Pi)((e) => {
          let { children: t } = e,
            {
              isAuthorizing: i,
              isAuthorized: s,
              connectionStatus: a,
              accountList: n,
              activeLoginid: c,
            } = (0, D.T)(),
            d = (0, r.useRef)(!1),
            u = (0, r.useRef)(!1),
            h = (0, r.useRef)(null),
            p = (0, r.useRef)(null),
            { client: m, common: g } = (0, _.oR)() ?? {},
            { currentLang: y } = (0, l.T_)(),
            { oAuthLogout: v, isOAuth2Enabled: f } = (0, E.q)({
              handleLogout: async () => m.logout(),
              client: m,
            }),
            w = "false" === C.Z.get("logged_state");
          (0, r.useEffect)(() => {
            w && f && (null == m ? void 0 : m.is_logged_in) && v();
          }, [w, v, f, null == m ? void 0 : m.is_logged_in]);
          let k = (0, r.useMemo)(
            () => (null == n ? void 0 : n.find((e) => e.loginid === c)),
            [c, n]
          );
          (0, r.useEffect)(() => {
            var e, t;
            let i =
              null == m
                ? void 0
                : null === (t = m.all_accounts_balance) || void 0 === t
                ? void 0
                : null === (e = t.accounts) || void 0 === e
                ? void 0
                : e[(null == k ? void 0 : k.loginid) ?? ""];
            i &&
              (null == m ||
                m.setBalance(i.balance.toFixed((0, b.i4S)(i.currency))),
              null == m || m.setCurrency(i.currency));
          }, [
            null == k ? void 0 : k.loginid,
            null == m ? void 0 : m.all_accounts_balance,
          ]),
            (0, r.useEffect)(() => {
              m &&
                k &&
                (null == m || m.setLoginId(c),
                null == m || m.setAccountList(n),
                null == m || m.setIsLoggedIn(!0));
            }, [n, k, c, m]),
            (0, r.useEffect)(
              () => (
                (0, S.bf)(N()),
                () => {
                  h.current && clearInterval(h.current);
                }
              ),
              []
            ),
            (0, r.useEffect)(() => {
              g && y && g.setCurrentLanguage(y);
            }, [y, g]),
            (0, r.useEffect)(() => {
              if (m && !i && !d.current) {
                var e;
                (d.current = !0),
                  null === (e = x.api_base.api) ||
                    void 0 === e ||
                    e.websiteStatus().then((e) => {
                      m.setWebsiteStatus(e.website_status);
                    }),
                  (h.current = setInterval(() => {
                    var e;
                    null === (e = x.api_base.api) ||
                      void 0 === e ||
                      e
                        .time()
                        .then((e) => {
                          g.setServerTime((0, b.gbT)(e.time), !1);
                        })
                        .catch(() => {
                          g.setServerTime((0, b.gbT)(Date.now()), !0);
                        });
                  }, 1e4));
              }
            }, [m, g, i]);
          let T = (0, r.useCallback)(
            async (e) => {
              if (!e) return;
              let t = e.data,
                { msg_type: i, error: o } = t;
              if (
                (((null == o ? void 0 : o.code) === "AuthorizationRequired" ||
                  (null == o ? void 0 : o.code) === "DisabledClient" ||
                  (null == o ? void 0 : o.code) === "InvalidToken") &&
                  (await v()),
                "balance" === i && t && !o)
              ) {
                let e = t.balance;
                if (null == e ? void 0 : e.accounts) m.setAllAccountsBalance(e);
                else if (null == e ? void 0 : e.loginid) {
                  var s;
                  if (
                    !(null == m
                      ? void 0
                      : null === (s = m.all_accounts_balance) || void 0 === s
                      ? void 0
                      : s.accounts) ||
                    !(null == e ? void 0 : e.loginid)
                  )
                    return;
                  let t = {
                    ...{ ...m.all_accounts_balance.accounts }[e.loginid],
                  };
                  t.balance = e.balance;
                  let i = {
                    ...m.all_accounts_balance,
                    accounts: {
                      ...m.all_accounts_balance.accounts,
                      [e.loginid]: t,
                    },
                  };
                  m.setAllAccountsBalance(i);
                }
              }
            },
            [m, v]
          );
          return (
            (0, r.useEffect)(() => {
              if (!i && m) {
                var e;
                let t =
                  null === x.api_base || void 0 === x.api_base
                    ? void 0
                    : null === (e = x.api_base.api) || void 0 === e
                    ? void 0
                    : e.onMessage().subscribe(T);
                p.current = { unsubscribe: null == t ? void 0 : t.unsubscribe };
              }
              return () => {
                if (p.current) {
                  var e, t;
                  null === (e = (t = p.current).unsubscribe) ||
                    void 0 === e ||
                    e.call(t);
                }
              };
            }, [a, T, i, s, m]),
            (0, r.useEffect)(() => {
              !i &&
                s &&
                !u.current &&
                m &&
                ((u.current = !0),
                x.api_base.api.getSettings().then((e) => {
                  var t;
                  null == m || m.setAccountSettings(e.get_settings),
                    x.api_base.api
                      .landingCompany({
                        landing_company:
                          null === (t = e.get_settings) || void 0 === t
                            ? void 0
                            : t.country_code,
                      })
                      .then((e) => {
                        null == m || m.setLandingCompany(e.landing_company);
                      });
                }),
                x.api_base.api.getAccountStatus().then((e) => {
                  null == m || m.setAccountStatus(e.get_account_status);
                }));
            }, [i, s, m]),
            (0, o.jsx)(o.Fragment, { children: t })
          );
        });
        i(674);
        let A = (0, r.lazy)(() =>
            Promise.all([i.e("834"), i.e("863"), i.e("572")]).then(
              i.bind(i, 1607)
            )
          ),
          I = (0, r.lazy)(() =>
            Promise.all([i.e("892"), i.e("232")]).then(i.bind(i, 15207))
          ),
          {
            TRANSLATIONS_CDN_URL: L,
            R2_PROJECT_NAME: R,
            CROWDIN_BRANCH_NAME: B,
          } = {
            TRANSLATIONS_CDN_URL: void 0,
            R2_PROJECT_NAME: void 0,
            CROWDIN_BRANCH_NAME: void 0,
          },
          P = (0, l.uC)({ cdnUrl: `${L}/${R}/${B}` }),
          j = (0, u.aj)(
            (0, h.i7)(
              (0, o.jsxs)(h.AW, {
                path: "/",
                element: (0, o.jsx)(r.Suspense, {
                  fallback: (0, o.jsx)(a.Z, {
                    message: (0, l.NC)(
                      "Please wait while we connect to the server..."
                    ),
                  }),
                  children: (0, o.jsx)(l.$j, {
                    defaultLang: "EN",
                    i18nInstance: P,
                    children: (0, o.jsxs)(_.g3, {
                      children: [
                        (0, o.jsx)(g, {}),
                        (0, o.jsx)(O, { children: (0, o.jsx)(A, {}) }),
                      ],
                    }),
                  }),
                }),
                children: [
                  (0, o.jsx)(h.AW, { index: !0, element: (0, o.jsx)(I, {}) }),
                  (0, o.jsx)(h.AW, {
                    path: "endpoint",
                    element: (0, o.jsx)(() => {
                      let e = (0, f.TA)({
                        initialValues: {
                          appId:
                            localStorage.getItem(c.sE.configAppId) ??
                            (0, b.rhL)(),
                          serverUrl:
                            localStorage.getItem(c.sE.configServerURL) ??
                            (0, b.wmM)(),
                        },
                        onSubmit: (t) => {
                          localStorage.setItem(
                            c.sE.configServerURL,
                            t.serverUrl
                          ),
                            localStorage.setItem(
                              c.sE.configAppId,
                              t.appId.toString()
                            ),
                            e.resetForm({ values: t });
                        },
                        validate: (e) => {
                          let t = {};
                          return (
                            e.serverUrl ||
                              (t.serverUrl = "This field is required"),
                            e.appId
                              ? /^(0|[1-9]\d*)(\.\d+)?$/.test(
                                  e.appId.toString()
                                ) || (t.appId = "Please enter a valid app ID")
                              : (t.appId = "This field is required"),
                            t
                          );
                        },
                      });
                      return (0, o.jsxs)("div", {
                        className: "endpoint",
                        children: [
                          (0, o.jsx)(w.x, {
                            weight: "bold",
                            className: "endpoint__title",
                            children: "Change API endpoint",
                          }),
                          (0, o.jsxs)("form", {
                            onSubmit: e.handleSubmit,
                            className: "endpoint__form",
                            children: [
                              (0, o.jsx)(k.I, {
                                "data-testid": "dt_endpoint_server_url_input",
                                label: "Server",
                                name: "serverUrl",
                                message: e.errors.serverUrl,
                                onBlur: e.handleBlur,
                                onChange: e.handleChange,
                                value: e.values.serverUrl,
                              }),
                              (0, o.jsx)(k.I, {
                                "data-testid": "dt_endpoint_app_id_input",
                                label: "OAuth App ID",
                                name: "appId",
                                message: e.errors.appId,
                                onBlur: e.handleBlur,
                                onChange: e.handleChange,
                                value: e.values.appId,
                              }),
                              (0, o.jsxs)("div", {
                                children: [
                                  (0, o.jsx)(v.z, {
                                    className: "endpoint__button",
                                    disabled: !e.dirty || !e.isValid,
                                    type: "submit",
                                    children: "Submit",
                                  }),
                                  (0, o.jsx)(v.z, {
                                    className: "endpoint__button",
                                    color: "black",
                                    onClick: () => {
                                      let { server_url: t, app_id: i } = (0,
                                      b.e_e)();
                                      localStorage.setItem(
                                        c.sE.configServerURL,
                                        t
                                      ),
                                        localStorage.setItem(
                                          c.sE.configAppId,
                                          i.toString()
                                        ),
                                        e.resetForm({
                                          values: { appId: i, serverUrl: t },
                                        }),
                                        window.location.reload();
                                    },
                                    variant: "outlined",
                                    type: "button",
                                    children: "Reset to original settings",
                                  }),
                                ],
                              }),
                            ],
                          }),
                        ],
                      });
                    }, {}),
                  }),
                  (0, o.jsx)(h.AW, {
                    path: "callback",
                    element: (0, o.jsx)(
                      () =>
                        (0, o.jsx)(y.AQ, {
                          onSignInSuccess: async (e) => {
                            let t = {},
                              i = {};
                            for (let [o, s] of Object.entries(e))
                              if (o.startsWith("acct")) {
                                let r = o.replace("acct", "token");
                                e[r] &&
                                  ((t[s] = e[r]),
                                  (i[s] = {
                                    loginid: s,
                                    token: e[r],
                                    currency: "",
                                  }));
                              } else if (o.startsWith("cur")) {
                                let t = o.replace("cur", "acct");
                                e[t] && (i[e[t]].currency = s);
                              }
                            localStorage.setItem(
                              "accountsList",
                              JSON.stringify(t)
                            ),
                              localStorage.setItem(
                                "clientAccounts",
                                JSON.stringify(i)
                              );
                            let o = !1,
                              s = await (0, n.wL)();
                            if (s) {
                              let { authorize: t, error: a } =
                                await s.authorize(e.token1);
                              if (
                                (localStorage.setItem(
                                  "callback_token",
                                  t.toString()
                                ),
                                s.disconnect(),
                                !a)
                              ) {
                                var r;
                                let e = Object.values(i),
                                  s =
                                    null == t
                                      ? void 0
                                      : null === (r = t.account_list[0]) ||
                                        void 0 === r
                                      ? void 0
                                      : r.loginid,
                                  a = e.filter((e) => e.loginid === s);
                                a.length &&
                                  (localStorage.setItem(
                                    "authToken",
                                    a[0].token
                                  ),
                                  localStorage.setItem(
                                    "active_loginid",
                                    a[0].loginid
                                  ),
                                  (o = !0));
                              }
                            }
                            o ||
                              (localStorage.setItem("authToken", e.token1),
                              localStorage.setItem("active_loginid", e.acct1));
                            let a = sessionStorage.getItem(
                              "query_param_currency"
                            );
                            window.location.assign(a ? `/?account=${a}` : "/");
                          },
                          renderReturnButton: () =>
                            (0, o.jsx)(v.z, {
                              className: "callback-return-button",
                              onClick: () => {
                                window.location.href = "/";
                              },
                              children: "Return to Bot",
                            }),
                        }),
                      {}
                    ),
                  }),
                ],
              })
            )
          ),
          U = function () {
            return (
              r.useEffect(() => {
                var e, t;
                return (
                  (0, d.UR)(),
                  null === (t = window) ||
                    void 0 === t ||
                    null === (e = t.dataLayer) ||
                    void 0 === e ||
                    e.push({ event: "page_load" }),
                  () => {
                    let e = document.getElementById("survicate-box");
                    e && (e.style.display = "none");
                  }
                );
              }, []),
              r.useEffect(() => {
                let e = localStorage.getItem("accountsList"),
                  t = localStorage.getItem("clientAccounts"),
                  i = localStorage.getItem("active_loginid"),
                  o = new URLSearchParams(window.location.search).get(
                    "account"
                  );
                if (!o)
                  try {
                    if (!t) return;
                    let e = JSON.parse(t),
                      o = Object.entries(e).find((e) => {
                        let [t, o] = e;
                        return o.loginid === i;
                      });
                    if (!o) return;
                    let [s, r] = o;
                  } catch (e) {
                    console.warn("Error", e);
                  }
                if (e && t)
                  try {
                    let s = JSON.parse(e),
                      r = JSON.parse(t),
                      a =
                        !!o &&
                        Object.values(r).some(
                          (e) => e.currency.toUpperCase() === o.toUpperCase()
                        ),
                      n = (e, t) => {
                        localStorage.setItem("authToken", e),
                          localStorage.setItem("active_loginid", t);
                      };
                    if ((null == o ? void 0 : o.toUpperCase()) === "DEMO") {
                      let e = Object.entries(s).find((e) => {
                        let [t] = e;
                        return t.startsWith("VR");
                      });
                      if (e) {
                        let [t, i] = e;
                        n(String(i), t);
                        return;
                      }
                    }
                    if (
                      (null == o ? void 0 : o.toUpperCase()) !== "DEMO" &&
                      a
                    ) {
                      let e = Object.entries(r).find((e) => {
                        let [t, i] = e;
                        return (
                          !t.startsWith("VR") &&
                          i.currency.toUpperCase() ===
                            (null == o ? void 0 : o.toUpperCase())
                        );
                      });
                      if (e) {
                        let [t, i] = e;
                        "token" in i &&
                          n(String(null == i ? void 0 : i.token), t);
                        return;
                      }
                    }
                    if (!a) {
                      let e = Object.entries(r).find((e) => {
                        let [t, o] = e;
                        return o.loginid === i;
                      });
                      if (!e) return;
                      let [t, o] = e;
                    }
                  } catch (e) {
                    console.warn("Error", e);
                  }
              }, []),
              (0, o.jsx)(u.pG, { router: j })
            );
          },
          M = async (e, t) => {
            if (e.length)
              try {
                if (!c.fr.getDefaultActiveAccount(e)) return;
                let o = {},
                  s = {};
                e.forEach((e) => {
                  (o[e.loginid] = e.token), (s[e.loginid] = e);
                }),
                  localStorage.setItem("accountsList", JSON.stringify(o)),
                  localStorage.setItem("clientAccounts", JSON.stringify(s)),
                  c.fr.filterSearchParams(t);
                let r = await (0, n.wL)();
                if (r) {
                  let { authorize: t, error: o } = await r.authorize(
                    e[0].token
                  );
                  if ((r.disconnect(), !o)) {
                    var i;
                    let o =
                        null == t
                          ? void 0
                          : null === (i = t.account_list[0]) || void 0 === i
                          ? void 0
                          : i.loginid,
                      s = e.filter((e) => e.loginid === o);
                    if (s.length) {
                      localStorage.setItem("authToken", s[0].token),
                        localStorage.setItem("active_loginid", s[0].loginid);
                      return;
                    }
                  }
                }
                localStorage.setItem("authToken", e[0].token),
                  localStorage.setItem("active_loginid", e[0].loginid);
              } catch (e) {
                console.error("Error setting up login info:", e);
              }
          };
        i(83571),
          (async () => {
            var e, t;
            null === b.j73 ||
              void 0 === b.j73 ||
              null === (t = b.j73.get("active_loginid")) ||
              void 0 === t ||
              null === (e = t.match(/[a-zA-Z]+/g)) ||
              void 0 === e ||
              e.join("");
          })(),
          s.createRoot(document.getElementById("root")).render(
            (0, o.jsx)(() => {
              let [e, t] = r.useState(!1),
                { loginInfo: i, paramsToDelete: s } =
                  c.fr.getLoginInfoFromURL();
              return (r.useEffect(() => {
                (async () => {
                  await M(i, s), c.fr.filterSearchParams(["lang"]), t(!0);
                })();
              }, [i, s]),
              e)
                ? (0, o.jsx)(U, {})
                : (0, o.jsx)(a.Z, { message: (0, l.NC)("Initializing...") });
            }, {})
          );
      },
      85414: function (e, t, i) {
        "use strict";
        i.d(t, { j: () => H });
        var o = i(88199),
          s = i(48059),
          r = i(68853),
          a = i(85893);
        i(67294);
        let n = (e) => {
            let { max_payout: t, max_ticks: i } = e ?? {
              max_payout: 0,
              max_ticks: 0,
            };
            return (0, a.jsxs)("div", {
              className: "sell_conditions",
              children: [
                (0, a.jsxs)("div", {
                  className: "sell_conditions__take_profit",
                  children: [
                    (0, a.jsx)("span", {
                      children: (0, a.jsx)("strong", {
                        children: (0, s.NC)("Take Profit: "),
                      }),
                    }),
                    (0, a.jsx)("span", {
                      children: (0, s.NC)(
                        "The position closes once its profit exceeds the take-profit amount"
                      ),
                    }),
                  ],
                }),
                (0, a.jsxs)("div", {
                  className: "sell_conditions__tick_count",
                  children: [
                    (0, a.jsx)("span", {
                      children: (0, a.jsx)("strong", {
                        children: (0, s.NC)("Tick Count: "),
                      }),
                    }),
                    (0, a.jsx)("span", {
                      children: (0, s.NC)(
                        "The holding period measured in ticks before the position is sold"
                      ),
                    }),
                  ],
                }),
                (0, a.jsx)("div", {
                  children: (0, a.jsx)(s.Xx, {
                    i18n_default_text:
                      "The position closes when the input condition is met or upon reaching the maximum payout of {{ max_payout }} or maximum tick of {{ max_ticks }}, whichever occurs first.",
                    values: { max_payout: t, max_ticks: i },
                  }),
                }),
              ],
            });
          },
          l = () => ({
            type: "label",
            label: (0, s.NC)("Sell conditions"),
            description: n,
          }),
          c = () => ({
            type: "label",
            label: (0, s.NC)("Size"),
            description: (0, s.NC)(
              "The size used to multiply the stake after a successful trade for the next trade."
            ),
          }),
          d = () => ({ type: "sell_conditions", name: "sell_conditions" }),
          u = () => ({
            type: "label",
            label: (0, s.NC)("Growth rate"),
            description: (0, s.NC)(
              "Your stake will grow at the specified growth rate per tick as long as the current spot price remains within the range of the previous spot price."
            ),
          }),
          h = () => ({
            type: "growth_rate",
            name: "growth_rate",
            attached: !0,
            validation: ["number", "required", "ceil"],
          }),
          p = () => ({
            type: "label",
            label: (0, s.NC)("Unit"),
            description: (0, s.NC)(
              "The unit used to multiply the stake after a losing trade for the next trade."
            ),
          }),
          _ = () => ({
            type: "number",
            name: "take_profit",
            should_have: [{ key: "boolean_tick_count", value: !1 }],
            hide_without_should_have: !0,
            attached: !0,
            has_currency_unit: !0,
          }),
          m = () => ({
            type: "number",
            name: "tick_count",
            should_have: [{ key: "boolean_tick_count", value: !0 }],
            hide_without_should_have: !0,
            attached: !0,
            has_currency_unit: !1,
          }),
          g = () => ({
            type: "min",
            value: 1,
            getMessage: (e) =>
              (0, s.NC)("Must be a number higher than {{ min }}", {
                min: Number(e) - 1,
              }),
          }),
          y = () => ({
            type: "label",
            label: (0, s.NC)("Asset"),
            description: (0, s.NC)(
              "The underlying market your bot will trade with this strategy."
            ),
          }),
          v = () => ({ type: "symbol", name: "symbol" }),
          f = () => ({
            type: "label",
            label: (0, s.NC)("Contract type"),
            description: (0, s.NC)(
              "Your bot will use this contract type for every run"
            ),
          }),
          b = () => ({
            type: "tradetype",
            name: "tradetype",
            dependencies: ["symbol"],
          }),
          w = () => ({
            type: "label",
            label: (0, s.NC)("Purchase condition"),
            description: (0, s.NC)(
              "Your bot uses a single trade type for each run."
            ),
          }),
          k = () => ({
            type: "contract_type",
            name: "type",
            dependencies: ["symbol", "tradetype"],
          }),
          C = () => ({
            type: "label",
            label: (0, s.NC)("Initial stake"),
            description: (0, s.NC)(
              "The amount that you stake for the first trade. Note that this is the minimum stake amount."
            ),
          }),
          T = () => ({
            type: "number",
            name: "stake",
            validation: ["number", "required", "ceil", g()],
            has_currency_unit: !0,
          }),
          N = () => ({
            type: "label",
            label: (0, s.NC)("Duration"),
            description: (0, s.NC)("How long each trade takes to expire."),
          }),
          S = () => ({
            type: "durationtype",
            name: "durationtype",
            dependencies: ["symbol", "tradetype"],
            attached: !0,
          }),
          x = () => ({
            type: "number",
            name: "duration",
            attached: !0,
            validation: ["number", "required", "min", "max"],
          }),
          E = () => ({
            type: "label",
            label: (0, s.NC)("Profit threshold"),
            description: (0, s.NC)(
              "The bot will stop trading if your total profit exceeds this amount."
            ),
          }),
          D = () => ({
            type: "number",
            name: "profit",
            validation: ["number", "required", "ceil", g()],
            has_currency_unit: !0,
          }),
          O = () => ({
            type: "label",
            label: (0, s.NC)("Loss threshold"),
            description: (0, s.NC)(
              "The bot will stop trading if your total loss exceeds this amount."
            ),
          }),
          A = () => ({
            type: "number",
            name: "loss",
            validation: ["number", "required", "ceil", g()],
            has_currency_unit: !0,
          }),
          I = () => ({
            type: "label",
            label: (0, s.NC)("Size"),
            description: (0, s.NC)(
              "The size used to multiply the stake after a losing trade for the next trade."
            ),
          }),
          L = () => ({
            type: "label",
            label: (0, s.NC)("Size"),
            description: (0, s.NC)(
              "The size used to multiply the stake after a successful trade for the next trade."
            ),
          }),
          R = () => ({
            type: "number",
            name: "size",
            validation: [
              "number",
              "required",
              "floor",
              {
                type: "min",
                value: String((0, o.config)().QUICK_STRATEGY.DEFAULT.size),
                getMessage: (e) =>
                  (0, s.NC)(
                    "The value must be equal or greater than {{ min }}",
                    { min: e }
                  ),
              },
            ],
          }),
          B = () => ({
            type: "label",
            label: (0, s.NC)("Unit"),
            description: (0, s.NC)(
              "Number of unit(s) to be added to the next trade after a losing trade. One unit is equivalent to the amount of initial stake."
            ),
          }),
          P = () => ({
            type: "label",
            label: (0, s.NC)("Unit"),
            description: (0, s.NC)(
              "Number of unit(s) to be added to the next trade after a successful trade. One unit is equivalent to the amount of initial stake."
            ),
          }),
          j = () => ({
            type: "number",
            name: "unit",
            validation: ["number", "required", "ceil", g()],
          }),
          U = () => ({
            type: "checkbox",
            name: "boolean_max_stake",
            label: (0, s.NC)("Max stake"),
            description: (0, s.NC)(
              "The stake for your next trade will reset to the initial stake if it exceeds this value."
            ),
            attached: !0,
          }),
          M = () => ({
            type: "number",
            name: "max_stake",
            validation: ["number", "required", "ceil", "min"],
            should_have: [{ key: "boolean_max_stake", value: !0 }],
            hide_without_should_have: !0,
            attached: !0,
            has_currency_unit: !0,
          }),
          F = () => ({
            type: "label",
            name: "label_last_digit_prediction",
            label: (0, s.NC)("Last Digit Prediction"),
            description: (0, s.NC)(
              "Your prediction of the last digit of the asset price."
            ),
            should_have: [
              {
                key: "tradetype",
                value: "",
                multiple: ["matchesdiffers", "overunder"],
              },
            ],
            hide_without_should_have: !0,
          }),
          G = () => ({
            type: "number",
            name: "last_digit_prediction",
            validation: ["number", "required", "min", "max", "integer"],
            should_have: [
              {
                key: "tradetype",
                value: "",
                multiple: ["matchesdiffers", "overunder"],
              },
            ],
            hide_without_should_have: !0,
          }),
          H = () => ({
            MARTINGALE: {
              name: "martingale_max-stake",
              label: (0, s.NC)("Martingale"),
              rs_strategy_name: "martingale",
              description: (0, r.MARTINGALE)(),
              fields: [
                [
                  y(),
                  v(),
                  f(),
                  b(),
                  w(),
                  k(),
                  F(),
                  G(),
                  C(),
                  T(),
                  N(),
                  S(),
                  x(),
                ],
                [E(), D(), O(), A(), I(), R(), U(), M()],
              ],
            },
            D_ALEMBERT: {
              name: "dalembert_max-stake",
              label: (0, s.NC)("D’Alembert"),
              rs_strategy_name: "d'alembert",
              description: (0, r.D_ALEMBERT)(),
              fields: [
                [
                  y(),
                  v(),
                  f(),
                  b(),
                  w(),
                  k(),
                  F(),
                  G(),
                  C(),
                  T(),
                  N(),
                  S(),
                  x(),
                ],
                [E(), D(), O(), A(), B(), j(), U(), M()],
              ],
            },
            OSCARS_GRIND: {
              name: "oscars_grind_max-stake",
              label: (0, s.NC)("Oscar’s Grind"),
              rs_strategy_name: "oscar's-grind",
              description: (0, r.OSCARS_GRIND)(),
              fields: [
                [
                  y(),
                  v(),
                  f(),
                  b(),
                  w(),
                  k(),
                  F(),
                  G(),
                  C(),
                  T(),
                  N(),
                  S(),
                  x(),
                ],
                [E(), D(), O(), A(), U(), M()],
              ],
            },
            REVERSE_MARTINGALE: {
              name: "reverse_martingale",
              label: (0, s.NC)("Reverse Martingale"),
              rs_strategy_name: "reverse martingale",
              description: (0, r.REVERSE_MARTINGALE)(),
              fields: [
                [
                  y(),
                  v(),
                  f(),
                  b(),
                  w(),
                  k(),
                  F(),
                  G(),
                  C(),
                  T(),
                  N(),
                  S(),
                  x(),
                ],
                [E(), D(), O(), A(), L(), R(), U(), M()],
              ],
            },
            REVERSE_D_ALEMBERT: {
              name: "reverse_dalembert",
              label: (0, s.NC)("Reverse D’Alembert"),
              rs_strategy_name: "reverse d'alembert",
              description: (0, r.REVERSE_D_ALEMBERT)(),
              fields: [
                [
                  y(),
                  v(),
                  f(),
                  b(),
                  w(),
                  k(),
                  F(),
                  G(),
                  C(),
                  T(),
                  N(),
                  S(),
                  x(),
                ],
                [E(), D(), O(), A(), P(), j(), U(), M()],
              ],
            },
            STRATEGY_1_3_2_6: {
              name: "1_3_2_6",
              label: (0, s.NC)("1-3-2-6"),
              rs_strategy_name: "1-3-2-6",
              description: (0, r.STRATEGY_1_3_2_6)(),
              fields: [
                [
                  y(),
                  v(),
                  f(),
                  b(),
                  w(),
                  k(),
                  F(),
                  G(),
                  C(),
                  T(),
                  N(),
                  S(),
                  x(),
                ],
                [E(), D(), O(), A()],
              ],
            },
            ACCUMULATORS_MARTINGALE: {
              name: "accumulators_martingale",
              label: (0, s.NC)("Martingale"),
              rs_strategy_name: "accumulators_martingale",
              description: [],
              fields: [
                [y(), v(), C(), T(), u(), h()],
                [E(), D(), O(), A(), c(), R(), l(), d(), _(), m(), U(), M()],
              ],
            },
            ACCUMULATORS_DALEMBERT: {
              name: "accumulators_dalembert",
              label: (0, s.NC)("D’Alembert"),
              rs_strategy_name: "accumulators_dalembert",
              description: [],
              fields: [
                [y(), v(), C(), T(), u(), h()],
                [E(), D(), O(), A(), p(), j(), l(), d(), _(), m(), U(), M()],
              ],
            },
            ACCUMULATORS_MARTINGALE_ON_STAT_RESET: {
              name: "accumulators_martingale_on_stat_reset",
              label: (0, s.NC)("Martingale on Stat Reset"),
              rs_strategy_name: "accumulators_martingale_on_stat_reset",
              description: [],
              fields: [
                [y(), v(), C(), T(), u(), h()],
                [E(), D(), O(), A(), c(), R(), l(), d(), _(), m(), U(), M()],
              ],
            },
            ACCUMULATORS_DALEMBERT_ON_STAT_RESET: {
              name: "accumulators_dalembert_on_stat_reset",
              label: (0, s.NC)("D'Alembert on Stat Reset"),
              rs_strategy_name: "accumulators_dalembert_on_stat_reset",
              description: [],
              fields: [
                [y(), v(), C(), T(), u(), h()],
                [E(), D(), O(), A(), p(), j(), l(), d(), _(), m(), U(), M()],
              ],
            },
            ACCUMULATORS_REVERSE_MARTINGALE: {
              name: "accumulators_reverse_martingale",
              label: (0, s.NC)("Reverse Martingale"),
              rs_strategy_name: "accumulators_reverse_martingale",
              description: [],
              fields: [
                [y(), v(), C(), T(), u(), h()],
                [E(), D(), O(), A(), c(), R(), l(), d(), _(), m(), U(), M()],
              ],
            },
            ACCUMULATORS_REVERSE_MARTINGALE_ON_STAT_RESET: {
              name: "accumulators_reverse_martingale_on_stat_reset",
              label: (0, s.NC)("Reverse Martingale on Stat Reset"),
              rs_strategy_name: "accumulators_reverse_martingale_on_stat_reset",
              description: [],
              fields: [
                [y(), v(), C(), T(), u(), h()],
                [E(), D(), O(), A(), c(), R(), l(), d(), _(), m(), U(), M()],
              ],
            },
            ACCUMULATORS_REVERSE_DALEMBERT: {
              name: "accumulators_reverse_dalembert",
              label: (0, s.NC)("Reverse D'Alembert"),
              rs_strategy_name: "accumulators_reverse_dalembert",
              description: [],
              fields: [
                [y(), v(), C(), T(), u(), h()],
                [E(), D(), O(), A(), p(), j(), l(), d(), _(), m(), U(), M()],
              ],
            },
            ACCUMULATORS_REVERSE_DALEMBERT_ON_STAT_RESET: {
              name: "accumulators_reverse_dalembert_on_stat_reset",
              label: (0, s.NC)("Reverse D'Alembert on Stat Reset"),
              rs_strategy_name: "accumulators_reverse_dalembert_on_stat_reset",
              description: [],
              fields: [
                [y(), v(), C(), T(), u(), h()],
                [E(), D(), O(), A(), p(), j(), l(), d(), _(), m(), U(), M()],
              ],
            },
          });
      },
      64376: function (e, t, i) {
        "use strict";
        i.d(t, {
          FM: () => a,
          Mq: () => d,
          Qb: () => r,
          Yk: () => u,
          xH: () => l,
          zw: () => c,
        });
        var o = i(21995),
          s = i(48059);
        let r = "user guide",
          a = "videos on deriv bot",
          n = "quick strategy guides",
          l = () => [
            {
              id: 1,
              type: "Tour",
              subtype: "OnBoard",
              content: (0, s.NC)("Get started on Deriv Bot"),
              src: (0, o.oY)("dbot-onboard-tour.png"),
              search_id: `${r}-0`,
            },
            {
              id: 2,
              type: "Tour",
              subtype: "BotBuilder",
              content: (0, s.NC)("Let’s build a bot!"),
              src: (0, o.oY)("bot-builder-tour.png"),
              search_id: `${r}-1`,
            },
          ],
          c = () => [
            {
              id: 1,
              type: "DBotVideo",
              content: (0, s.NC)("An introduction to Deriv Bot"),
              url: "https://www.youtube.com/embed/lthEgaIY1uw",
              src: (0, o.oY)("intro_to_deriv_bot.png"),
              search_id: `${a}-0`,
            },
            {
              id: 2,
              type: "DBotVideo",
              content: (0, s.NC)(
                "How to build a basic trading bot with Deriv Bot"
              ),
              url: "https://www.youtube.com/embed/mnpi2g7YakU",
              src: (0, o.oY)("build_a_bot.png"),
              search_id: `${a}-1`,
            },
            {
              id: 3,
              type: "DBotVideo",
              content: (0, s.NC)("How to use Martingale strategy on Deriv Bot"),
              url: "https://www.youtube.com/embed/FSslvF7P00I",
              src: (0, o.oY)("how_to_use_martingale.jpg"),
              search_id: `${a}-2`,
            },
            {
              id: 4,
              type: "DBotVideo",
              content: (0, s.NC)(
                "Introducing Accumulator Options on Deriv Bot: Available for automated trading"
              ),
              url: "https://www.youtube.com/embed/uMBBmdNaadU",
              src: (0, o.oY)("introducing_accumulators_on_deriv_bot.png"),
              search_id: `${a}-3`,
            },
          ],
          d = () => [
            {
              title: (0, s.NC)("What is Deriv Bot?"),
              description: [
                {
                  type: "text",
                  content: (0, s.NC)(
                    "Deriv Bot is a web-based strategy builder for trading digital options. It’s a platform where you can build your own automated trading bot using drag-and-drop 'blocks'."
                  ),
                },
              ],
              search_id: "faq-0",
            },
            {
              title: (0, s.NC)("Where do I find the blocks I need?"),
              description: [
                { type: "text", content: (0, s.NC)("Follow these steps:") },
                {
                  type: "text",
                  content: (0, s.NC)("1. Go to <strong>Bot Builder</strong>."),
                },
                {
                  type: "text",
                  content: (0, s.NC)(
                    "2. Under the <strong>Blocks menu</strong>, you'll see a list of categories. Blocks are grouped within these categories. Choose the block you want and drag them to the workspace."
                  ),
                },
                { type: "image", src: (0, o.oY)("blocks_menu.png") },
                {
                  type: "text",
                  content: (0, s.NC)(
                    "3. You can also search for the blocks you want using the search bar above the categories."
                  ),
                },
                { type: "image", src: (0, o.oY)("blocks_menu_search.png") },
                {
                  type: "text",
                  content: (0, s.NC)(
                    'For more info, <a href="https://deriv.com/academy/blog/posts/how-to-build-a-basic-trading-bot-with-dbot/" target="_blank">check out this blog post</a> on the basics of building a trading bot.'
                  ),
                },
              ],
              search_id: "faq-1",
            },
            {
              title: (0, s.NC)("How do I remove blocks from the workspace?"),
              description: [
                {
                  type: "text",
                  content: (0, s.NC)(
                    "Click on the block you want to remove and press <strong>Delete</strong> on your keyboard."
                  ),
                },
              ],
              search_id: "faq-2",
            },
            {
              title: (0, s.NC)("How do I create variables?"),
              description: [
                {
                  type: "text",
                  content: (0, s.NC)(
                    "1. Under the <strong>Blocks</strong> menu, go to <strong>Utility > Variables</strong>."
                  ),
                },
                {
                  type: "text",
                  content: (0, s.NC)(
                    "2. Enter a name for your variable, and hit <strong>Create</strong>. New blocks containing your new variable will appear below."
                  ),
                },
                {
                  type: "text",
                  content: (0, s.NC)(
                    "3. Choose the block you want and drag it to the workspace."
                  ),
                },
              ],
              search_id: "faq-3",
            },
            {
              title: (0, s.NC)(
                "Do you offer pre-built trading bots on Deriv Bot?"
              ),
              description: [
                {
                  type: "text",
                  content: (0, s.NC)(
                    "Yes, you can get started with a pre-built bot using the <strong>Quick strategy</strong> feature. You’ll find some of the most popular trading strategies here: Martingale, D'Alembert, and Oscar's Grind. Just select the strategy, enter your trade parameters, and your bot will be created for you. You can always tweak the parameters later."
                  ),
                },
              ],
              search_id: "faq-4",
            },
            {
              title: (0, s.NC)("What is a quick strategy?"),
              description: [
                {
                  type: "text",
                  content: (0, s.NC)(
                    "A quick strategy is a ready-made strategy that you can use in Deriv Bot. There are 3 quick strategies you can choose from: Martingale, D'Alembert, and Oscar's Grind."
                  ),
                },
                {
                  type: "text",
                  content: (0, s.NC)("<strong>Using a quick strategy</strong>"),
                },
                {
                  type: "text",
                  content: (0, s.NC)(
                    "1. Go to <strong>Quick strategy</strong> and select the strategy you want."
                  ),
                },
                {
                  type: "text",
                  content: (0, s.NC)("2. Select the asset and trade type."),
                },
                {
                  type: "text",
                  content: (0, s.NC)(
                    "3. Set your trade parameters and hit <strong>Run</strong>."
                  ),
                },
                {
                  type: "text",
                  content: (0, s.NC)(
                    "4. Once the blocks are loaded onto the workspace, tweak the parameters if you want, or hit <strong>Run</strong> to start trading."
                  ),
                },
                {
                  type: "text",
                  content: (0, s.NC)(
                    "5. Hit <strong>Save</strong> to download your bot. You can choose to download your bot to your device or your Google Drive."
                  ),
                },
              ],
              search_id: "faq-5",
            },
            {
              title: (0, s.NC)("How do I save my strategy?"),
              description: [
                {
                  type: "text",
                  content: (0, s.NC)(
                    "In <strong>Bot Builder</strong>, hit <strong>Save</strong> on the toolbar at the top to download your bot. Give your bot a name, and choose to download your bot to your device or Google Drive. Your bot will be downloaded as an XML file."
                  ),
                },
              ],
              search_id: "faq-6",
            },
            {
              title: (0, s.NC)(
                "How do I import my own trading bot into Deriv Bot?"
              ),
              description: [
                {
                  type: "text",
                  content: (0, s.NC)(
                    "Just drag the XML file from your computer onto the workspace, and your bot will be loaded accordingly. Alternatively, you can hit <strong>Import</strong> in <strong>Bot Builder</strong>, and choose to import your bot from your computer or from your Google Drive."
                  ),
                },
                {
                  type: "text",
                  content: (0, s.NC)(
                    "<strong>Import from your computer</strong>"
                  ),
                },
                {
                  type: "text",
                  content: (0, s.NC)(
                    "1. After hitting <strong>Import</strong>, select <strong>Local</strong> and click <strong>Continue</strong>."
                  ),
                },
                {
                  type: "text",
                  content: (0, s.NC)(
                    "2. Select your XML file and hit <strong>Open</strong>."
                  ),
                },
                {
                  type: "text",
                  content: (0, s.NC)("3. Your bot will be loaded accordingly."),
                },
                {
                  type: "text",
                  content: (0, s.NC)(
                    "<strong>Import from your Google Drive</strong>"
                  ),
                },
                {
                  type: "text",
                  content: (0, s.NC)(
                    "1. After hitting <strong>Import</strong>, select <strong>Google Drive</strong> and click <strong>Continue</strong>."
                  ),
                },
                {
                  type: "text",
                  content: (0, s.NC)(
                    "2. Select your XML file and hit <strong>Select</strong>."
                  ),
                },
                {
                  type: "text",
                  content: (0, s.NC)("3. Your bot will be loaded accordingly."),
                },
              ],
              search_id: "faq-7",
            },
            {
              title: (0, s.NC)("How do I reset the workspace?"),
              description: [
                {
                  type: "text",
                  content: (0, s.NC)(
                    "In <strong>Bot Builder</strong>, hit <strong>Reset</strong> on the toolbar at the top. This will clear the workspace. Please note that any unsaved changes will be lost."
                  ),
                },
              ],
              search_id: "faq-8",
            },
            {
              title: (0, s.NC)("How do I clear my transaction log?"),
              description: [
                {
                  type: "text",
                  content: (0, s.NC)(
                    "1. Hit <strong>Reset</strong> at the bottom of stats panel."
                  ),
                },
                { type: "image", src: (0, o.oY)("reset_transaction_log.png") },
                {
                  type: "text",
                  content: (0, s.NC)("2. Hit <strong>Ok</strong> to confirm."),
                },
                {
                  type: "image",
                  src: (0, o.oY)("reset_transaction_log_message.png"),
                },
              ],
              search_id: "faq-9",
            },
            {
              title: (0, s.NC)("How do I control my losses with Deriv Bot?"),
              description: [
                {
                  type: "text",
                  content: (0, s.NC)(
                    "There are several ways to control your losses with Deriv Bot. Here’s a simple example of how you can implement loss control in your strategy:"
                  ),
                },
                {
                  type: "image",
                  src: (0, o.oY)("loss_control_all_block.png"),
                  imageclass: "loss-control",
                },
                {
                  type: "text",
                  content: (0, s.NC)(
                    "<strong>1.</strong> Create the following variables and place them under <strong>Run once at start</strong>:"
                  ),
                },
                {
                  type: "text",
                  content: (0, s.NC)(
                    "• <strong>Stop loss threshold</strong>: Use this variable to store your loss limit. You can assign any amount you want. Your bot will stop when your losses hits or exceeds this amount."
                  ),
                },
                { type: "text", content: (0, s.NC)("Example:") },
                {
                  type: "image",
                  src: (0, o.oY)("loss_control_set_stop_loss.png"),
                },
                {
                  type: "text",
                  content: (0, s.NC)(
                    "• <strong>Current stake</strong>: Use this variable to store the stake amount. You can assign any amount you want, but it must be a positive number."
                  ),
                },
                { type: "text", content: (0, s.NC)("Example:") },
                {
                  type: "image",
                  src: (0, o.oY)("loss_control_set_current_stake.png"),
                },
                {
                  type: "text",
                  content: (0, s.NC)(
                    "This is how your trade parameters, variables, and trade options should look like:"
                  ),
                },
                {
                  type: "image",
                  src: (0, o.oY)("loss_control_trade_parameters.png"),
                },
                {
                  type: "text",
                  content: (0, s.NC)(
                    "<strong>2.</strong> Set the <strong>Purchase conditions</strong>. In this example, your bot will purchase a <strong>Rise</strong> contract when it starts and after a contract closes."
                  ),
                },
                {
                  type: "image",
                  src: (0, o.oY)("loss_control_purchase_conditions.png"),
                },
                {
                  type: "text",
                  content: (0, s.NC)(
                    "<strong>3.</strong> Use a logic block to check if <strong>Total profit/loss</strong> is more than the <strong>Stop loss threshold</strong> amount. You can find the <strong>Total profit/loss</strong> variable under <strong>Analysis > Stats</strong> on the <strong>Blocks menu</strong> on the left. Your bot will continue to purchase new contracts until the <strong>Total profit/loss</strong> amount exceeds the <strong>Stop loss threshold</strong> amount."
                  ),
                },
                {
                  type: "image",
                  src: (0, o.oY)("loss_control_restart_trade_conditions.png"),
                },
              ],
              search_id: "faq-10",
            },
            {
              title: (0, s.NC)(
                "Can I run Deriv Bot on multiple tabs in my web browser?"
              ),
              description: [
                {
                  type: "text",
                  content: (0, s.NC)(
                    'Yes, you can. However, there are limits on your account, such as maximum number of open positions and maximum aggregate payouts on open positions. So, just keep these limits in mind when opening multiple positions. You can find more info about these limits at <a href="https://app.deriv.com/account/account-limits" target="_blank">Settings > Account limits</a>.'
                  ),
                },
              ],
              search_id: "faq-11",
            },
            {
              title: (0, s.NC)("Can I trade cryptocurrencies on Deriv Bot?"),
              description: [
                {
                  type: "text",
                  content: (0, s.NC)(
                    "No, we don't offer cryptocurrencies on Deriv Bot."
                  ),
                },
              ],
              search_id: "faq-12",
            },
            {
              title: (0, s.NC)("Do you sell trading bots?"),
              description: [
                {
                  type: "text",
                  content: (0, s.NC)(
                    "No, we don't. However, you'll find quick strategies on Deriv Bot that'll help you build your own trading bot for free."
                  ),
                },
              ],
              search_id: "faq-13",
            },
            {
              title: (0, s.NC)("In which countries is Deriv Bot available?"),
              description: [
                {
                  type: "text",
                  content: (0, s.NC)(
                    'We offer our services in all countries, except for the ones <a href="https://deriv.com/tnc/general-terms.pdf" target="_blank">mentioned in our terms and conditions.</a>'
                  ),
                },
              ],
              search_id: "faq-14",
            },
            {
              title: (0, s.NC)(
                "If I close my web browser, will Deriv Bot continue to run?"
              ),
              description: [
                {
                  type: "text",
                  content: (0, s.NC)(
                    "No, Deriv Bot will stop running when your web browser is closed."
                  ),
                },
              ],
              search_id: "faq-15",
            },
            {
              title: (0, s.NC)(
                "What are the most popular strategies for automated trading?"
              ),
              description: [
                {
                  type: "text",
                  content: (0, s.NC)(
                    "Three of the most commonly used strategies in automated trading are Martingale, D'Alembert, and Oscar's Grind — you can find them all ready-made and waiting for you in Deriv Bot."
                  ),
                },
              ],
              search_id: "faq-16",
            },
            {
              title: (0, s.NC)("How do I build a trading bot?"),
              description: [
                {
                  type: "text",
                  content: (0, s.NC)(
                    '<a href="https://www.youtube.com/watch?v=QdI5zCkO4Gk&t=203s" target="_blank">Watch this video</a> to learn how to build a trading bot on Deriv Bot. Also, <a href="https://deriv.com/academy/blog/posts/how-to-build-a-basic-trading-bot-with-dbot/" target="_blank">check out this blog post</a> on building a trading bot.'
                  ),
                },
              ],
              search_id: "faq-17",
            },
          ],
          u = () => [
            {
              qs_name: "MARTINGALE",
              type: (0, s.NC)("About Martingale"),
              content: [
                (0, s.NC)("Exploring the Martingale strategy in Deriv Bot"),
                (0, s.NC)("An example of Martingale strategy"),
              ],
              search_id: `${n}-0`,
            },
            {
              qs_name: "D_ALEMBERT",
              type: (0, s.NC)("About D'Alembert"),
              content: [
                (0, s.NC)("Exploring the D’Alembert strategy in Deriv Bot"),
                (0, s.NC)("An example of D’Alembert strategy"),
              ],
              search_id: `${n}-1`,
            },
            {
              qs_name: "OSCARS_GRIND",
              type: (0, s.NC)("About Oscar's Grind"),
              content: [
                (0, s.NC)("Exploring the Oscar’s Grind strategy in Deriv Bot"),
                (0, s.NC)("An example of Oscar’s Grind strategy"),
              ],
              search_id: `${n}-2`,
            },
            {
              qs_name: "REVERSE_MARTINGALE",
              type: (0, s.NC)("About Reverse Martingale"),
              content: [
                (0, s.NC)(
                  "Exploring the Reverse Martingale strategy in Deriv Bot"
                ),
                (0, s.NC)("An example of Reverse Martingale strategy"),
              ],
              search_id: `${n}-3`,
            },
            {
              qs_name: "REVERSE_D_ALEMBERT",
              type: (0, s.NC)("About Reverse D’Alembert"),
              content: [
                (0, s.NC)(
                  "Exploring the Reverse D’Alembert strategy in Deriv Bot"
                ),
                (0, s.NC)("An example of Reverse D’Alembert strategy"),
              ],
              search_id: `${n}-4`,
            },
            {
              qs_name: "STRATEGY_1_3_2_6",
              type: (0, s.NC)("About 1-3-2-6"),
              content: [
                (0, s.NC)("Exploring the 1-3-2-6 strategy in Deriv Bot"),
                (0, s.NC)("An example of 1-3-2-6 strategy"),
              ],
              search_id: `${n}-5`,
            },
          ];
      },
      84006: function (e, t, i) {
        "use strict";
        i.d(t, { TJ: () => n, X7: () => a, _y: () => r, pw: () => s });
        var o = i(58902);
        let s = { key: "onboard_tour" };
        s.key;
        let r = (e, t) => {
            let i = document.querySelector("#db-toolbar__import-button");
            e && 1 === t
              ? null == i || i.classList.add("dbot-tour-blink")
              : null == i || i.classList.remove("dbot-tour-blink");
          },
          a = (e, t) => (0, o.Jp)(t, e),
          n = Object.freeze({ 0: "onboarding", 1: "bot_builder" });
      },
      21995: function (e, t, i) {
        "use strict";
        var o;
        i.d(t, { UR: () => c, oY: () => s });
        let s = (e) => `assets/images/${e}`,
          r = (e, t, i) => {
            window.Survicate &&
              (e && window.Survicate.track("userCountry", e),
              t && window.Survicate.track("accountType", t),
              i && window.Survicate.track("accountCreationDate", i));
          },
          a = !1,
          n = (e) => {
            a = e;
          },
          l = (e) => {
            let t = document.createElement("script");
            (t.id = "dbot-survicate"),
              (t.async = !0),
              (t.src =
                "https://survey.survicate.com/workspaces/83b651f6b3eca1ab4551d95760fe5deb/web_surveys.js"),
              (t.onload = e);
            let i = document.getElementsByTagName("script")[0];
            (null == i ? void 0 : i.parentNode)
              ? i.parentNode.insertBefore(t, i)
              : document.body.appendChild(t);
          },
          c = () => {
            if (a) return;
            n(!0);
            let e = localStorage.getItem("active_loginid"),
              t = JSON.parse(localStorage.getItem("accountsList")) || void 0,
              i = () => {
                if (e && t) {
                  let {
                    residence: i,
                    account_type: o,
                    created_at: s,
                  } = t[e] || {};
                  r(i, o, s);
                }
              };
            if (document.getElementById("dbot-survicate")) {
              let e = document.getElementById("survicate-box");
              e && (e.style.display = "block"), i();
            } else l(i);
          };
        (o = (function () {
          let e =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : "",
            t = window.location;
          if (!/^\/(br_)/.test(t.pathname)) return e;
          let i = e.startsWith("/") ? e : `/${e}`;
          return `/${t.pathname.split("/")[1]}${i}`;
        })("/")),
          (window.__webpack_public_path__ = ""),
          (window.__webpack_public_path__ = o);
      },
      42457: function (e, t, i) {
        "use strict";
        i.d(t, { _: () => o });
        let o = (e, t) =>
          new Promise((i) => {
            if (document.querySelector(e)) {
              i(document.querySelector(e));
              return;
            }
            let o = new MutationObserver(() => {
              document.querySelector(e) &&
                (i(document.querySelector(e)), o.disconnect());
            });
            o.observe(t ?? document.body, { childList: !0, subtree: !0 });
          });
      },
      18908: function (e, t, i) {
        "use strict";
        i.r(t), i.d(t, { default: () => s });
        var o = i(68949);
        let s = (() => {
          let e;
          let t = !1,
            i = (e) => {
              var t;
              null === (t = window.dataLayer) || void 0 === t || t.push(e);
            },
            s = (e, t, o) => {
              try {
                let s = `${e}-${t}`,
                  r = {
                    counters: `tr:${o.number_of_runs},\
                ts:${o.total_stake},\
                py:${o.total_payout},\
                lc:${o.lost_contracts},\
                wc:${o.won_contracts},\
                pr:${o.total_profit}`.replace(/\s/g, ""),
                    event: "dbot_run",
                    run_id: s,
                  };
                i(r);
              } catch (e) {
                console.warn("Error pushing run data to datalayer ", e);
              }
            };
          return {
            init: (i) => {
              if (!t) {
                (t = !0),
                  setTimeout(() => {
                    (function (e, t, i, o, s) {
                      (e[o] = e[o] || []),
                        e[o].push({
                          "gtm.start": new Date().getTime(),
                          event: "gtm.js",
                        });
                      let r = t.getElementsByTagName(i)[0],
                        a = t.createElement(i);
                      (a.defer = !0),
                        (a.src =
                          "https://www.googletagmanager.com/gtm.js?id=" +
                          s +
                          ("dataLayer" != o ? "&l=" + o : "")),
                        r.parentNode.insertBefore(a, r);
                    })(window, document, "script", "dataLayer", "GTM-NF7884S");
                  }, 3e3);
                try {
                  let {
                    run_panel: t,
                    transactions: r,
                    client: a,
                    common: n,
                  } = i;
                  (0, o.U5)(
                    () => t.is_running,
                    () => {
                      t.is_running &&
                        (clearTimeout(e),
                        (e = setTimeout(() => {
                          var e;
                          s(
                            null == a ? void 0 : a.loginid,
                            null == n
                              ? void 0
                              : null === (e = n.server_time) || void 0 === e
                              ? void 0
                              : e.unix(),
                            null == r ? void 0 : r.statistics
                          );
                        }, 500)));
                    }
                  );
                } catch (e) {
                  console.warn("Error initializing GTM reactions ", e);
                }
              }
            },
            pushDataLayer: i,
            onTransactionClosed: (e) => {
              i({
                event: "dbot_run_transaction",
                reference_id: (null == e ? void 0 : e.contract_id) ?? "",
              });
            },
            onRunBot: s,
          };
        })();
      },
      69103: function (e, t, i) {
        "use strict";
        i.d(t, { I: () => o, S: () => l });
        let o = {
            TEXT: "text",
            VIDEO: "video",
            IMAGE: "image",
            BLOCK: "block",
            EXAMPLE: "example",
          },
          { TEXT: s, IMAGE: r, BLOCK: a, EXAMPLE: n } = o,
          l = (e) => (
            (window.__webpack_public_path__ = e),
            {
              procedures_ifreturn: [
                { type: s },
                { type: a },
                { type: s },
                { type: n, example_id: "if-return" },
              ],
              math_arithmetic: [
                { type: s },
                { type: a },
                { type: s },
                { type: s },
                { type: s },
                { type: s },
                { type: s },
                { type: s },
              ],
              math_single: [
                { type: s },
                { type: a },
                { type: s },
                { type: s },
                { type: s },
                { type: s },
                { type: s },
                { type: s },
                { type: s },
              ],
              math_constrain: [
                { type: s },
                { type: a },
                { type: s },
                { type: s },
                { type: n, example_id: "constrain" },
              ],
              text_print: [{ type: s }, { type: a }, { type: s }],
              text_prompt_ext: [{ type: s }, { type: a }, { type: s }],
              tick_analysis: [{ type: s }, { type: a }],
              read_details: [
                { type: s },
                { type: a },
                { type: s },
                { type: s },
                { type: s },
                { type: s },
                { type: s },
                { type: s },
                { type: s },
                { type: s },
                { type: s },
                { type: s },
                { type: s },
                { type: s },
              ],
              last_digit: [{ type: s }, { type: a }],
              read_ohlc: [
                { type: s },
                { type: a },
                { type: s },
                { type: s },
                { type: s },
                { type: s },
                { type: s },
                { type: s },
                { type: n, example_id: "in_candle_list_read" },
              ],
              read_ohlc_obj: [
                { type: s },
                { type: a },
                { type: s },
                { type: s },
                { type: n, example_id: "read_candle_value" },
              ],
              check_direction: [
                { type: s },
                { type: a },
                { type: s },
                { type: s },
                { type: s },
              ],
              get_ohlc: [
                { type: s },
                { type: a },
                { type: s },
                { type: n, example_id: "get_candle" },
                { type: s },
              ],
              ohlc: [
                { type: s },
                { type: a },
                { type: s },
                { type: n, example_id: "candle_list_1" },
              ],
              ohlc_values: [
                { type: s },
                { type: a },
                { type: s },
                { type: n, example_id: "candle_list" },
              ],
              is_candle_black: [
                { type: s },
                { type: a },
                { type: s },
                { type: s },
                { type: s },
                { type: s },
                { type: s },
                { type: s },
                { type: s },
                {
                  type: r,
                  width: "100%",
                  url: `${window.__webpack_public_path__}assets/media/is_candle_black.jpeg`,
                },
                { type: s },
                {
                  type: r,
                  width: "100%",
                  url: `${window.__webpack_public_path__}assets/media/is_candle_black_1.jpeg`,
                },
                { type: s },
              ],
              ohlc_values_in_list: [
                { type: s },
                { type: a },
                { type: s },
                { type: s },
                { type: n, example_id: "candle_list_1" },
              ],
              variables_gets: [
                { type: s },
                { type: a },
                { type: s },
                { type: s },
                { type: s },
                { type: s },
                { type: s },
                { type: s },
                { type: s },
              ],
              variables_set: [
                { type: s },
                { type: a },
                { type: s },
                { type: s },
                { type: s },
                {
                  type: r,
                  width: "100%",
                  url: `${window.__webpack_public_path__}assets/media/create_variable.jpg`,
                },
                { type: s },
                {
                  type: r,
                  width: "100%",
                  url: `${window.__webpack_public_path__}assets/media/set_variable.png`,
                },
              ],
              epoch: [
                { type: s },
                { type: a },
                { type: s },
                { type: s },
                { type: s },
                { type: s },
                { type: s },
                { type: n, example_id: "epoch" },
              ],
              todatetime: [
                { type: s },
                { type: a },
                { type: s },
                { type: n, example_id: "todatetime" },
                { type: s },
              ],
              totimestamp: [
                { type: s },
                { type: a },
                { type: s },
                { type: n, example_id: "totimestamp" },
                { type: s },
              ],
              notify_telegram: [
                { type: s },
                { type: a },
                { type: s },
                { type: s },
                { type: s },
                { type: s },
                { type: s },
                { type: s },
                { type: s },
                { type: s },
                { type: s },
                { type: n, example_id: "notify_telegram" },
              ],
              console: [
                { type: s },
                { type: s },
                { type: s },
                { type: s },
                { type: s },
                { type: s },
              ],
              balance: [
                { type: s },
                { type: a },
                { type: s },
                { type: s },
                { type: s },
                { type: s },
                { type: s },
              ],
              sma_statement: [
                { type: s },
                { type: a },
                { type: s },
                {
                  type: r,
                  width: "60%",
                  url: `${window.__webpack_public_path__}assets/media/sma_formula.png`,
                },
                { type: s },
                { type: s },
                { type: s },
                { type: s },
                {
                  type: r,
                  width: "100%",
                  url: `${window.__webpack_public_path__}assets/media/sma_chart_1.png`,
                },
                { type: s },
                {
                  type: r,
                  width: "100%",
                  url: `${window.__webpack_public_path__}assets/media/sma_chart_2.png`,
                },
                { type: s },
                { type: s },
                { type: s },
                { type: s },
                { type: s },
                { type: n, example_id: "sma_block_example" },
                { type: s },
                { type: s },
                { type: n, example_id: "sma_block_example_1" },
                { type: s },
                { type: s },
                { type: n, example_id: "sma_array" },
                { type: s },
                { type: s },
                { type: s },
                {
                  type: r,
                  width: "100%",
                  url: `${window.__webpack_public_path__}assets/media/sma_array_explanation.jpeg`,
                },
              ],
              trade_definition: [
                { type: s },
                { type: s },
                { type: s },
                { type: s },
                { type: s },
                { type: s },
                { type: s },
                { type: s },
                { type: s },
                { type: s },
                { type: s },
                { type: s },
                { type: s },
                { type: s },
                { type: s },
                { type: s },
                { type: s },
                { type: a },
              ],
              trade_definition_tradeoptions: [{ type: s }, { type: a }],
              trade_definition_multiplier: [
                { type: s },
                { type: s },
                { type: s },
                { type: s },
              ],
              before_purchase: [{ type: s }, { type: a }, { type: s }],
              during_purchase: [
                { type: s },
                { type: a },
                { type: s },
                { type: n, example_id: "sell_available" },
              ],
              sell_at_market: [
                { type: s },
                { type: a },
                { type: s },
                { type: n, example_id: "sell_available" },
              ],
              after_purchase: [{ type: s }, { type: a }, { type: s }],
              trade_again: [
                { type: s },
                { type: a },
                { type: s },
                { type: n, example_id: "trade_again" },
              ],
              contract_check_result: [
                { type: s },
                { type: a },
                { type: s },
                { type: s },
                { type: n, example_id: "check_result" },
              ],
              sell_price: [
                { type: s },
                { type: a },
                { type: s },
                { type: n, example_id: "sell_pl" },
              ],
              controls_if: [
                { type: s },
                { type: a },
                { type: s },
                { type: n, example_id: "controls_if" },
                { type: s },
                { type: n, example_id: "compare_logic" },
                { type: n, example_id: "compare_logic_1" },
              ],
              logic_operation: [
                { type: s },
                { type: a },
                { type: s },
                { type: s },
                {
                  type: r,
                  width: "40%",
                  url: `${window.__webpack_public_path__}assets/media/logic.png`,
                },
              ],
              controls_whileUntil: [
                { type: s },
                { type: a },
                { type: s },
                { type: s },
                { type: n, example_id: "repeat_while" },
                { type: s },
                { type: n, example_id: "repeat_until" },
              ],
              controls_for: [
                { type: s },
                { type: a },
                { type: s },
                { type: n, example_id: "controls_for" },
                { type: s },
                { type: s },
              ],
              controls_forEach: [
                { type: s },
                { type: a },
                { type: s },
                { type: n, example_id: "controls_forEach" },
                { type: s },
                { type: s },
                { type: s },
              ],
              controls_flow_statements: [
                { type: s },
                { type: a },
                { type: s },
                { type: s },
                { type: n, example_id: "break_out" },
                { type: s },
                { type: n, example_id: "continue" },
              ],
            }
          );
      },
      58902: function (e, t, i) {
        "use strict";
        i.d(t, { $8: () => s, Jp: () => r, ev: () => a });
        let o = () => JSON.parse(localStorage.getItem("dbot_settings")),
          s = (e) => {
            let t = o();
            return t ? t[e] : null;
          },
          r = (e, t) => {
            let i = o() || {};
            (i[e] = t),
              localStorage.setItem("dbot_settings", JSON.stringify(i));
          },
          a = (e) => {
            let t = o() || {};
            delete t[e],
              localStorage.setItem("dbot_settings", JSON.stringify(t));
          };
      },
      33304: function (e, t, i) {
        "use strict";
        i.d(t, { F0: () => o });
        let o = "Deriv";
      },
      27179: function (e, t, i) {
        "use strict";
        i.d(t, { Yp: () => n, gb: () => a, kT: () => l });
        var o = i(30381),
          s = i.n(o);
        let r = (e) => s().unix(e).utc(),
          a = (e) =>
            e && s()(e).isValid()
              ? s().isMoment(e) && e.isValid() && e.isUTC()
                ? e
                : "number" == typeof e
                ? r(e)
                : s().utc(e)
              : s()().utc(),
          n = "YYYY-MM-DD HH:mm:ss [GMT]",
          l = "YYYY-MM-DD HH:mm:ss Z";
      },
      89606: function (e, t, i) {
        "use strict";
        i.d(t, { J: () => s });
        var o = i(85893);
        let s = (0, i(67294).memo)((e) => {
          let { icon: t, ...i } = e;
          return (0, o.jsx)("div", {
            className: "dummy-icon",
            ...i,
            children: (0, o.jsx)("img", {
              src: `assets/icons/${t}.svg`,
              alt: t,
              onError: (e) => {
                e.target.src = "assets/icons/IcDashboard.svg";
              },
            }),
          });
        });
      },
      18925: function () {},
    },
    t = {};
  function i(o) {
    var s = t[o];
    if (void 0 !== s) return s.exports;
    var r = (t[o] = { id: o, loaded: !1, exports: {} });
    return e[o].call(r.exports, r, r.exports, i), (r.loaded = !0), r.exports;
  }
  (i.m = e),
    (i.n = (e) => {
      var t = e && e.__esModule ? () => e.default : () => e;
      return i.d(t, { a: t }), t;
    }),
    (() => {
      var e,
        t = Object.getPrototypeOf
          ? (e) => Object.getPrototypeOf(e)
          : (e) => e.__proto__;
      i.t = function (o, s) {
        if (
          (1 & s && (o = this(o)),
          8 & s ||
            ("object" == typeof o &&
              o &&
              ((4 & s && o.__esModule) ||
                (16 & s && "function" == typeof o.then))))
        )
          return o;
        var r = Object.create(null);
        i.r(r);
        var a = {};
        e = e || [null, t({}), t([]), t(t)];
        for (
          var n = 2 & s && o;
          "object" == typeof n && !~e.indexOf(n);
          n = t(n)
        )
          Object.getOwnPropertyNames(n).forEach((e) => {
            a[e] = () => o[e];
          });
        return (a.default = () => o), i.d(r, a), r;
      };
    })(),
    (i.d = (e, t) => {
      for (var o in t)
        i.o(t, o) &&
          !i.o(e, o) &&
          Object.defineProperty(e, o, { enumerable: !0, get: t[o] });
    }),
    (i.f = {}),
    (i.e = (e) =>
      Promise.all(Object.keys(i.f).reduce((t, o) => (i.f[o](e, t), t), []))),
    (i.hmd = (e) => (
      (e = Object.create(e)).children || (e.children = []),
      Object.defineProperty(e, "exports", {
        enumerable: !0,
        set: () => {
          throw Error(
            "ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: " +
              e.id
          );
        },
      }),
      e
    )),
    (i.u = (e) =>
      "static/js/async/" +
      ({
        129: "OVER1-BOT-WITH-OVER3-REVOVERY-xml",
        307: "1-2025-$Orginal-DollarPrinterBot-2025-Version-$-(1)-xml",
        331: "2025-Alpha-Version-2025-xml",
        372: "2025-No-Martngale-bot-free-xml",
        462: "2025-UPDATED-DIGIT-EVEN-Version-Bot-xml",
        640: "2025-Binary-Expert-Version-pro-xml",
        677: "2025-BOT---0008---Over-Under-(1)-xml",
        68: "2025-Dp-Printer-Version1-xml",
        705: "Dp-Entry-point-Bot-V1-xml",
        817: "2025-Updated-Binary-V5-Expert-pro-xml",
        820: "2-2025-Updated-Expert-Speed-Bot-Version-(1)-(1)-xml",
        867: "dbot-collection",
        890: "Alpha-Ai-Two-Predictions-xml",
        996: "3-2025-Updated-Version-Of-Candle-Mine-xml",
      }[e] || e) +
      "." +
      {
        129: "8511e311",
        141: "4f901cc8",
        148: "5158bb91",
        165: "c3e9141e",
        232: "a2c0bee4",
        285: "1668b9a3",
        307: "3b1f5ddc",
        31: "eaf4bc67",
        327: "5faccb8a",
        331: "e931e1b0",
        333: "021e8636",
        372: "4fe0966c",
        378: "b44c17ba",
        462: "2f7bcad0",
        463: "ca7937d6",
        522: "336bdfc9",
        551: "9d07d655",
        565: "01993a98",
        572: "b49a8fc4",
        600: "fe39bc02",
        602: "48893d16",
        609: "2b1ec816",
        640: "7509f0eb",
        677: "68c4e4f6",
        68: "5541134e",
        705: "adaae67c",
        733: "6facdb30",
        745: "1de3ef64",
        753: "8e04b73a",
        817: "a9e45f22",
        820: "e08229cd",
        834: "51027a21",
        863: "f7671029",
        867: "66127a1b",
        890: "8cdbbdc6",
        892: "fd9d70f6",
        911: "88f700b8",
        932: "e4aae805",
        996: "c757373b",
      }[e] +
      ".js"),
    (i.miniCssF = (e) =>
      "static/css/async/" +
      e +
      "." +
      {
        141: "83b82dba",
        148: "ce768c78",
        232: "731a2b21",
        285: "57dfb825",
        31: "6c2cc20f",
        333: "83b82dba",
        522: "647ee573",
        565: "024ad2e1",
        572: "83b22a30",
        600: "e468adc3",
        745: "82237af8",
        834: "943f1ac1",
        863: "3a1e38d1",
        932: "cb28e558",
      }[e] +
      ".css"),
    (i.h = () => "f79fc86b66212b60"),
    (() => {
      i.g = (() => {
        if ("object" == typeof globalThis) return globalThis;
        try {
          return this || Function("return this")();
        } catch (e) {
          if ("object" == typeof window) return window;
        }
      })();
    })(),
    (i.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t)),
    (() => {
      var e = {},
        t = "bot:";
      i.l = function (o, s, r, a) {
        if (e[o]) {
          e[o].push(s);
          return;
        }
        if (void 0 !== r)
          for (
            var n, l, c = document.getElementsByTagName("script"), d = 0;
            d < c.length;
            d++
          ) {
            var u = c[d];
            if (
              u.getAttribute("src") == o ||
              u.getAttribute("data-webpack") == t + r
            ) {
              n = u;
              break;
            }
          }
        n ||
          ((l = !0),
          ((n = document.createElement("script")).charset = "utf-8"),
          (n.timeout = 120),
          i.nc && n.setAttribute("nonce", i.nc),
          n.setAttribute("data-webpack", t + r),
          (n.src = o)),
          (e[o] = [s]);
        var h = function (t, i) {
            (n.onerror = n.onload = null), clearTimeout(p);
            var s = e[o];
            if (
              (delete e[o],
              n.parentNode && n.parentNode.removeChild(n),
              s &&
                s.forEach(function (e) {
                  return e(i);
                }),
              t)
            )
              return t(i);
          },
          p = setTimeout(
            h.bind(null, void 0, { type: "timeout", target: n }),
            12e4
          );
        (n.onerror = h.bind(null, n.onerror)),
          (n.onload = h.bind(null, n.onload)),
          l && document.head.appendChild(n);
      };
    })(),
    (i.r = function (e) {
      "undefined" != typeof Symbol &&
        Symbol.toStringTag &&
        Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }),
        Object.defineProperty(e, "__esModule", { value: !0 });
    }),
    (i.nmd = function (e) {
      return (e.paths = []), e.children || (e.children = []), e;
    }),
    (() => {
      var e = [];
      i.O = function (t, o, s, r) {
        if (o) {
          r = r || 0;
          for (var a = e.length; a > 0 && e[a - 1][2] > r; a--) e[a] = e[a - 1];
          e[a] = [o, s, r];
          return;
        }
        for (var n = 1 / 0, a = 0; a < e.length; a++) {
          for (
            var o = e[a][0], s = e[a][1], r = e[a][2], l = !0, c = 0;
            c < o.length;
            c++
          )
            (!1 & r || n >= r) &&
            Object.keys(i.O).every(function (e) {
              return i.O[e](o[c]);
            })
              ? o.splice(c--, 1)
              : ((l = !1), r < n && (n = r));
          if (l) {
            e.splice(a--, 1);
            var d = s();
            void 0 !== d && (t = d);
          }
        }
        return t;
      };
    })(),
    (i.p = "/"),
    (i.rv = () => "1.2.7"),
    (() => {
      if ("undefined" != typeof document) {
        var e = function (e, t, o, s, r) {
            var a = document.createElement("link");
            return (
              (a.rel = "stylesheet"),
              (a.type = "text/css"),
              i.nc && (a.nonce = i.nc),
              (a.onerror = a.onload =
                function (i) {
                  if (((a.onerror = a.onload = null), "load" === i.type)) s();
                  else {
                    var o = i && ("load" === i.type ? "missing" : i.type),
                      n = (i && i.target && i.target.href) || t,
                      l = Error(
                        "Loading CSS chunk " + e + " failed.\\n(" + n + ")"
                      );
                    (l.code = "CSS_CHUNK_LOAD_FAILED"),
                      (l.type = o),
                      (l.request = n),
                      a.parentNode && a.parentNode.removeChild(a),
                      r(l);
                  }
                }),
              (a.href = t),
              o
                ? o.parentNode.insertBefore(a, o.nextSibling)
                : document.head.appendChild(a),
              a
            );
          },
          t = function (e, t) {
            for (
              var i = document.getElementsByTagName("link"), o = 0;
              o < i.length;
              o++
            ) {
              var s = i[o],
                r = s.getAttribute("data-href") || s.getAttribute("href");
              if ("stylesheet" === s.rel && (r === e || r === t)) return s;
            }
            for (
              var a = document.getElementsByTagName("style"), o = 0;
              o < a.length;
              o++
            ) {
              var s = a[o],
                r = s.getAttribute("data-href");
              if (r === e || r === t) return s;
            }
          },
          o = { 980: 0 };
        i.f.miniCss = function (s, r) {
          if (o[s]) r.push(o[s]);
          else if (
            0 !== o[s] &&
            {
              600: 1,
              572: 1,
              834: 1,
              232: 1,
              522: 1,
              863: 1,
              745: 1,
              932: 1,
              565: 1,
              31: 1,
              333: 1,
              141: 1,
              148: 1,
              285: 1,
            }[s]
          )
            r.push(
              (o[s] = new Promise(function (o, r) {
                var a = i.miniCssF(s),
                  n = i.p + a;
                if (t(a, n)) return o();
                e(s, n, null, o, r);
              }).then(
                function () {
                  o[s] = 0;
                },
                function (e) {
                  throw (delete o[s], e);
                }
              ))
            );
        };
      }
    })(),
    (() => {
      var e = { 980: 0 };
      (i.f.j = function (t, o) {
        var s = i.o(e, t) ? e[t] : void 0;
        if (0 !== s) {
          if (s) o.push(s[2]);
          else {
            var r = new Promise((i, o) => (s = e[t] = [i, o]));
            o.push((s[2] = r));
            var a = i.p + i.u(t),
              n = Error();
            i.l(
              a,
              function (o) {
                if (i.o(e, t) && (0 !== (s = e[t]) && (e[t] = void 0), s)) {
                  var r = o && ("load" === o.type ? "missing" : o.type),
                    a = o && o.target && o.target.src;
                  (n.message =
                    "Loading chunk " + t + " failed.\n(" + r + ": " + a + ")"),
                    (n.name = "ChunkLoadError"),
                    (n.type = r),
                    (n.request = a),
                    s[1](n);
                }
              },
              "chunk-" + t,
              t
            );
          }
        }
      }),
        (i.O.j = (t) => 0 === e[t]);
      var t = (t, o) => {
          var s,
            r,
            [a, n, l] = o,
            c = 0;
          if (a.some((t) => 0 !== e[t])) {
            for (s in n) i.o(n, s) && (i.m[s] = n[s]);
            if (l) var d = l(i);
          }
          for (t && t(o); c < a.length; c++)
            (r = a[c]), i.o(e, r) && e[r] && e[r][0](), (e[r] = 0);
          return i.O(d);
        },
        o = (self.webpackChunkbot = self.webpackChunkbot || []);
      o.forEach(t.bind(null, 0)), (o.push = t.bind(null, o.push.bind(o)));
    })(),
    (i.ruid = "bundler=rspack@1.2.7");
  var o = i.O(void 0, ["361", "118", "352"], function () {
    return i(3937);
  });
  o = i.O(o);
})();
